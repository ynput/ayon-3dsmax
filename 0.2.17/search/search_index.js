var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"3dsMax addon","text":"<p>3dsMax integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_max<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>colorspace</li> <li>lib</li> <li>lib_renderproducts</li> <li>lib_rendersettings</li> <li>menu</li> <li>pipeline</li> <li>plugin</li> <li>preview_animation</li> </ul> </li> <li>hooks<ul> <li>force_startup_script</li> <li>inject_python</li> <li>pre_copy_mxp</li> <li>set_paths</li> </ul> </li> <li>mxp</li> <li>plugins<ul> <li>create<ul> <li>create_camera</li> <li>create_maxScene</li> <li>create_model</li> <li>create_pointcache</li> <li>create_pointcloud</li> <li>create_redshift_proxy</li> <li>create_render</li> <li>create_review</li> <li>create_tyflow</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_camera_fbx</li> <li>load_image</li> <li>load_max_scene</li> <li>load_model</li> <li>load_model_fbx</li> <li>load_model_obj</li> <li>load_model_usd</li> <li>load_pointcache</li> <li>load_pointcache_ornatrix</li> <li>load_pointcloud</li> <li>load_redshift_proxy</li> <li>load_tycache</li> </ul> </li> <li>publish<ul> <li>collect_current_file</li> <li>collect_frame_range</li> <li>collect_members</li> <li>collect_render</li> <li>collect_review</li> <li>collect_tycache_attributes</li> <li>collect_workfile</li> <li>extract_alembic</li> <li>extract_fbx</li> <li>extract_max_scene_raw</li> <li>extract_model_obj</li> <li>extract_model_usd</li> <li>extract_pointcloud</li> <li>extract_redshift_proxy</li> <li>extract_review_animation</li> <li>extract_thumbnail</li> <li>extract_tycache</li> <li>increment_workfile_version</li> <li>save_scene</li> <li>save_scenes_for_cameras</li> <li>validate_attributes</li> <li>validate_camera_attributes</li> <li>validate_camera_contents</li> <li>validate_extended_viewport</li> <li>validate_frame_range</li> <li>validate_instance_has_members</li> <li>validate_instance_in_context</li> <li>validate_loaded_plugin</li> <li>validate_mesh_has_uv</li> <li>validate_model_contents</li> <li>validate_model_name</li> <li>validate_no_animation</li> <li>validate_pointcloud</li> <li>validate_renderable_camera</li> <li>validate_renderer_redshift_proxy</li> <li>validate_renderpasses</li> <li>validate_resolution_setting</li> <li>validate_scene_saved</li> <li>validate_tyflow_data</li> </ul> </li> </ul> </li> <li>startup<ul> <li>startup</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>create_review_settings</li> <li>imageio</li> <li>main</li> <li>publishers</li> <li>render_settings</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_max/index.html","title":"ayon_max","text":""},{"location":"autoapi/client/ayon_max/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_max/mxp.html","title":"mxp","text":""},{"location":"autoapi/client/ayon_max/mxp.html#client.ayon_max.mxp.default_mxp_template","title":"<code>default_mxp_template()</code>","text":"<p>Return text script for the path configuration if users do not enable project creation in AYON project setting</p> Source code in <code>client/ayon_max/mxp.py</code> <pre><code>def default_mxp_template():\n    \"\"\"Return text script for the path configuration if\n    users do not enable project creation in AYON project\n    setting\n    \"\"\"\n    mxp_template = \"\\n\".join((\n        '[Directories]',\n        'Animations= ./',\n        'Archives=./',\n        'AutoBackup=./',\n        'BitmapProxies=./',\n        'Fluid Simulations=./',\n        'Images=./',\n        'MaxStart=./',\n        'Previews=./',\n        'RenderAssets=./',\n        'RenderOutput= ./renders/3dsmax',\n        'Scenes=./',\n        'Sounds=./',\n        '[XReferenceDirs]',\n        'Dir1=./'\n    ))\n    return mxp_template\n</code></pre>"},{"location":"autoapi/client/ayon_max/version.html","title":"version","text":"<p>Package declaring AYON addon 'max' version.</p>"},{"location":"autoapi/client/ayon_max/api/index.html","title":"api","text":"<p>Public API for 3dsmax</p>"},{"location":"autoapi/client/ayon_max/api/index.html#client.ayon_max.api.MaxHost","title":"<code>MaxHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>class MaxHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n\n    name = \"max\"\n    menu = None\n\n    def __init__(self):\n        super(MaxHost, self).__init__()\n        self._op_events = {}\n        self._has_been_setup = False\n\n    def get_app_information(self):\n        from ayon_core.host import ApplicationInformation\n\n        (\n            _rel_number,\n            _api_version,\n            _rel_rev_number,\n\n            _major_version,\n            _update_version,\n            _hotfix_number,\n            _build_number,\n\n            year_version,\n            product_version,\n        ) = rt.maxVersion()\n        version = f\"{year_version}{product_version}\"\n        return ApplicationInformation(\n            app_name=\"3ds Max\",\n            app_version=version,\n        )\n\n    def install(self):\n        pyblish.api.register_host(\"max\")\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        _set_project()\n        _set_autobackup_dir()\n\n        self.menu = AYONMenu()\n\n        register_event_callback(\"workfile.open.before\", on_before_open)\n        register_event_callback(\"workfile.open.after\", on_after_open)\n        register_event_callback(\"before.save\", before_save)\n        register_event_callback(\"taskChanged\", self.on_task_changed)\n        self._has_been_setup = True\n        self._register_callbacks()\n\n    def workfile_has_unsaved_changes(self):\n        return rt.getSaveRequired()\n\n    def get_workfile_extensions(self):\n        return [\".max\"]\n\n    def save_workfile(self, dst_path=None):\n        rt.saveMaxFile(dst_path)\n        return dst_path\n\n    def open_workfile(self, filepath):\n        rt.checkForSave()\n        rt.loadMaxFile(filepath)\n        return filepath\n\n    def get_current_workfile(self):\n        return os.path.join(rt.maxFilePath, rt.maxFileName)\n\n    def get_containers(self):\n        return ls()\n\n    def _register_callbacks(self):\n        rt.callbacks.removeScripts(id=rt.name(\"AyonCallbacks\"))\n        rt.callbacks.addScript(\n            rt.Name('welcomeScreenDone'),\n            on_new, id=rt.name(\"AyonCallbacks\")\n        )\n        rt.callbacks.addScript(\n            rt.Name('systemPostNew'),\n            lib.set_context_setting,\n            id=rt.name(\"AyonCallbacks\")\n        )\n        rt.callbacks.addScript(\n            rt.Name('postWorkspaceChange'),\n            self._deferred_menu_creation,\n            id=rt.name(\"AyonCallbacks\"))\n        rt.NodeEventCallback(\n            nameChanged=lib.update_modifier_node_names)\n\n    def _deferred_menu_creation(self):\n        self.log.info(\"Building menu ...\")\n        self.menu = AYONMenu()\n\n    @staticmethod\n    def create_context_node():\n        \"\"\"Helper for creating context holding node.\"\"\"\n\n        root_scene = rt.rootScene\n\n        create_attr_script = (\"\"\"\nattributes \"OpenPypeContext\"\n(\n    parameters main rollout:params\n    (\n        context type: #string\n    )\n\n    rollout params \"OpenPype Parameters\"\n    (\n        editText editTextContext \"Context\" type: #string\n    )\n)\n        \"\"\")\n\n        attr = rt.execute(create_attr_script)\n        rt.custAttributes.add(root_scene, attr)\n\n        return root_scene.OpenPypeContext.context\n\n    def update_context_data(self, data, changes):\n        try:\n            _ = rt.rootScene.OpenPypeContext.context\n        except AttributeError:\n            # context node doesn't exists\n            self.create_context_node()\n\n        rt.rootScene.OpenPypeContext.context = json.dumps(data)\n\n    def get_context_data(self):\n        try:\n            context = rt.rootScene.OpenPypeContext.context\n        except AttributeError:\n            # context node doesn't exists\n            context = self.create_context_node()\n        if not context:\n            context = \"{}\"\n        return json.loads(context)\n\n    def on_task_changed(self):\n        if lib.is_headless():\n            return\n\n        ayon_menu = self.menu.menu\n        if ayon_menu is not None:\n            actions = ayon_menu.actions()\n            context_action = actions[0]\n            context_label = lib.get_context_label()\n            context_action.setText(f\"{context_label}\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/index.html#client.ayon_max.api.MaxHost.create_context_node","title":"<code>create_context_node()</code>  <code>staticmethod</code>","text":"<p>Helper for creating context holding node.</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>    @staticmethod\n    def create_context_node():\n        \"\"\"Helper for creating context holding node.\"\"\"\n\n        root_scene = rt.rootScene\n\n        create_attr_script = (\"\"\"\nattributes \"OpenPypeContext\"\n(\n    parameters main rollout:params\n    (\n        context type: #string\n    )\n\n    rollout params \"OpenPype Parameters\"\n    (\n        editText editTextContext \"Context\" type: #string\n    )\n)\n        \"\"\")\n\n        attr = rt.execute(create_attr_script)\n        rt.custAttributes.add(root_scene, attr)\n\n        return root_scene.OpenPypeContext.context\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/index.html#client.ayon_max.api.get_all_children","title":"<code>get_all_children(parent, node_type=None)</code>","text":"<p>Handy function to get all the children of a given node</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>3dsmax Node1</code> <p>Node to get all children of.</p> required <code>node_type</code> <code>None, runtime.class</code> <p>give class to check for e.g. rt.FFDBox/rt.GeometryClass etc.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>list of all children of the parent node</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_all_children(parent, node_type=None):\n    \"\"\"Handy function to get all the children of a given node\n\n    Args:\n        parent (3dsmax Node1): Node to get all children of.\n        node_type (None, runtime.class): give class to check for\n            e.g. rt.FFDBox/rt.GeometryClass etc.\n\n    Returns:\n        list: list of all children of the parent node\n    \"\"\"\n    def list_children(node):\n        children = []\n        for c in node.Children:\n            children.append(c)\n            children = children + list_children(c)\n        return children\n    child_list = list_children(parent)\n\n    return ([x for x in child_list if rt.SuperClassOf(x) == node_type]\n            if node_type else child_list)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/index.html#client.ayon_max.api.lsattr","title":"<code>lsattr(attr, value=None, root=None)</code>","text":"<p>List nodes having attribute with specified value.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Attribute name to match.</p> required <code>value</code> <code>(str, Optional)</code> <p>Value to match, of omitted, all nodes with specified attribute are returned no matter of value.</p> <code>None</code> <code>root</code> <code>(str, Optional)</code> <p>Root node name. If omitted, scene root is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>list of nodes.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def lsattr(\n        attr: str,\n        value: Union[str, None] = None,\n        root: Union[str, None] = None) -&gt; list:\n    \"\"\"List nodes having attribute with specified value.\n\n    Args:\n        attr (str): Attribute name to match.\n        value (str, Optional): Value to match, of omitted, all nodes\n            with specified attribute are returned no matter of value.\n        root (str, Optional): Root node name. If omitted, scene root is used.\n\n    Returns:\n        list of nodes.\n    \"\"\"\n    root = rt.RootNode if root is None else rt.GetNodeByName(root)\n\n    def output_node(node, nodes):\n        nodes.append(node)\n        for child in node.Children:\n            output_node(child, nodes)\n\n    nodes = []\n    output_node(root, nodes)\n    return [\n        n for n in nodes\n        if rt.GetUserProp(n, attr) == value\n    ] if value else [\n        n for n in nodes\n        if rt.GetUserProp(n, attr)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_max/api/action.html#client.ayon_max.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid objects in Blender when a publish plug-in failed.</p> Source code in <code>client/ayon_max/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid objects in Blender when a publish plug-in failed.\"\"\"\n    label = \"Select Invalid\"\n    on = \"failed\"\n    icon = \"search\"\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(context,\n                                                               plugin=plugin)\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes...\")\n        invalid = list()\n        for instance in errored_instances:\n            invalid_nodes = plugin.get_invalid(instance)\n            if invalid_nodes:\n                if isinstance(invalid_nodes, (list, tuple)):\n                    invalid.extend(invalid_nodes)\n                else:\n                    self.log.warning(\n                        \"Failed plug-in doesn't have any selectable objects.\"\n                    )\n\n        if not invalid:\n            self.log.info(\"No invalid nodes found.\")\n            return\n        invalid_names = [obj.name for obj in invalid if not isinstance(obj, tuple)]\n        if not invalid_names:\n            invalid_names = [obj.name for obj, _ in invalid]\n            invalid = [obj for obj, _ in invalid]\n        self.log.info(\n            \"Selecting invalid objects: %s\", \", \".join(invalid_names)\n        )\n\n        rt.Select(invalid)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/colorspace.html","title":"colorspace","text":""},{"location":"autoapi/client/ayon_max/api/colorspace.html#client.ayon_max.api.colorspace.ARenderProduct","title":"<code>ARenderProduct</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_max/api/colorspace.py</code> <pre><code>class ARenderProduct(object):\n\n    def __init__(self):\n        \"\"\"Constructor.\"\"\"\n        # Initialize\n        self.layer_data = self._get_layer_data()\n        self.layer_data.products = self.get_colorspace_data()\n\n    def _get_layer_data(self):\n        return LayerMetadata(\n            frameStart=int(rt.rendStart),\n            frameEnd=int(rt.rendEnd),\n        )\n\n    def get_colorspace_data(self):\n        \"\"\"To be implemented by renderer class.\n        This should return a list of RenderProducts.\n        Returns:\n            list: List of RenderProduct\n        \"\"\"\n        colorspace_data = [\n            RenderProduct(\n                colorspace=\"sRGB\",\n                view=\"ACES 1.0\",\n                productName=\"\"\n            )\n        ]\n        return colorspace_data\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/colorspace.html#client.ayon_max.api.colorspace.ARenderProduct.__init__","title":"<code>__init__()</code>","text":"<p>Constructor.</p> Source code in <code>client/ayon_max/api/colorspace.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructor.\"\"\"\n    # Initialize\n    self.layer_data = self._get_layer_data()\n    self.layer_data.products = self.get_colorspace_data()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/colorspace.html#client.ayon_max.api.colorspace.ARenderProduct.get_colorspace_data","title":"<code>get_colorspace_data()</code>","text":"<p>To be implemented by renderer class. This should return a list of RenderProducts. Returns:     list: List of RenderProduct</p> Source code in <code>client/ayon_max/api/colorspace.py</code> <pre><code>def get_colorspace_data(self):\n    \"\"\"To be implemented by renderer class.\n    This should return a list of RenderProducts.\n    Returns:\n        list: List of RenderProduct\n    \"\"\"\n    colorspace_data = [\n        RenderProduct(\n            colorspace=\"sRGB\",\n            view=\"ACES 1.0\",\n            productName=\"\"\n        )\n    ]\n    return colorspace_data\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/colorspace.html#client.ayon_max.api.colorspace.LayerMetadata","title":"<code>LayerMetadata</code>","text":"<p>               Bases: <code>object</code></p> <p>Data class for Render Layer metadata.</p> Source code in <code>client/ayon_max/api/colorspace.py</code> <pre><code>@attr.s\nclass LayerMetadata(object):\n    \"\"\"Data class for Render Layer metadata.\"\"\"\n    frameStart = attr.ib()\n    frameEnd = attr.ib()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/colorspace.html#client.ayon_max.api.colorspace.RenderProduct","title":"<code>RenderProduct</code>","text":"<p>               Bases: <code>object</code></p> <p>Getting Colorspace as Specific Render Product Parameter for submitting publish job.</p> Source code in <code>client/ayon_max/api/colorspace.py</code> <pre><code>@attr.s\nclass RenderProduct(object):\n    \"\"\"Getting Colorspace as\n    Specific Render Product Parameter for submitting\n    publish job.\n    \"\"\"\n    colorspace = attr.ib()                      # colorspace\n    view = attr.ib()\n    productName = attr.ib(default=None)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html","title":"lib","text":"<p>Library of functions useful for 3dsmax pipeline.</p>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.convert_unit_scale","title":"<code>convert_unit_scale()</code>","text":"<p>Convert system unit scale in 3dsMax for fbx export</p> <p>Returns:</p> Name Type Description <code>str</code> <p>unit scale</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def convert_unit_scale():\n    \"\"\"Convert system unit scale in 3dsMax\n    for fbx export\n\n    Returns:\n        str: unit scale\n    \"\"\"\n    unit_scale_dict = {\n        \"millimeters\": \"mm\",\n        \"centimeters\": \"cm\",\n        \"meters\": \"m\",\n        \"kilometers\": \"km\"\n    }\n    current_unit_scale = rt.Execute(\"units.MetricType as string\")\n    return unit_scale_dict[current_unit_scale]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.ensure_sme_editor_active","title":"<code>ensure_sme_editor_active()</code>","text":"<p>Ensure that Slate Material Editor is active during context</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef ensure_sme_editor_active():\n    \"\"\"Ensure that Slate Material Editor is active during context\n    \"\"\"\n    was_open = rt.sme.isOpen()\n    try:\n        if not was_open:\n            rt.sme.open()\n        yield\n    finally:\n        if not was_open:\n            rt.sme.close()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.find_plugins","title":"<code>find_plugins(search_string)</code>","text":"<p>Find if a plugin is loaded in 3dsMax</p> <p>Parameters:</p> Name Type Description Default <code>search_string</code> <code>str</code> <p>string to search for</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if found, False otherwise</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def find_plugins(search_string: str) -&gt; bool:\n    \"\"\"Find if a plugin is loaded in 3dsMax\n\n    Args:\n        search_string (str): string to search for\n\n    Returns:\n        bool: True if found, False otherwise\n    \"\"\"\n    if any(search_string in plugin for plugin in get_plugins()):\n        return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_all_children","title":"<code>get_all_children(parent, node_type=None)</code>","text":"<p>Handy function to get all the children of a given node</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>3dsmax Node1</code> <p>Node to get all children of.</p> required <code>node_type</code> <code>None, runtime.class</code> <p>give class to check for e.g. rt.FFDBox/rt.GeometryClass etc.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>list of all children of the parent node</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_all_children(parent, node_type=None):\n    \"\"\"Handy function to get all the children of a given node\n\n    Args:\n        parent (3dsmax Node1): Node to get all children of.\n        node_type (None, runtime.class): give class to check for\n            e.g. rt.FFDBox/rt.GeometryClass etc.\n\n    Returns:\n        list: list of all children of the parent node\n    \"\"\"\n    def list_children(node):\n        children = []\n        for c in node.Children:\n            children.append(c)\n            children = children + list_children(c)\n        return children\n    child_list = list_children(parent)\n\n    return ([x for x in child_list if rt.SuperClassOf(x) == node_type]\n            if node_type else child_list)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_current_renderer","title":"<code>get_current_renderer()</code>","text":"Notes <p>Get current renderer for Max</p> <p>Returns:</p> Type Description <p>\"{Current Renderer}:{Current Renderer}\"</p> <p>e.g. \"Redshift_Renderer:Redshift_Renderer\"</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_current_renderer():\n    \"\"\"\n    Notes:\n        Get current renderer for Max\n\n    Returns:\n        \"{Current Renderer}:{Current Renderer}\"\n        e.g. \"Redshift_Renderer:Redshift_Renderer\"\n    \"\"\"\n    return rt.renderers.production\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_fps_for_current_context","title":"<code>get_fps_for_current_context()</code>","text":"<p>Get fps that should be set for current context.</p> Todos <ul> <li>Skip project value.</li> <li>Merge logic with 'get_frame_range' and 'reset_scene_resolution' -&gt;     all the values in the functions can be collected at one place as     they have same requirements.</li> </ul> <p>Returns:</p> Type Description <p>Union[int, float]: FPS value.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_fps_for_current_context():\n    \"\"\"Get fps that should be set for current context.\n\n    Todos:\n        - Skip project value.\n        - Merge logic with 'get_frame_range' and 'reset_scene_resolution' -&gt;\n            all the values in the functions can be collected at one place as\n            they have same requirements.\n\n    Returns:\n        Union[int, float]: FPS value.\n    \"\"\"\n    task_entity = get_current_task_entity(fields={\"attrib\"})\n    return task_entity[\"attrib\"][\"fps\"]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_frame_range","title":"<code>get_frame_range(task_entity=None)</code>","text":"<p>Get the current task frame range and handles</p> <p>Parameters:</p> Name Type Description Default <code>task_entity</code> <code>dict</code> <p>Task Entity.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Union[Dict[str, Any], None]</code> <p>with frame start, frame end, handle start, handle end.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_frame_range(task_entity=None) -&gt; Union[Dict[str, Any], None]:\n    \"\"\"Get the current task frame range and handles\n\n    Args:\n        task_entity (dict): Task Entity.\n\n    Returns:\n        dict: with frame start, frame end, handle start, handle end.\n    \"\"\"\n    # Set frame start/end\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib\"})\n    task_attributes = task_entity[\"attrib\"]\n    frame_start = int(task_attributes[\"frameStart\"])\n    frame_end = int(task_attributes[\"frameEnd\"])\n    handle_start = int(task_attributes[\"handleStart\"])\n    handle_end = int(task_attributes[\"handleEnd\"])\n    frame_start_handle = frame_start - handle_start\n    frame_end_handle = frame_end + handle_end\n\n    return {\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"frameStartHandle\": frame_start_handle,\n        \"frameEndHandle\": frame_end_handle,\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_main_window","title":"<code>get_main_window()</code>","text":"<p>Acquire Max's main window</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_main_window():\n    \"\"\"Acquire Max's main window\"\"\"\n    from qtpy import QtWidgets\n    top_widgets = QtWidgets.QApplication.topLevelWidgets()\n    name = \"QmaxApplicationWindow\"\n    for widget in top_widgets:\n        if (\n            widget.inherits(\"QMainWindow\")\n            and widget.metaObject().className() == name\n        ):\n            return widget\n    raise RuntimeError('Count not find 3dsMax main window.')\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_max_version","title":"<code>get_max_version()</code>","text":"<p>Args: get max version date for deadline</p> <p>Returns:</p> Type Description <p>max_info[7] = max version date</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_max_version():\n    \"\"\"\n    Args:\n    get max version date for deadline\n\n    Returns:\n        #(25000, 62, 0, 25, 0, 0, 997, 2023, \"\")\n        max_info[7] = max version date\n    \"\"\"\n    max_info = rt.MaxVersion()\n    return max_info[7]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_max_version--25000-62-0-25-0-0-997-2023","title":"(25000, 62, 0, 25, 0, 0, 997, 2023, \"\")","text":""},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_multipass_setting","title":"<code>get_multipass_setting(renderer, project_setting=None)</code>","text":"<p>Get the multipass setting for the given renderer.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>str</code> <p>The name of the renderer.</p> required <code>project_setting</code> <code>dict</code> <p>The project settings. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if multipass is enabled, False otherwise.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_multipass_setting(renderer, project_setting=None):\n    \"\"\"Get the multipass setting for the given renderer.\n\n    Args:\n        renderer (str): The name of the renderer.\n        project_setting (dict, optional): The project settings. Defaults to None.\n\n    Returns:\n        bool: True if multipass is enabled, False otherwise.\n    \"\"\"\n    if project_setting is None:\n        project_setting = get_project_settings(\n            get_current_project_name()\n        )\n    render_settings = (\n        project_setting[\"max\"][\"RenderSettings\"]\n    )\n    if renderer.startswith(\"V_Ray_\"):\n        vray_render_setting = render_settings.get(\"vray_render_settings\", {})\n        return (\n            vray_render_setting.get(\"separate_render_channels\", False)\n        )\n    elif renderer == \"Redshift_Renderer\":\n        redshift_render_setting = render_settings.get(\"redshift_render_settings\", {})\n        return (\n            redshift_render_setting.get(\"separate_aov_files\", False)\n        )\n\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_namespace","title":"<code>get_namespace(container_name)</code>","text":"<p>Get the namespace and name of the sub-container</p> <p>Parameters:</p> Name Type Description Default <code>container_name</code> <code>str</code> <p>the name of master container</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>when there is no master container found</p> <p>Returns:</p> Name Type Description <code>namespace</code> <code>str</code> <p>namespace of the sub-container</p> <code>name</code> <code>str</code> <p>name of the sub-container</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_namespace(container_name):\n    \"\"\"Get the namespace and name of the sub-container\n\n    Args:\n        container_name (str): the name of master container\n\n    Raises:\n        RuntimeError: when there is no master container found\n\n    Returns:\n        namespace (str): namespace of the sub-container\n        name (str): name of the sub-container\n    \"\"\"\n    node = rt.getNodeByName(container_name)\n    if not node:\n        raise RuntimeError(\"Master Container Not Found..\")\n    name = rt.getUserProp(node, \"name\")\n    namespace = rt.getUserProp(node, \"namespace\")\n    return namespace, name\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_plugins","title":"<code>get_plugins()</code>","text":"<p>Get all loaded plugins in 3dsMax</p> <p>Returns:</p> Name Type Description <code>plugin_info_list</code> <code>list</code> <p>a list of loaded plugins</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_plugins() -&gt; list:\n    \"\"\"Get all loaded plugins in 3dsMax\n\n    Returns:\n        plugin_info_list: a list of loaded plugins\n    \"\"\"\n    manager = rt.PluginManager\n    count = manager.pluginDllCount\n    plugin_info_list = []\n    for p in range(1, count + 1):\n        plugin_info = manager.pluginDllName(p)\n        plugin_info_list.append(plugin_info)\n\n    return plugin_info_list\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_target_sme_view","title":"<code>get_target_sme_view(target_view)</code>","text":"<p>summary</p> <p>Parameters:</p> Name Type Description Default <code>target_view</code> <code>int</code> <p>active SME view</p> required <p>Returns:     IObject: SME View object</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_target_sme_view(target_view: int):\n    \"\"\"_summary_\n\n    Args:\n        target_view (int): active SME view\n    Returns:\n        IObject: SME View object\n    \"\"\"\n    return rt.sme.GetView(target_view)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_tyflow_export_operators","title":"<code>get_tyflow_export_operators()</code>","text":"<p>Get Tyflow Export Particles Operators.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Particle operators</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_tyflow_export_operators():\n    \"\"\"Get Tyflow Export Particles Operators.\n\n    Returns:\n        list: Particle operators\n\n    \"\"\"\n    operators = []\n    members = [obj for obj in rt.Objects if rt.ClassOf(obj) == rt.tyFlow]\n    for member in members:\n        obj = member.baseobject\n        anim_names = rt.GetSubAnimNames(obj)\n        for anim_name in anim_names:\n            sub_anim = rt.GetSubAnim(obj, anim_name)\n            if not rt.isKindOf(sub_anim, rt.tyEvent):\n                continue\n            node_names = rt.GetSubAnimNames(sub_anim)\n            for node_name in node_names:\n                node_sub_anim = rt.GetSubAnim(sub_anim, node_name)\n                if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                    operators.append(node_sub_anim)\n    return operators\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.get_view_node_from_sme_view","title":"<code>get_view_node_from_sme_view(sme_view, view_node_name)</code>","text":"<p>Get view node from SME view</p> <p>Parameters:</p> Name Type Description Default <code>sme_view</code> <code>IFP_NodeViewImp</code> <p>Target SME View</p> required <code>view_node_name</code> <code>str</code> <p>view node name</p> required <p>Returns:     IObject: view node object</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def get_view_node_from_sme_view(sme_view, view_node_name):\n    \"\"\"Get view node from SME view\n\n    Args:\n        sme_view (rt.IFP_NodeViewImp): Target SME View\n        view_node_name (str): view node name\n    Returns:\n        IObject: view node object\n    \"\"\"\n    for i in range(sme_view.GetNumNodes() + 1):\n        node = sme_view.GetNode(i)\n        if node is None:\n            continue\n        if node.name == view_node_name:\n            return node\n    raise ValueError(f\"View node {view_node_name} not found in SME view.\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.is_headless","title":"<code>is_headless()</code>","text":"<p>Check if 3dsMax runs in batch mode. If it returns True, it runs in 3dsbatch.exe If it returns False, it runs in 3dsmax.exe</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def is_headless():\n    \"\"\"Check if 3dsMax runs in batch mode.\n    If it returns True, it runs in 3dsbatch.exe\n    If it returns False, it runs in 3dsmax.exe\n    \"\"\"\n    return rt.maxops.isInNonInteractiveMode()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.lsattr","title":"<code>lsattr(attr, value=None, root=None)</code>","text":"<p>List nodes having attribute with specified value.</p> <p>Parameters:</p> Name Type Description Default <code>attr</code> <code>str</code> <p>Attribute name to match.</p> required <code>value</code> <code>(str, Optional)</code> <p>Value to match, of omitted, all nodes with specified attribute are returned no matter of value.</p> <code>None</code> <code>root</code> <code>(str, Optional)</code> <p>Root node name. If omitted, scene root is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>list</code> <p>list of nodes.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def lsattr(\n        attr: str,\n        value: Union[str, None] = None,\n        root: Union[str, None] = None) -&gt; list:\n    \"\"\"List nodes having attribute with specified value.\n\n    Args:\n        attr (str): Attribute name to match.\n        value (str, Optional): Value to match, of omitted, all nodes\n            with specified attribute are returned no matter of value.\n        root (str, Optional): Root node name. If omitted, scene root is used.\n\n    Returns:\n        list of nodes.\n    \"\"\"\n    root = rt.RootNode if root is None else rt.GetNodeByName(root)\n\n    def output_node(node, nodes):\n        nodes.append(node)\n        for child in node.Children:\n            output_node(child, nodes)\n\n    nodes = []\n    output_node(root, nodes)\n    return [\n        n for n in nodes\n        if rt.GetUserProp(n, attr) == value\n    ] if value else [\n        n for n in nodes\n        if rt.GetUserProp(n, attr)\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.maintained_sme_view_nodes_selection","title":"<code>maintained_sme_view_nodes_selection(current_sme_view, texture_node)</code>","text":"<p>Maintain selection of nodes in SME view during context</p> <p>Parameters:</p> Name Type Description Default <code>view_node_name</code> <code>IFP_NodeViewImp</code> <p>SNE View Node Object</p> required <code>texture_node</code> <code>Node</code> <p>Texture Node Object</p> required Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_sme_view_nodes_selection(current_sme_view, texture_node):\n    \"\"\"Maintain selection of nodes in SME view during context\n\n    Args:\n        view_node_name (IFP_NodeViewImp): SNE View Node Object\n        texture_node (Node): Texture Node Object\n    \"\"\"\n    previous_selection = [\n        node.reference for node in current_sme_view.GetSelectedNodes()\n        if node.reference != texture_node\n    ]\n    try:\n        current_sme_view.SelectNone()\n        current_sme_view.setSelectedNodes([texture_node])\n        yield\n\n    finally:\n        if previous_selection:\n            current_sme_view.setSelectedNodes(previous_selection)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.object_transform_set","title":"<code>object_transform_set(container_children)</code>","text":"<p>A function which allows to store the transform of previous loaded object(s) Args:     container_children(list): A list of nodes</p> <p>Returns:</p> Name Type Description <code>transform_set</code> <code>dict</code> <p>A dict with all transform data of</p> <p>the previous loaded object(s)</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def object_transform_set(container_children):\n    \"\"\"A function which allows to store the transform of\n    previous loaded object(s)\n    Args:\n        container_children(list): A list of nodes\n\n    Returns:\n        transform_set (dict): A dict with all transform data of\n        the previous loaded object(s)\n    \"\"\"\n    transform_set = {}\n\n    for node in container_children:\n        name = f\"{node.name}.rotation\"\n        transform_set[name] = node.rotation\n        name = f\"{node.name}.scale\"\n        transform_set[name] = node.scale\n        name = f\"{node.name}.translate\"\n        transform_set[name] = node.pos\n    return transform_set\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.render_resolution","title":"<code>render_resolution(width, height)</code>","text":"<p>Set render resolution option during context</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>render width</p> required <code>height</code> <code>int</code> <p>render height</p> required Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef render_resolution(width, height):\n    \"\"\"Set render resolution option during context\n\n    Args:\n        width (int): render width\n        height (int): render height\n    \"\"\"\n    current_renderWidth = rt.renderWidth\n    current_renderHeight = rt.renderHeight\n    try:\n        rt.renderWidth = width\n        rt.renderHeight = height\n        yield\n    finally:\n        rt.renderWidth = current_renderWidth\n        rt.renderHeight = current_renderHeight\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.reset_colorspace","title":"<code>reset_colorspace()</code>","text":"<p>OCIO Configuration Supports in 3dsMax 2024+</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def reset_colorspace():\n    \"\"\"OCIO Configuration\n    Supports in 3dsMax 2024+\n\n    \"\"\"\n    if int(get_max_version()) &lt; 2024:\n        return\n    colorspace_mgr = rt.ColorPipelineMgr\n    ocio_config_path = os.getenv(\"OCIO\")\n    colorspace_mgr.Mode = rt.Name(\"OCIO_EnvVar\")\n    if not ocio_config_path:\n        max_config_data = colorspace.get_current_context_imageio_config_preset()\n        if max_config_data:\n            ocio_config_path = max_config_data[\"path\"]\n            colorspace_mgr.Mode = rt.Name(\"OCIO_Custom\")\n            colorspace_mgr.OCIOConfigPath = ocio_config_path\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.reset_frame_range","title":"<code>reset_frame_range(fps=True)</code>","text":"<p>Set frame range to current folder. This is part of 3dsmax documentation:</p> A System Global variable which lets you get and <p>set an Interval value that defines the start and end frames of the Active Time Segment.</p> <p>frameRate: A System Global variable which lets you get         and set an Integer value that defines the current         scene frame rate in frames-per-second.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def reset_frame_range(fps: bool = True):\n    \"\"\"Set frame range to current folder.\n    This is part of 3dsmax documentation:\n\n    animationRange: A System Global variable which lets you get and\n        set an Interval value that defines the start and end frames\n        of the Active Time Segment.\n    frameRate: A System Global variable which lets you get\n            and set an Integer value that defines the current\n            scene frame rate in frames-per-second.\n    \"\"\"\n    if fps:\n        rt.frameRate = float(get_fps_for_current_context())\n\n    frame_range = get_frame_range()\n\n    set_timeline(\n        frame_range[\"frameStartHandle\"], frame_range[\"frameEndHandle\"])\n    set_render_frame_range(\n        frame_range[\"frameStartHandle\"], frame_range[\"frameEndHandle\"])\n\n    project_name = get_current_project_name()\n    settings = get_project_settings(project_name).get(\"max\")\n    auto_key_default_key_time = settings.get(\n        \"auto_key_default\", {}).get(\"defualt_key_time\")\n    rt.maxOps.autoKeyDefaultKeyTime = auto_key_default_key_time\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.reset_scene_resolution","title":"<code>reset_scene_resolution(task_entity=None)</code>","text":"<p>Apply the scene resolution from the project definition</p> <p>scene resolution can be overwritten by a folder if the folder.attrib contains any information regarding scene resolution.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def reset_scene_resolution(task_entity=None):\n    \"\"\"Apply the scene resolution from the project definition\n\n    scene resolution can be overwritten by a folder if the folder.attrib\n    contains any information regarding scene resolution.\n    \"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib\"})\n    task_attributes = task_entity[\"attrib\"]\n    width = int(task_attributes[\"resolutionWidth\"])\n    height = int(task_attributes[\"resolutionHeight\"])\n\n    set_scene_resolution(width, height)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.set_context_setting","title":"<code>set_context_setting()</code>","text":"<p>Apply the project settings from the project definition</p> <p>Settings can be overwritten by an folder if the folder.attrib contains any information regarding those settings.</p> Examples of settings <p>frame range resolution</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def set_context_setting():\n    \"\"\"Apply the project settings from the project definition\n\n    Settings can be overwritten by an folder if the folder.attrib contains\n    any information regarding those settings.\n\n    Examples of settings:\n        frame range\n        resolution\n\n    Returns:\n        None\n    \"\"\"\n    reset_scene_resolution()\n    reset_frame_range()\n    validate_unit_scale()\n    reset_colorspace()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.set_render_frame_range","title":"<code>set_render_frame_range(start_frame, end_frame)</code>","text":"Note <p>Frame range can be specified in different types. Possible values are: * <code>1</code> - Single frame. * <code>2</code> - Active time segment ( animationRange ). * <code>3</code> - User specified Range. * <code>4</code> - User specified Frame pickup string (for example <code>1,3,5-12</code>).</p> Todo <p>Current type is hard-coded, there should be a custom setting for this.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def set_render_frame_range(start_frame, end_frame):\n    \"\"\"\n    Note:\n        Frame range can be specified in different types. Possible values are:\n        * `1` - Single frame.\n        * `2` - Active time segment ( animationRange ).\n        * `3` - User specified Range.\n        * `4` - User specified Frame pickup string (for example `1,3,5-12`).\n\n    Todo:\n        Current type is hard-coded, there should be a custom setting for this.\n    \"\"\"\n    rt.rendTimeType = 3\n    if start_frame is not None and end_frame is not None:\n        rt.rendStart = int(start_frame)\n        rt.rendEnd = int(end_frame)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.set_scene_resolution","title":"<code>set_scene_resolution(width, height)</code>","text":"<p>Set the render resolution</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>value of the width</p> required <code>height</code> <code>int</code> <p>value of the height</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def set_scene_resolution(width: int, height: int):\n    \"\"\"Set the render resolution\n\n    Args:\n        width(int): value of the width\n        height(int): value of the height\n\n    Returns:\n        None\n\n    \"\"\"\n    # make sure the render dialog is closed\n    # for the update of resolution\n    # Changing the Render Setup dialog settings should be done\n    # with the actual Render Setup dialog in a closed state.\n    if rt.renderSceneDialog.isOpen():\n        rt.renderSceneDialog.close()\n\n    rt.renderWidth = width\n    rt.renderHeight = height\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.set_timeline","title":"<code>set_timeline(frameStart, frameEnd)</code>","text":"<p>Set frame range for timeline editor in Max</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def set_timeline(frameStart, frameEnd):\n    \"\"\"Set frame range for timeline editor in Max\n    \"\"\"\n    rt.animationRange = rt.interval(int(frameStart), int(frameEnd))\n    return rt.animationRange\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.set_unit_scale","title":"<code>set_unit_scale(project_settings=None)</code>","text":"<p>Function to set unit scale in Metric</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def set_unit_scale(project_settings=None):\n    \"\"\"Function to set unit scale in Metric\n    \"\"\"\n    if project_settings is None:\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name).get(\"max\")\n    scene_scale = project_settings[\"unit_scale_settings\"][\"scene_unit_scale\"]\n    rt.units.DisplayType = rt.Name(\"Metric\")\n    rt.units.MetricType = rt.Name(scene_scale)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.set_viewport_type","title":"<code>set_viewport_type(viewport_type=None)</code>","text":"<p>Set viewport type during context</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef set_viewport_type(viewport_type=None):\n    \"\"\"Set viewport type during context\"\"\"\n    if viewport_type is None:\n        viewport_type = rt.Name(\"view_camera\")\n    previous_viewport_type = rt.viewport.getType()\n    rt.viewport.setType(viewport_type)\n    try:\n        yield\n    finally:\n        rt.viewport.setType(previous_viewport_type)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.suspended_refresh","title":"<code>suspended_refresh()</code>","text":"<p>Suspended refresh for scene and modify panel redraw.</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef suspended_refresh():\n    \"\"\"Suspended refresh for scene and modify panel redraw.\n    \"\"\"\n    if is_headless():\n        yield\n        return\n    rt.disableSceneRedraw()\n    rt.suspendEditing()\n    try:\n        yield\n\n    finally:\n        rt.enableSceneRedraw()\n        rt.resumeEditing()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.unique_namespace","title":"<code>unique_namespace(namespace, format='%02d', prefix='', suffix='', con_suffix='CON')</code>","text":"<p>Return unique namespace</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Name of namespace to consider</p> required <code>format</code> <code>str</code> <p>Formatting of the given iteration number</p> <code>'%02d'</code> <code>suffix</code> <code>str</code> <p>Only consider namespaces with this suffix.</p> <code>''</code> <code>con_suffix</code> <p>max only, for finding the name of the master container</p> <code>'CON'</code> <p>unique_namespace(\"bar\")</p>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.unique_namespace--bar01","title":"bar01","text":"<p>unique_namespace(\":hello\")</p>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.unique_namespace--hello01","title":":hello01","text":"<p>unique_namespace(\"bar:\", suffix=\"_NS\")</p>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.unique_namespace--bar01_ns","title":"bar01_NS:","text":"Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def unique_namespace(namespace, format=\"%02d\",\n                     prefix=\"\", suffix=\"\", con_suffix=\"CON\"):\n    \"\"\"Return unique namespace\n\n    Arguments:\n        namespace (str): Name of namespace to consider\n        format (str, optional): Formatting of the given iteration number\n        suffix (str, optional): Only consider namespaces with this suffix.\n        con_suffix: max only, for finding the name of the master container\n\n    &gt;&gt;&gt; unique_namespace(\"bar\")\n    # bar01\n    &gt;&gt;&gt; unique_namespace(\":hello\")\n    # :hello01\n    &gt;&gt;&gt; unique_namespace(\"bar:\", suffix=\"_NS\")\n    # bar01_NS:\n\n    \"\"\"\n\n    def current_namespace():\n        current = namespace\n        # When inside a namespace Max adds no trailing :\n        if not current.endswith(\":\"):\n            current += \":\"\n        return current\n\n    # Always check against the absolute namespace root\n    # There's no clash with :x if we're defining namespace :a:x\n    ROOT = \":\" if namespace.startswith(\":\") else current_namespace()\n\n    # Strip trailing `:` tokens since we might want to add a suffix\n    start = \":\" if namespace.startswith(\":\") else \"\"\n    end = \":\" if namespace.endswith(\":\") else \"\"\n    namespace = namespace.strip(\":\")\n    if \":\" in namespace:\n        # Split off any nesting that we don't uniqify anyway.\n        parents, namespace = namespace.rsplit(\":\", 1)\n        start += parents + \":\"\n        ROOT += start\n\n    iteration = 1\n    increment_version = True\n    while increment_version:\n        nr_namespace = namespace + format % iteration\n        unique = prefix + nr_namespace + suffix\n        container_name = f\"{unique}:{namespace}{con_suffix}\"\n        if not rt.getNodeByName(container_name):\n            name_space = start + unique + end\n            increment_version = False\n            return name_space\n        else:\n            increment_version = True\n        iteration += 1\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.update_modifier_node_names","title":"<code>update_modifier_node_names(event, node)</code>","text":"<p>Update the name of the nodes after renaming</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MXSWrapperBase</code> <p>Event Name ( Mandatory argument for rt.NodeEventCallback)</p> required <code>node</code> <code>list</code> <p>Event Number ( Mandatory argument for rt.NodeEventCallback)</p> required Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def update_modifier_node_names(event, node):\n    \"\"\"Update the name of the nodes after renaming\n\n    Args:\n        event (pymxs.MXSWrapperBase): Event Name (\n            Mandatory argument for rt.NodeEventCallback)\n        node (list): Event Number (\n            Mandatory argument for rt.NodeEventCallback)\n\n    \"\"\"\n    containers = [\n        obj\n        for obj in rt.Objects\n        if (\n            rt.ClassOf(obj) == rt.Container\n            and rt.getUserProp(obj, \"id\") == \"pyblish.avalon.instance\"\n            and rt.getUserProp(obj, \"productType\") not in {\n                \"workfile\", \"tyflow\"\n            }\n        )\n    ]\n    if not containers:\n        return\n    for container in containers:\n        ayon_data = container.modifiers[0].openPypeData\n        updated_node_names = [str(node.node) for node\n                              in ayon_data.all_handles]\n        rt.setProperty(ayon_data, \"sel_list\", updated_node_names)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib.html#client.ayon_max.api.lib.validate_unit_scale","title":"<code>validate_unit_scale(project_settings=None)</code>","text":"<p>Apply the unit scale setting to 3dsMax</p> Source code in <code>client/ayon_max/api/lib.py</code> <pre><code>def validate_unit_scale(project_settings=None):\n    \"\"\"Apply the unit scale setting to 3dsMax\n    \"\"\"\n\n    if is_headless():\n        return\n    if project_settings is None:\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name).get(\"max\")\n    scene_scale_enabled = project_settings[\"unit_scale_settings\"][\"enabled\"]\n    if not scene_scale_enabled:\n        log.info(\"Using default scale display type.\")\n        rt.units.DisplayType = rt.Name(\"Generic\")\n        return\n    scene_scale = project_settings[\"unit_scale_settings\"][\"scene_unit_scale\"]\n    if rt.units.DisplayType == rt.Name(\"Metric\") and (\n        rt.units.MetricType == rt.Name(scene_scale)\n    ):\n        return\n\n    parent = get_main_window()\n    dialog = SimplePopup(parent=parent)\n    dialog.setWindowTitle(\"Wrong Unit Scale\")\n    dialog.set_message(\"Scene units do not match studio/project preferences.\")\n    dialog.set_button_text(\"Fix\")\n    dialog.setStyleSheet(load_stylesheet())\n\n    dialog.on_clicked.connect(partial(set_unit_scale, project_settings))\n    dialog.show()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html","title":"lib_renderproducts","text":""},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts","title":"<code>RenderProducts</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>class RenderProducts(object):\n\n    def __init__(self, project_settings=None):\n        self._project_settings = project_settings\n        if not self._project_settings:\n            self._project_settings = get_project_settings(\n                get_current_project_name()\n            )\n\n    def get_beauty(self, container, renderer, filename):\n        \"\"\"Get beauty render output file path.\"\"\"\n        setting = self._project_settings\n        render_dir = get_expected_render_folder(setting, filename)\n        output_file = os.path.join(render_dir, container)\n        img_fmt = setting[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n\n        start_frame = int(rt.rendStart)\n        end_frame = int(rt.rendEnd) + 1\n        return {\n            \"beauty\": self.get_expected_beauty(\n                output_file, start_frame, end_frame, img_fmt,\n                renderer\n            )\n        }\n\n    def get_multiple_beauty(self, outputs, cameras):\n        beauty_output_frames = dict()\n        renderer = get_current_renderer()\n        for output, camera in zip(outputs, cameras):\n            camera = camera.replace(\":\", \"_\")\n            filename, ext = os.path.splitext(output)\n            filename = filename.replace(\".\", \"\")\n            ext = ext.replace(\".\", \"\")\n            start_frame = int(rt.rendStart)\n            end_frame = int(rt.rendEnd) + 1\n            new_beauty = self.get_expected_beauty(\n                filename, start_frame, end_frame, ext,\n                renderer\n            )\n            beauty_output = ({\n                f\"{camera}_beauty\": new_beauty\n            })\n            beauty_output_frames.update(beauty_output)\n        return beauty_output_frames\n\n    def get_multiple_aovs(self, outputs, cameras):\n        renderer_class = get_current_renderer()\n        renderer = str(renderer_class).split(\":\")[0]\n        aovs_frames = {}\n        for output, camera in zip(outputs, cameras):\n            camera = camera.replace(\":\", \"_\")\n            filename, ext = os.path.splitext(output)\n            filename = filename.replace(\".\", \"\")\n            ext = ext.replace(\".\", \"\")\n            start_frame = int(rt.rendStart)\n            end_frame = int(rt.rendEnd) + 1\n\n            if renderer in [\n                \"ART_Renderer\",\n                \"Default_Scanline_Renderer\",\n                \"Quicksilver_Hardware_Renderer\",\n            ]:\n                render_name = self.get_render_elements_name()\n                if render_name:\n                    for name in render_name:\n                        aovs_frames.update({\n                            f\"{camera}_{name}\": self.get_expected_aovs(\n                                filename, name, start_frame,\n                                end_frame, ext, renderer)\n                        })\n            elif renderer.startswith(\"V_Ray_\"):\n                if not renderer_class.output_splitgbuffer:\n                    return aovs_frames\n\n                render_name = self.get_render_elements_name()\n                render_name = self._add_vray_additional_outputs(render_name, renderer_class)\n                if render_name:\n                    for name in render_name:\n                        aovs_frames.update({\n                            f\"{camera}_{name}\": self.get_expected_aovs(\n                            filename, name, start_frame,\n                            end_frame, ext, renderer)\n                    })\n            elif renderer == \"Redshift_Renderer\":\n                render_name = self.get_render_elements_name()\n                if render_name:\n                    rs_aov_files = rt.Execute(\"renderers.current.separateAovFiles\")     # noqa\n                    # this doesn't work, always returns False\n                    # rs_AovFiles = rt.RedShift_Renderer().separateAovFiles\n                    if ext == \"exr\" and not rs_aov_files:\n                        for name in render_name:\n                            if name == \"RsCryptomatte\":\n                                aovs_frames.update({\n                                    f\"{camera}_{name}\": self.get_expected_aovs(\n                                        filename, name, start_frame,\n                                        end_frame, ext, renderer)\n                                })\n                    else:\n                        for name in render_name:\n                            aovs_frames.update({\n                                f\"{camera}_{name}\": self.get_expected_aovs(\n                                    filename, name, start_frame,\n                                    end_frame, ext, renderer)\n                            })\n            # elif renderer == \"Arnold\":\n            #     aov_by_render_name, output_file = self.get_arnold_product_name_and_path()\n            #     if aov_by_render_name:\n            #         aovs_frames.update({\n            #             f\"{camera}_{name}\": self.get_expected_arnold_product(   # noqa\n            #                 output_file, aov_by_render_name, start_frame,\n            #                 end_frame, ext)\n            #         })\n\n        return aovs_frames\n\n    def get_aovs(self, container, filename):\n        setting = self._project_settings\n        render_dir = get_expected_render_folder(setting, filename)\n        output_file = os.path.join(render_dir, container)\n        img_fmt = setting[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n\n        start_frame = int(rt.rendStart)\n        end_frame = int(rt.rendEnd) + 1\n        renderer_class = get_current_renderer()\n        renderer = str(renderer_class).split(\":\")[0]\n        render_dict = {}\n\n        if renderer in [\n            \"ART_Renderer\",\n            \"Default_Scanline_Renderer\",\n            \"Quicksilver_Hardware_Renderer\",\n        ]:\n            render_name = self.get_render_elements_name()\n            if render_name:\n                for name in render_name:\n                    render_dict.update({\n                        name: self.get_expected_aovs(\n                            output_file, name, start_frame,\n                            end_frame, img_fmt,\n                            renderer)\n                    })\n        elif renderer.startswith(\"V_Ray_\"):\n            if not renderer_class.output_splitgbuffer:\n                return render_dict\n\n            render_name = self.get_render_elements_name()\n            render_name = self._add_vray_additional_outputs(render_name, renderer_class)\n\n            if render_name:\n                for name in render_name:\n                    render_dict.update({\n                        name: self.get_expected_aovs(\n                            output_file, name, start_frame,\n                            end_frame, img_fmt,\n                            renderer)\n                    })\n        elif renderer == \"Redshift_Renderer\":\n            render_name = self.get_render_elements_name()\n            if render_name:\n                rs_aov_files = rt.Execute(\"renderers.current.separateAovFiles\")\n                # this doesn't work, always returns False\n                # rs_AovFiles = rt.RedShift_Renderer().separateAovFiles\n                if img_fmt == \"exr\" and not rs_aov_files:\n                    for name in render_name:\n                        if name == \"RsCryptomatte\":\n                            render_dict.update({\n                                name: self.get_expected_aovs(\n                                    output_file, name, start_frame,\n                                    end_frame, img_fmt,\n                                    renderer)\n                            })\n                else:\n                    for name in render_name:\n                        render_dict.update({\n                            name: self.get_expected_aovs(\n                                output_file, name, start_frame,\n                                end_frame, img_fmt,\n                                renderer)\n                        })\n\n        # TODO: implement aovs\n        # elif renderer == \"Arnold\":\n        #     aov_by_render_name, output_file = self.get_arnold_product_name_and_path()\n        #     render_dict.update({\n        #         name: self.get_expected_arnold_product(\n        #             output_file, aov_by_render_name, start_frame,\n        #             end_frame, img_fmt)\n        #     })\n\n        return render_dict\n\n    def get_expected_beauty(self, folder, start_frame, end_frame, fmt, renderer):\n        \"\"\"Get expected beauty render output file paths for each frame.\"\"\"\n        beauty_frame_range = []\n\n        if renderer.startswith(\"V_Ray_\"):\n            vr_renderer = get_current_renderer()\n            if fmt == \"exr\":\n                raw_directory = os.path.dirname(folder)\n                _, raw_fname = self.get_vray_render_files(vr_renderer)\n                for frame_num in range(start_frame, end_frame):\n                    frame = f\"{frame_num:04d}\"\n                    output_path = f\"{raw_directory}/{raw_fname}.{frame}.{fmt}\"\n                    beauty_frame_range.append(output_path.replace(\"\\\\\", \"/\"))\n\n        elif renderer == \"Arnold\":\n            aov_by_name, output_file = self.get_arnold_product_name_and_path()\n            beauty_frame_range.extend(\n                self.get_expected_arnold_product(\n                    output_file, aov_by_name, start_frame,\n                    end_frame, fmt)\n            )\n        else:\n            for frame_num in range(start_frame, end_frame):\n                frame = f\"{frame_num:04d}\"\n                output_path = f\"{folder}.{frame}.{fmt}\"\n                beauty_frame_range.append(output_path.replace(\"\\\\\", \"/\"))\n\n        return beauty_frame_range\n\n    def get_arnold_product_name_and_path(self):\n        \"\"\"Get all the Arnold AOVs name and output path from AOV manager.\"\"\"\n        aov_name_by_render_name = {}\n        # amw = rt.MaxToAOps.AOVsManagerWindow()\n        aov_mgr = rt.renderers.current.AOVManager\n        aov_output_path = rt.renderers.current.AOVManager.outputPath\n        # Check if there is any aov group set in AOV manager\n        aov_group_num = len(aov_mgr.drivers)\n        if aov_group_num &lt; 1:\n            return\n        for i in range(aov_group_num):\n            # get the specific AOV group\n            aov_name = aov_mgr.drivers[i].filenameSuffix\n            if aov_name is None:\n                aov_name = \"\"\n            aov_name_by_render_name.update({\n                aov_name: [aov.name for aov in aov_mgr.drivers[i].aov_list]\n            })\n        # # close the AOVs manager window\n        # amw.close()\n\n        return aov_name_by_render_name, aov_output_path\n\n    def get_expected_arnold_product(self, folder, name,\n                                    start_frame, end_frame, fmt):\n        \"\"\"Get all the expected Arnold AOVs\"\"\"\n        aov_list = []\n        # TODO: refactor this to make sure it supports separate AOVs\n        # with Arnold drivers.\n        for aov_group in name.keys():\n            rendername = f\"{folder}/{aov_group}\"\n            for f in range(start_frame, end_frame):\n                frame = \"%04d\" % f\n                render_element = f\"{rendername}{frame}.{fmt}\"\n                render_element = render_element.replace(\"\\\\\", \"/\")\n                aov_list.append(render_element)\n\n        return aov_list\n\n    def get_render_elements_name(self):\n        \"\"\"Get all the render element names for general \"\"\"\n        render_name = []\n        render_elem = rt.maxOps.GetCurRenderElementMgr()\n        render_elem_num = render_elem.NumRenderElements()\n        if render_elem_num &lt; 1:\n            return render_name\n        # get render elements from the renders\n        for i in range(render_elem_num):\n            renderlayer_name = render_elem.GetRenderElement(i)\n            if renderlayer_name.enabled:\n                _, renderpass = str(renderlayer_name).split(\":\")\n                render_name.append(renderpass)\n\n        return render_name\n\n    def _add_vray_additional_outputs(self, render_name, renderer_class):\n        \"\"\"Add additional V-Ray outputs like Alpha and RGB_color to render names.\n\n        Args:\n            render_name (list): List of existing render element names\n            renderer_class: V-Ray renderer instance\n\n        Returns:\n            list: Updated list with additional outputs\n        \"\"\"\n        if hasattr(renderer_class, 'output_splitAlpha') and renderer_class.output_splitAlpha:\n            render_name.append(\"Alpha\")\n        if hasattr(renderer_class, 'output_splitRGB') and renderer_class.output_splitRGB:\n            render_name.append(\"RGB_color\")\n\n        return render_name\n\n    def get_expected_aovs(self, folder, name, start_frame, end_frame, fmt, renderer):\n        \"\"\"Get all the expected render element output files.\"\"\"\n        render_elements = []\n\n        if renderer.startswith(\"V_Ray_\"):\n            vr_renderer = get_current_renderer()\n            raw_directory = os.path.dirname(folder)\n            _, raw_fname = self.get_vray_render_files(\n                vr_renderer, is_render_element=True)\n            if vr_renderer.output_separateFolders:\n                formated_output = f\"{raw_directory}/{name}/{raw_fname}.{name}\"\n            else:\n                formated_output = f\"{raw_directory}/{raw_fname}.{name}\"\n\n            for frame_num in range(start_frame, end_frame):\n                frame = f\"{frame_num:04d}\"\n                render_element = f\"{formated_output}.{frame}.{fmt}\"\n                render_elements.append(render_element.replace(\"\\\\\", \"/\"))\n        else:\n            for frame_num in range(start_frame, end_frame):\n                frame = f\"{frame_num:04d}\"\n                render_element = f\"{folder}_{name}.{frame}.{fmt}\"\n                render_elements.append(render_element.replace(\"\\\\\", \"/\"))\n\n        return render_elements\n\n    def get_vray_render_files(self, vr_renderer, is_render_element=False):\n        \"\"\"Get the raw directory and filename for V-Ray renderer.\n\n        Args:\n            vr_renderer (rt.renderers.production): The V-Ray renderer instance.\n            is_render_element (bool): whether type of output are\n            render element files.\n\n        Returns:\n            str, str: The raw directory and filename for V-Ray renderer.\n        \"\"\"\n        raw_filepath = vr_renderer.output_rawfilename\n        if not raw_filepath or is_render_element:\n            if \"GPU\" in str(vr_renderer):\n                raw_filepath = vr_renderer.V_Ray_settings.output_rawfilename\n            else:\n                raw_filepath = vr_renderer.output_splitfilename\n\n        raw_directory = os.path.dirname(raw_filepath).rsplit(\"\\\\\")[-1]\n        raw_filename = os.path.basename(raw_filepath)\n        raw_fname, _ = os.path.splitext(raw_filename)\n        return raw_directory, raw_fname.strip(\".\")\n\n    def image_format(self):\n        return self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]  # noqa\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_arnold_product_name_and_path","title":"<code>get_arnold_product_name_and_path()</code>","text":"<p>Get all the Arnold AOVs name and output path from AOV manager.</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_arnold_product_name_and_path(self):\n    \"\"\"Get all the Arnold AOVs name and output path from AOV manager.\"\"\"\n    aov_name_by_render_name = {}\n    # amw = rt.MaxToAOps.AOVsManagerWindow()\n    aov_mgr = rt.renderers.current.AOVManager\n    aov_output_path = rt.renderers.current.AOVManager.outputPath\n    # Check if there is any aov group set in AOV manager\n    aov_group_num = len(aov_mgr.drivers)\n    if aov_group_num &lt; 1:\n        return\n    for i in range(aov_group_num):\n        # get the specific AOV group\n        aov_name = aov_mgr.drivers[i].filenameSuffix\n        if aov_name is None:\n            aov_name = \"\"\n        aov_name_by_render_name.update({\n            aov_name: [aov.name for aov in aov_mgr.drivers[i].aov_list]\n        })\n    # # close the AOVs manager window\n    # amw.close()\n\n    return aov_name_by_render_name, aov_output_path\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_beauty","title":"<code>get_beauty(container, renderer, filename)</code>","text":"<p>Get beauty render output file path.</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_beauty(self, container, renderer, filename):\n    \"\"\"Get beauty render output file path.\"\"\"\n    setting = self._project_settings\n    render_dir = get_expected_render_folder(setting, filename)\n    output_file = os.path.join(render_dir, container)\n    img_fmt = setting[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n\n    start_frame = int(rt.rendStart)\n    end_frame = int(rt.rendEnd) + 1\n    return {\n        \"beauty\": self.get_expected_beauty(\n            output_file, start_frame, end_frame, img_fmt,\n            renderer\n        )\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_expected_aovs","title":"<code>get_expected_aovs(folder, name, start_frame, end_frame, fmt, renderer)</code>","text":"<p>Get all the expected render element output files.</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_expected_aovs(self, folder, name, start_frame, end_frame, fmt, renderer):\n    \"\"\"Get all the expected render element output files.\"\"\"\n    render_elements = []\n\n    if renderer.startswith(\"V_Ray_\"):\n        vr_renderer = get_current_renderer()\n        raw_directory = os.path.dirname(folder)\n        _, raw_fname = self.get_vray_render_files(\n            vr_renderer, is_render_element=True)\n        if vr_renderer.output_separateFolders:\n            formated_output = f\"{raw_directory}/{name}/{raw_fname}.{name}\"\n        else:\n            formated_output = f\"{raw_directory}/{raw_fname}.{name}\"\n\n        for frame_num in range(start_frame, end_frame):\n            frame = f\"{frame_num:04d}\"\n            render_element = f\"{formated_output}.{frame}.{fmt}\"\n            render_elements.append(render_element.replace(\"\\\\\", \"/\"))\n    else:\n        for frame_num in range(start_frame, end_frame):\n            frame = f\"{frame_num:04d}\"\n            render_element = f\"{folder}_{name}.{frame}.{fmt}\"\n            render_elements.append(render_element.replace(\"\\\\\", \"/\"))\n\n    return render_elements\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_expected_arnold_product","title":"<code>get_expected_arnold_product(folder, name, start_frame, end_frame, fmt)</code>","text":"<p>Get all the expected Arnold AOVs</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_expected_arnold_product(self, folder, name,\n                                start_frame, end_frame, fmt):\n    \"\"\"Get all the expected Arnold AOVs\"\"\"\n    aov_list = []\n    # TODO: refactor this to make sure it supports separate AOVs\n    # with Arnold drivers.\n    for aov_group in name.keys():\n        rendername = f\"{folder}/{aov_group}\"\n        for f in range(start_frame, end_frame):\n            frame = \"%04d\" % f\n            render_element = f\"{rendername}{frame}.{fmt}\"\n            render_element = render_element.replace(\"\\\\\", \"/\")\n            aov_list.append(render_element)\n\n    return aov_list\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_expected_beauty","title":"<code>get_expected_beauty(folder, start_frame, end_frame, fmt, renderer)</code>","text":"<p>Get expected beauty render output file paths for each frame.</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_expected_beauty(self, folder, start_frame, end_frame, fmt, renderer):\n    \"\"\"Get expected beauty render output file paths for each frame.\"\"\"\n    beauty_frame_range = []\n\n    if renderer.startswith(\"V_Ray_\"):\n        vr_renderer = get_current_renderer()\n        if fmt == \"exr\":\n            raw_directory = os.path.dirname(folder)\n            _, raw_fname = self.get_vray_render_files(vr_renderer)\n            for frame_num in range(start_frame, end_frame):\n                frame = f\"{frame_num:04d}\"\n                output_path = f\"{raw_directory}/{raw_fname}.{frame}.{fmt}\"\n                beauty_frame_range.append(output_path.replace(\"\\\\\", \"/\"))\n\n    elif renderer == \"Arnold\":\n        aov_by_name, output_file = self.get_arnold_product_name_and_path()\n        beauty_frame_range.extend(\n            self.get_expected_arnold_product(\n                output_file, aov_by_name, start_frame,\n                end_frame, fmt)\n        )\n    else:\n        for frame_num in range(start_frame, end_frame):\n            frame = f\"{frame_num:04d}\"\n            output_path = f\"{folder}.{frame}.{fmt}\"\n            beauty_frame_range.append(output_path.replace(\"\\\\\", \"/\"))\n\n    return beauty_frame_range\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_render_elements_name","title":"<code>get_render_elements_name()</code>","text":"<p>Get all the render element names for general</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_render_elements_name(self):\n    \"\"\"Get all the render element names for general \"\"\"\n    render_name = []\n    render_elem = rt.maxOps.GetCurRenderElementMgr()\n    render_elem_num = render_elem.NumRenderElements()\n    if render_elem_num &lt; 1:\n        return render_name\n    # get render elements from the renders\n    for i in range(render_elem_num):\n        renderlayer_name = render_elem.GetRenderElement(i)\n        if renderlayer_name.enabled:\n            _, renderpass = str(renderlayer_name).split(\":\")\n            render_name.append(renderpass)\n\n    return render_name\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_renderproducts.html#client.ayon_max.api.lib_renderproducts.RenderProducts.get_vray_render_files","title":"<code>get_vray_render_files(vr_renderer, is_render_element=False)</code>","text":"<p>Get the raw directory and filename for V-Ray renderer.</p> <p>Parameters:</p> Name Type Description Default <code>vr_renderer</code> <code>production</code> <p>The V-Ray renderer instance.</p> required <code>is_render_element</code> <code>bool</code> <p>whether type of output are</p> <code>False</code> <p>Returns:</p> Type Description <p>str, str: The raw directory and filename for V-Ray renderer.</p> Source code in <code>client/ayon_max/api/lib_renderproducts.py</code> <pre><code>def get_vray_render_files(self, vr_renderer, is_render_element=False):\n    \"\"\"Get the raw directory and filename for V-Ray renderer.\n\n    Args:\n        vr_renderer (rt.renderers.production): The V-Ray renderer instance.\n        is_render_element (bool): whether type of output are\n        render element files.\n\n    Returns:\n        str, str: The raw directory and filename for V-Ray renderer.\n    \"\"\"\n    raw_filepath = vr_renderer.output_rawfilename\n    if not raw_filepath or is_render_element:\n        if \"GPU\" in str(vr_renderer):\n            raw_filepath = vr_renderer.V_Ray_settings.output_rawfilename\n        else:\n            raw_filepath = vr_renderer.output_splitfilename\n\n    raw_directory = os.path.dirname(raw_filepath).rsplit(\"\\\\\")[-1]\n    raw_filename = os.path.basename(raw_filepath)\n    raw_fname, _ = os.path.splitext(raw_filename)\n    return raw_directory, raw_fname.strip(\".\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_rendersettings.html","title":"lib_rendersettings","text":""},{"location":"autoapi/client/ayon_max/api/lib_rendersettings.html#client.ayon_max.api.lib_rendersettings.RenderSettings","title":"<code>RenderSettings</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_max/api/lib_rendersettings.py</code> <pre><code>class RenderSettings(object):\n\n    log = Logger.get_logger(\"RenderSettings\")\n\n    _aov_chars = {\n        \"dot\": \".\",\n        \"dash\": \"-\",\n        \"underscore\": \"_\"\n    }\n\n    def __init__(self, project_settings=None):\n        \"\"\"\n        Set up the naming convention for the render\n        elements for the deadline submission\n        \"\"\"\n\n        self._project_settings = project_settings\n        if not self._project_settings:\n            self._project_settings = get_project_settings(\n                get_current_project_name()\n            )\n\n    def set_render_camera(self, selection):\n        for sel in selection:\n            # to avoid Attribute Error from pymxs wrapper\n            if rt.classOf(sel) in rt.Camera.classes:\n                rt.viewport.setCamera(sel)\n                return\n        raise RuntimeError(\"Active Camera not found\")\n\n    def render_output(self, container):\n        folder = rt.maxFilePath\n        # hard-coded, should be customized in the setting\n        file = rt.maxFileName\n        folder = folder.replace(\"\\\\\", \"/\")\n        # hard-coded, set the renderoutput path\n        setting = self._project_settings\n        render_folder = get_default_render_folder(setting)\n        filename, ext = os.path.splitext(file)\n        output_dir = os.path.join(folder,\n                                  render_folder,\n                                  filename)\n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n        # hard-coded, should be customized in the setting\n        folder_attributes = get_current_folder_entity()[\"attrib\"]\n\n        # get project resolution\n        width = folder_attributes.get(\"resolutionWidth\")\n        height = folder_attributes.get(\"resolutionHeight\")\n        # Set Frame Range\n        frame_start = folder_attributes.get(\"frame_start\")\n        frame_end = folder_attributes.get(\"frame_end\")\n        set_render_frame_range(frame_start, frame_end)\n        # get the production render\n        renderer_class = get_current_renderer()\n        renderer = str(renderer_class).split(\":\")[0]\n\n        img_fmt = self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n        output = os.path.join(output_dir, container)\n        try:\n            aov_separator = self._aov_chars[(\n                self._project_settings[\"max\"]\n                                      [\"RenderSettings\"]\n                                      [\"aov_separator\"]\n            )]\n        except KeyError:\n            aov_separator = \".\"\n        output_filename = f\"{output}..{img_fmt}\"\n        output_filename = output_filename.replace(\"{aov_separator}\",\n                                                  aov_separator)\n        multipass_enabled = get_multipass_setting(renderer, setting)\n        if renderer == \"VUE_File_Renderer\":\n            rt.rendOutputFilename = output_filename\n            return\n        # TODO: Finish the arnold render setup\n        elif renderer == \"Arnold\":\n            # We should remove this\n            rt.rendOutputFilename = output_filename\n            self.arnold_setup(output_dir, container, multipass_enabled)\n\n        elif is_supported_renderer(renderer):\n            rt.rendOutputFilename = output_filename\n            self.render_element_layer(output, width, height, img_fmt)\n\n        elif renderer.startswith(\"V_Ray_\"):\n            if \"GPU\" in renderer:\n                vr_settings = renderer_class.V_Ray_settings\n            else:\n                vr_settings = renderer_class\n            vr_settings.output_force32bit_3dsmax_vfb = True\n            vr_settings.output_splitgbuffer = multipass_enabled\n            if img_fmt == \"exr\":\n                vr_settings.output_saverawfile = True\n                vr_settings.output_rawfilename = f\"{output}.{img_fmt}\"\n\n            if multipass_enabled:\n                rt.rendOutputFilename = output_filename\n                vr_settings.output_splitfilename = f\"{output}.{img_fmt}\"\n            else:\n                rt.rendOutputFilename = f\"{output}_tmp..{img_fmt}\"\n            self.render_element_layer(output, width, height, img_fmt)\n        # TODO: supports multipass for different renderers\n        elif renderer == \"Redshift_Renderer\":\n            rt.rendOutputFilename = output_filename\n            rt.renderers.current.separateAovFiles = multipass_enabled\n\n        # prevent rendering extra files when using V-Ray\n        rt.rendSaveFile = True if not renderer.startswith(\"V_Ray_\") else False\n\n        rt.renderSceneDialog.update()\n\n    def arnold_setup(self, output_dir, container, multipass_enabled):\n        # get Arnold RenderView run in the background\n        # for setting up renderable camera\n        multipass = str(multipass_enabled).lower()\n        arv = rt.MAXToAOps.ArnoldRenderView()\n        render_camera = rt.viewport.GetCamera()\n        if render_camera:\n            arv.setOption(\"Camera\", str(render_camera))\n\n        # TODO: add AOVs and extension\n        img_fmt = self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n        # TODO: enhance this maxscript to make sure it supports separate AOVs\n        # with Arnold drivers.\n        setup_cmd = (\n            f\"\"\"\n        amw = MaxtoAOps.AOVsManagerWindow()\n        amw.close()\n        aovmgr = renderers.current.AOVManager\n        aovmgr.drivers = #()\n        aovmgr.outputPath = \"{output_dir}\"\n        img_fmt = \"{img_fmt}\"\n        if img_fmt == \"png\" then driver = ArnoldPNGDriver()\n        if img_fmt == \"jpg\" then driver = ArnoldJPEGDriver()\n        if img_fmt == \"exr\" then driver = ArnoldEXRDriver()\n        if img_fmt == \"tif\" then driver = ArnoldTIFFDriver()\n        if img_fmt == \"tiff\" then driver = ArnoldTIFFDriver()\n        append aovmgr.drivers driver\n        aovmgr.drivers[1].aov_list = #()\n        aovmgr.drivers[1].filenameSuffix  = \"{container}.\"\n        if aovmgr.drivers[1] == ArnoldEXRDriver() then (\n            aovmgr.drivers[1].multipart = {multipass})\n            \"\"\")\n\n        rt.execute(setup_cmd)\n        arv.close()\n\n    def render_element_layer(self, dir, width, height, ext):\n        \"\"\"For Renderers with render elements\"\"\"\n        rt.renderWidth = width\n        rt.renderHeight = height\n        render_elem = rt.maxOps.GetCurRenderElementMgr()\n        render_elem_num = render_elem.NumRenderElements()\n        if render_elem_num &lt; 0:\n            return\n\n        for i in range(render_elem_num):\n            renderlayer_name = render_elem.GetRenderElement(i)\n            target, renderpass = str(renderlayer_name).split(\":\")\n            aov_name = f\"{dir}_{renderpass}..{ext}\"\n            render_elem.SetRenderElementFileName(i, aov_name)\n\n    def get_render_output(self, container, output_dir):\n        output = os.path.join(output_dir, container)\n        img_fmt = self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n        output_filename = f\"{output}..{img_fmt}\"\n        return output_filename\n\n    def get_render_element(self):\n        orig_render_elem = []\n        render_elem = rt.maxOps.GetCurRenderElementMgr()\n        render_elem_num = render_elem.NumRenderElements()\n        if render_elem_num &lt; 0:\n            return\n\n        for i in range(render_elem_num):\n            render_element = render_elem.GetRenderElementFilename(i)\n            orig_render_elem.append(render_element)\n\n        return orig_render_elem\n\n    def get_batch_render_elements(self, container,\n                                  output_dir, camera):\n        render_element_list = list()\n        output = os.path.join(output_dir, container)\n        render_elem = rt.maxOps.GetCurRenderElementMgr()\n        render_elem_num = render_elem.NumRenderElements()\n        if render_elem_num &lt; 0:\n            return\n        img_fmt = self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n\n        for i in range(render_elem_num):\n            renderlayer_name = render_elem.GetRenderElement(i)\n            target, renderpass = str(renderlayer_name).split(\":\")\n            camera = camera.replace(\":\", \"_\")\n            aov_name = f\"{output}_{camera}_{renderpass}..{img_fmt}\"\n            render_element_list.append(aov_name)\n        return render_element_list\n\n    def get_batch_render_output(self, camera):\n        target_layer_no = rt.batchRenderMgr.FindView(camera)\n        target_layer = rt.batchRenderMgr.GetView(target_layer_no)\n        return target_layer.outputFilename\n\n    def batch_render_elements(self, camera):\n        target_layer_no = rt.batchRenderMgr.FindView(camera)\n        target_layer = rt.batchRenderMgr.GetView(target_layer_no)\n        outputfilename = target_layer.outputFilename\n        directory = os.path.dirname(outputfilename)\n        render_elem = rt.maxOps.GetCurRenderElementMgr()\n        render_elem_num = render_elem.NumRenderElements()\n        if render_elem_num &lt; 0:\n            return\n        ext = self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n\n        for i in range(render_elem_num):\n            renderlayer_name = render_elem.GetRenderElement(i)\n            target, renderpass = str(renderlayer_name).split(\":\")\n            aov_name = f\"{directory}_{camera}_{renderpass}..{ext}\"\n            render_elem.SetRenderElementFileName(i, aov_name)\n\n    def batch_render_layer(self, container,\n                           output_dir, cameras):\n        outputs = list()\n        output = os.path.join(output_dir, container)\n        img_fmt = self._project_settings[\"max\"][\"RenderSettings\"][\"image_format\"]   # noqa\n        for cam in cameras:\n            camera = rt.getNodeByName(cam)\n            layer_no = rt.batchRenderMgr.FindView(cam)\n            renderlayer = None\n            if layer_no == 0:\n                renderlayer = rt.batchRenderMgr.CreateView(camera)\n            else:\n                renderlayer = rt.batchRenderMgr.GetView(layer_no)\n            # use camera name as renderlayer name\n            renderlayer.name = cam\n            cam = cam.replace(\":\", \"_\")\n            renderlayer.outputFilename = f\"{output}_{cam}..{img_fmt}\"\n            outputs.append(renderlayer.outputFilename)\n        return outputs\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_rendersettings.html#client.ayon_max.api.lib_rendersettings.RenderSettings.__init__","title":"<code>__init__(project_settings=None)</code>","text":"<p>Set up the naming convention for the render elements for the deadline submission</p> Source code in <code>client/ayon_max/api/lib_rendersettings.py</code> <pre><code>def __init__(self, project_settings=None):\n    \"\"\"\n    Set up the naming convention for the render\n    elements for the deadline submission\n    \"\"\"\n\n    self._project_settings = project_settings\n    if not self._project_settings:\n        self._project_settings = get_project_settings(\n            get_current_project_name()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_rendersettings.html#client.ayon_max.api.lib_rendersettings.RenderSettings.render_element_layer","title":"<code>render_element_layer(dir, width, height, ext)</code>","text":"<p>For Renderers with render elements</p> Source code in <code>client/ayon_max/api/lib_rendersettings.py</code> <pre><code>def render_element_layer(self, dir, width, height, ext):\n    \"\"\"For Renderers with render elements\"\"\"\n    rt.renderWidth = width\n    rt.renderHeight = height\n    render_elem = rt.maxOps.GetCurRenderElementMgr()\n    render_elem_num = render_elem.NumRenderElements()\n    if render_elem_num &lt; 0:\n        return\n\n    for i in range(render_elem_num):\n        renderlayer_name = render_elem.GetRenderElement(i)\n        target, renderpass = str(renderlayer_name).split(\":\")\n        aov_name = f\"{dir}_{renderpass}..{ext}\"\n        render_elem.SetRenderElementFileName(i, aov_name)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/lib_rendersettings.html#client.ayon_max.api.lib_rendersettings.is_supported_renderer","title":"<code>is_supported_renderer(renderer_name)</code>","text":"<p>Whether ayon-max supports the relevant renderer.</p> Source code in <code>client/ayon_max/api/lib_rendersettings.py</code> <pre><code>def is_supported_renderer(renderer_name: str) -&gt; bool:\n    \"\"\"Whether ayon-max supports the relevant renderer.\"\"\"\n    if renderer_name in SUPPORTED_RENDERERS:\n        return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html","title":"menu","text":"<p>3dsmax menu definition of AYON.</p>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu","title":"<code>AYONMenu</code>","text":"<p>               Bases: <code>object</code></p> <p>Object representing AYON menu.</p> <p>This is using \"hack\" to inject itself before \"Help\" menu of 3dsmax. For some reason <code>postLoadingMenus</code> event doesn't fire, and main menu if probably re-initialized by menu templates, se we wait for at least 1 event Qt event loop before trying to insert.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>class AYONMenu(object):\n    \"\"\"Object representing AYON menu.\n\n    This is using \"hack\" to inject itself before \"Help\" menu of 3dsmax.\n    For some reason `postLoadingMenus` event doesn't fire, and main menu\n    if probably re-initialized by menu templates, se we wait for at least\n    1 event Qt event loop before trying to insert.\n\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.main_widget = self.get_main_widget()\n        self.menu = None\n\n        timer = QtCore.QTimer()\n        # set number of event loops to wait.\n        timer.setInterval(1)\n        timer.timeout.connect(self._on_timer)\n        timer.start()\n\n        self._timer = timer\n        self._counter = 0\n\n    def _on_timer(self):\n        if self._counter &lt; 1:\n            self._counter += 1\n            return\n\n        self._counter = 0\n        self._timer.stop()\n        self._build_ayon_menu()\n\n    @staticmethod\n    def get_main_widget():\n        \"\"\"Get 3dsmax main window.\"\"\"\n        return QtWidgets.QWidget.find(rt.windows.getMAXHWND())\n\n    def get_main_menubar(self) -&gt; QtWidgets.QMenuBar:\n        \"\"\"Get main Menubar by 3dsmax main window.\"\"\"\n        return list(self.main_widget.findChildren(QtWidgets.QMenuBar))[0]\n\n    def _get_or_create_ayon_menu(\n            self, name: str = \"&amp;AYON\",\n            before: str = \"&amp;Help\") -&gt; QtWidgets.QAction:\n        \"\"\"Create AYON menu.\n\n        Args:\n            name (str, Optional): AYON menu name.\n            before (str, Optional): Name of the 3dsmax main menu item to\n                add AYON menu before.\n\n        Returns:\n            QtWidgets.QAction: AYON menu action.\n\n        \"\"\"\n        if self.menu is not None:\n            return self.menu\n\n        menu_bar = self.get_main_menubar()\n        menu_items = menu_bar.findChildren(\n            QtWidgets.QMenu, options=QtCore.Qt.FindDirectChildrenOnly)\n        help_action = None\n        for item in menu_items:\n            if name in item.title():\n                # we already have AYON menu\n                return item\n\n            if before in item.title():\n                help_action = item.menuAction()\n        tab_menu_label = os.environ.get(\"AYON_MENU_LABEL\") or \"AYON\"\n        op_menu = QtWidgets.QMenu(\"&amp;{}\".format(tab_menu_label))\n        menu_bar.insertMenu(help_action, op_menu)\n\n        self.menu = op_menu\n        return op_menu\n\n    def _build_ayon_menu(self) -&gt; QtWidgets.QAction:\n        \"\"\"Build items in AYON menu.\"\"\"\n        ayon_menu = self._get_or_create_ayon_menu()\n\n        context_label = lib.get_context_label()\n        context_action = QtWidgets.QAction(f\"{context_label}\", ayon_menu)\n        context_action.setEnabled(False)\n        ayon_menu.addAction(context_action)\n\n        project_name = get_current_project_name()\n        project_settings = get_project_settings(project_name)\n        if project_settings[\"core\"][\"tools\"][\"ayon_menu\"].get(\n            \"version_up_current_workfile\"):\n            version_up_action = QtWidgets.QAction(\"Version Up Workfile\", ayon_menu)\n            version_up_action.triggered.connect(self.version_up_callback)\n\n            ayon_menu.addSeparator()\n            ayon_menu.addAction(version_up_action)\n\n        ayon_menu.addSeparator()\n\n        load_action = QtWidgets.QAction(\"Load...\", ayon_menu)\n        load_action.triggered.connect(self.load_callback)\n        ayon_menu.addAction(load_action)\n\n        publish_action = QtWidgets.QAction(\"Publish...\", ayon_menu)\n        publish_action.triggered.connect(self.publish_callback)\n        ayon_menu.addAction(publish_action)\n\n        manage_action = QtWidgets.QAction(\"Manage...\", ayon_menu)\n        manage_action.triggered.connect(self.manage_callback)\n        ayon_menu.addAction(manage_action)\n\n        library_action = QtWidgets.QAction(\"Library...\", ayon_menu)\n        library_action.triggered.connect(self.library_callback)\n        ayon_menu.addAction(library_action)\n\n        ayon_menu.addSeparator()\n\n        workfiles_action = QtWidgets.QAction(\"Work Files...\", ayon_menu)\n        workfiles_action.triggered.connect(self.workfiles_callback)\n        ayon_menu.addAction(workfiles_action)\n\n        ayon_menu.addSeparator()\n\n        res_action = QtWidgets.QAction(\"Set Resolution\", ayon_menu)\n        res_action.triggered.connect(self.resolution_callback)\n        ayon_menu.addAction(res_action)\n\n        frame_action = QtWidgets.QAction(\"Set Frame Range\", ayon_menu)\n        frame_action.triggered.connect(self.frame_range_callback)\n        ayon_menu.addAction(frame_action)\n\n        colorspace_action = QtWidgets.QAction(\"Set Colorspace\", ayon_menu)\n        colorspace_action.triggered.connect(self.colorspace_callback)\n        ayon_menu.addAction(colorspace_action)\n\n        unit_scale_action = QtWidgets.QAction(\"Set Unit Scale\", ayon_menu)\n        unit_scale_action.triggered.connect(self.unit_scale_callback)\n        ayon_menu.addAction(unit_scale_action)\n\n        return ayon_menu\n\n    def load_callback(self):\n        \"\"\"Callback to show Loader tool.\"\"\"\n        host_tools.show_loader(parent=self.main_widget)\n\n    def publish_callback(self):\n        \"\"\"Callback to show Publisher tool.\"\"\"\n        host_tools.show_publisher(parent=self.main_widget)\n\n    def manage_callback(self):\n        \"\"\"Callback to show Scene Manager/Inventory tool.\"\"\"\n        host_tools.show_scene_inventory(parent=self.main_widget)\n\n    def library_callback(self):\n        \"\"\"Callback to show Library Loader tool.\"\"\"\n        host_tools.show_library_loader(parent=self.main_widget)\n\n    def workfiles_callback(self):\n        \"\"\"Callback to show Workfiles tool.\"\"\"\n        host_tools.show_workfiles(parent=self.main_widget)\n\n    def resolution_callback(self):\n        \"\"\"Callback to reset scene resolution\"\"\"\n        return lib.reset_scene_resolution()\n\n    def frame_range_callback(self):\n        \"\"\"Callback to reset frame range\"\"\"\n        return lib.reset_frame_range()\n\n    def colorspace_callback(self):\n        \"\"\"Callback to reset colorspace\"\"\"\n        return lib.reset_colorspace()\n\n    def unit_scale_callback(self):\n        \"\"\"Callback to reset unit scale\"\"\"\n        return lib.validate_unit_scale()\n\n    def version_up_callback(self):\n        \"\"\"Callback to version up current workfile.\"\"\"\n        return save_next_version()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.colorspace_callback","title":"<code>colorspace_callback()</code>","text":"<p>Callback to reset colorspace</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def colorspace_callback(self):\n    \"\"\"Callback to reset colorspace\"\"\"\n    return lib.reset_colorspace()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.frame_range_callback","title":"<code>frame_range_callback()</code>","text":"<p>Callback to reset frame range</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def frame_range_callback(self):\n    \"\"\"Callback to reset frame range\"\"\"\n    return lib.reset_frame_range()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.get_main_menubar","title":"<code>get_main_menubar()</code>","text":"<p>Get main Menubar by 3dsmax main window.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def get_main_menubar(self) -&gt; QtWidgets.QMenuBar:\n    \"\"\"Get main Menubar by 3dsmax main window.\"\"\"\n    return list(self.main_widget.findChildren(QtWidgets.QMenuBar))[0]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.get_main_widget","title":"<code>get_main_widget()</code>  <code>staticmethod</code>","text":"<p>Get 3dsmax main window.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>@staticmethod\ndef get_main_widget():\n    \"\"\"Get 3dsmax main window.\"\"\"\n    return QtWidgets.QWidget.find(rt.windows.getMAXHWND())\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.library_callback","title":"<code>library_callback()</code>","text":"<p>Callback to show Library Loader tool.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def library_callback(self):\n    \"\"\"Callback to show Library Loader tool.\"\"\"\n    host_tools.show_library_loader(parent=self.main_widget)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.load_callback","title":"<code>load_callback()</code>","text":"<p>Callback to show Loader tool.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def load_callback(self):\n    \"\"\"Callback to show Loader tool.\"\"\"\n    host_tools.show_loader(parent=self.main_widget)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.manage_callback","title":"<code>manage_callback()</code>","text":"<p>Callback to show Scene Manager/Inventory tool.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def manage_callback(self):\n    \"\"\"Callback to show Scene Manager/Inventory tool.\"\"\"\n    host_tools.show_scene_inventory(parent=self.main_widget)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.publish_callback","title":"<code>publish_callback()</code>","text":"<p>Callback to show Publisher tool.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def publish_callback(self):\n    \"\"\"Callback to show Publisher tool.\"\"\"\n    host_tools.show_publisher(parent=self.main_widget)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.resolution_callback","title":"<code>resolution_callback()</code>","text":"<p>Callback to reset scene resolution</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def resolution_callback(self):\n    \"\"\"Callback to reset scene resolution\"\"\"\n    return lib.reset_scene_resolution()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.unit_scale_callback","title":"<code>unit_scale_callback()</code>","text":"<p>Callback to reset unit scale</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def unit_scale_callback(self):\n    \"\"\"Callback to reset unit scale\"\"\"\n    return lib.validate_unit_scale()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.version_up_callback","title":"<code>version_up_callback()</code>","text":"<p>Callback to version up current workfile.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def version_up_callback(self):\n    \"\"\"Callback to version up current workfile.\"\"\"\n    return save_next_version()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/menu.html#client.ayon_max.api.menu.AYONMenu.workfiles_callback","title":"<code>workfiles_callback()</code>","text":"<p>Callback to show Workfiles tool.</p> Source code in <code>client/ayon_max/api/menu.py</code> <pre><code>def workfiles_callback(self):\n    \"\"\"Callback to show Workfiles tool.\"\"\"\n    host_tools.show_workfiles(parent=self.main_widget)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html","title":"pipeline","text":"<p>Pipeline tools for AYON 3ds max integration.</p>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.MaxHost","title":"<code>MaxHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>class MaxHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n\n    name = \"max\"\n    menu = None\n\n    def __init__(self):\n        super(MaxHost, self).__init__()\n        self._op_events = {}\n        self._has_been_setup = False\n\n    def get_app_information(self):\n        from ayon_core.host import ApplicationInformation\n\n        (\n            _rel_number,\n            _api_version,\n            _rel_rev_number,\n\n            _major_version,\n            _update_version,\n            _hotfix_number,\n            _build_number,\n\n            year_version,\n            product_version,\n        ) = rt.maxVersion()\n        version = f\"{year_version}{product_version}\"\n        return ApplicationInformation(\n            app_name=\"3ds Max\",\n            app_version=version,\n        )\n\n    def install(self):\n        pyblish.api.register_host(\"max\")\n\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n\n        _set_project()\n        _set_autobackup_dir()\n\n        self.menu = AYONMenu()\n\n        register_event_callback(\"workfile.open.before\", on_before_open)\n        register_event_callback(\"workfile.open.after\", on_after_open)\n        register_event_callback(\"before.save\", before_save)\n        register_event_callback(\"taskChanged\", self.on_task_changed)\n        self._has_been_setup = True\n        self._register_callbacks()\n\n    def workfile_has_unsaved_changes(self):\n        return rt.getSaveRequired()\n\n    def get_workfile_extensions(self):\n        return [\".max\"]\n\n    def save_workfile(self, dst_path=None):\n        rt.saveMaxFile(dst_path)\n        return dst_path\n\n    def open_workfile(self, filepath):\n        rt.checkForSave()\n        rt.loadMaxFile(filepath)\n        return filepath\n\n    def get_current_workfile(self):\n        return os.path.join(rt.maxFilePath, rt.maxFileName)\n\n    def get_containers(self):\n        return ls()\n\n    def _register_callbacks(self):\n        rt.callbacks.removeScripts(id=rt.name(\"AyonCallbacks\"))\n        rt.callbacks.addScript(\n            rt.Name('welcomeScreenDone'),\n            on_new, id=rt.name(\"AyonCallbacks\")\n        )\n        rt.callbacks.addScript(\n            rt.Name('systemPostNew'),\n            lib.set_context_setting,\n            id=rt.name(\"AyonCallbacks\")\n        )\n        rt.callbacks.addScript(\n            rt.Name('postWorkspaceChange'),\n            self._deferred_menu_creation,\n            id=rt.name(\"AyonCallbacks\"))\n        rt.NodeEventCallback(\n            nameChanged=lib.update_modifier_node_names)\n\n    def _deferred_menu_creation(self):\n        self.log.info(\"Building menu ...\")\n        self.menu = AYONMenu()\n\n    @staticmethod\n    def create_context_node():\n        \"\"\"Helper for creating context holding node.\"\"\"\n\n        root_scene = rt.rootScene\n\n        create_attr_script = (\"\"\"\nattributes \"OpenPypeContext\"\n(\n    parameters main rollout:params\n    (\n        context type: #string\n    )\n\n    rollout params \"OpenPype Parameters\"\n    (\n        editText editTextContext \"Context\" type: #string\n    )\n)\n        \"\"\")\n\n        attr = rt.execute(create_attr_script)\n        rt.custAttributes.add(root_scene, attr)\n\n        return root_scene.OpenPypeContext.context\n\n    def update_context_data(self, data, changes):\n        try:\n            _ = rt.rootScene.OpenPypeContext.context\n        except AttributeError:\n            # context node doesn't exists\n            self.create_context_node()\n\n        rt.rootScene.OpenPypeContext.context = json.dumps(data)\n\n    def get_context_data(self):\n        try:\n            context = rt.rootScene.OpenPypeContext.context\n        except AttributeError:\n            # context node doesn't exists\n            context = self.create_context_node()\n        if not context:\n            context = \"{}\"\n        return json.loads(context)\n\n    def on_task_changed(self):\n        if lib.is_headless():\n            return\n\n        ayon_menu = self.menu.menu\n        if ayon_menu is not None:\n            actions = ayon_menu.actions()\n            context_action = actions[0]\n            context_label = lib.get_context_label()\n            context_action.setText(f\"{context_label}\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.MaxHost.create_context_node","title":"<code>create_context_node()</code>  <code>staticmethod</code>","text":"<p>Helper for creating context holding node.</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>    @staticmethod\n    def create_context_node():\n        \"\"\"Helper for creating context holding node.\"\"\"\n\n        root_scene = rt.rootScene\n\n        create_attr_script = (\"\"\"\nattributes \"OpenPypeContext\"\n(\n    parameters main rollout:params\n    (\n        context type: #string\n    )\n\n    rollout params \"OpenPype Parameters\"\n    (\n        editText editTextContext \"Context\" type: #string\n    )\n)\n        \"\"\")\n\n        attr = rt.execute(create_attr_script)\n        rt.custAttributes.add(root_scene, attr)\n\n        return root_scene.OpenPypeContext.context\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.before_save","title":"<code>before_save(event)</code>","text":"<p>Check and set up project before saving workfile</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def before_save(event):\n    \"\"\"Check and set up project before saving workfile\n    \"\"\"\n    max_filename_before: str = rt.maxFileName\n    max_filename_after: str = event.get(\"filename\")\n\n    if not max_filename_before:\n        # Saving from a new unsaved file, no need to check for changes.\n        return\n\n    if max_filename_before != max_filename_after:\n        print(f\"Detected scene name change from {max_filename_before} to \"\n              f\"{max_filename_after}\")\n    max_filename_before = os.path.splitext(max_filename_before)[0]\n    max_filename_after = os.path.splitext(max_filename_after)[0]\n    lib.reset_render_outputs(max_filename_before, max_filename_after)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.containerise_texture","title":"<code>containerise_texture(name, context, view_node, sme_view_number, namespace=None, loader=None, suffix='_CON')</code>","text":"<p>Containerise texture nodes</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the container</p> required <code>context</code> <code>dict</code> <p>context</p> required <code>view_node</code> <p>texture node</p> required <code>sme_view</code> <p>target view of slate material editor</p> required <code>namespace</code> <code>str</code> <p>namespace. Defaults to None.</p> <code>None</code> <code>loader</code> <code>str</code> <p>loader. Defaults to None.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>suffix. Defaults to \"_CON\".</p> <code>'_CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <p>The container object holding the texture node metadata.</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def containerise_texture(name: str, context: dict,\n                         view_node, sme_view_number,\n                         namespace=None, loader=None,\n                         suffix=\"_CON\"):\n    \"\"\"Containerise texture nodes\n\n    Args:\n        name (str): name of the container\n        context (dict): context\n        view_node: texture node\n        sme_view: target view of slate material editor\n        namespace (str, optional): namespace. Defaults to None.\n        loader (str, optional): loader. Defaults to None.\n        suffix (str, optional): suffix. Defaults to \"_CON\".\n\n    Returns:\n        container: The container object holding the texture node metadata.\n    \"\"\"\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace or \"\",\n        \"loader\": loader,\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n        \"view_node\": view_node,\n        \"sme_view_number\": sme_view_number,\n    }\n    container_name = f\"{namespace}:{name}{suffix}\"\n    container = rt.container(name=container_name)\n    if not lib.imprint(container_name, data):\n        raise RuntimeError(f\"imprinting of {container_name} failed.\")\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.get_previous_loaded_object","title":"<code>get_previous_loaded_object(container)</code>","text":"<p>Get previous loaded_object through the OP data</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>the container which stores the OP data</p> required <p>Returns:</p> Name Type Description <code>node_list</code> <code>list</code> <p>list of nodes which are previously loaded</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def get_previous_loaded_object(container: str):\n    \"\"\"Get previous loaded_object through the OP data\n\n    Args:\n        container (str): the container which stores the OP data\n\n    Returns:\n        node_list(list): list of nodes which are previously loaded\n    \"\"\"\n    node_list = []\n    node_transform_monitor_list = rt.getProperty(\n        container.modifiers[0].openPypeData, \"all_handles\")\n    for node_transform_monitor in node_transform_monitor_list:\n        node_list.append(node_transform_monitor.node)\n    return node_list\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.import_custom_attribute_data","title":"<code>import_custom_attribute_data(container, selections)</code>","text":"<p>Importing the Openpype/AYON custom parameter built by the creator</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>target container which adds custom attributes</p> required <code>selections</code> <code>list</code> <p>nodes to be added into</p> required Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def import_custom_attribute_data(container: str, selections: list):\n    \"\"\"Importing the Openpype/AYON custom parameter built by the creator\n\n    Args:\n        container (str): target container which adds custom attributes\n        selections (list): nodes to be added into\n        group in custom attributes\n    \"\"\"\n    attrs = load_custom_attribute_data()\n    modifier = rt.EmptyModifier()\n    rt.addModifier(container, modifier)\n    container.modifiers[0].name = \"OP Data\"\n    rt.custAttributes.add(container.modifiers[0], attrs)\n    node_list = []\n    sel_list = []\n    for i in selections:\n        node_ref = rt.NodeTransformMonitor(node=i)\n        node_list.append(node_ref)\n        sel_list.append(str(i))\n\n    # Setting the property\n    rt.setProperty(\n        container.modifiers[0].openPypeData,\n        \"all_handles\", node_list)\n    rt.setProperty(\n        container.modifiers[0].openPypeData,\n        \"sel_list\", sel_list)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.load_custom_attribute_data","title":"<code>load_custom_attribute_data()</code>","text":"<p>Re-loading the AYON custom parameter built by the creator</p> <p>Returns:</p> Name Type Description <code>attribute</code> <p>re-loading the custom OP attributes set in Maxscript</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def load_custom_attribute_data():\n    \"\"\"Re-loading the AYON custom parameter built by the creator\n\n    Returns:\n        attribute: re-loading the custom OP attributes set in Maxscript\n    \"\"\"\n    return rt.Execute(MS_CUSTOM_ATTRIB)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Get all AYON containers.</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Get all AYON containers.\"\"\"\n    objs = rt.objects\n    containers = [\n        obj for obj in objs\n        if rt.getUserProp(obj, \"id\") in {\n            AYON_CONTAINER_ID, AVALON_CONTAINER_ID\n        }\n    ]\n\n    for container in sorted(containers, key=attrgetter(\"name\")):\n        yield parse_container(container)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.on_after_open","title":"<code>on_after_open()</code>","text":"<p>Check and set up unit scale after opening workfile if user enabled.</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def on_after_open():\n    \"\"\"Check and set up unit scale after opening workfile if user enabled.\n    \"\"\"\n    lib.validate_unit_scale()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.on_before_open","title":"<code>on_before_open()</code>","text":"<p>Check and set up project before opening workfile</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def on_before_open():\n    \"\"\"Check and set up project before opening workfile\n    \"\"\"\n    _set_project()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.parse_container","title":"<code>parse_container(container)</code>","text":"<p>Return the container node's full container data.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>A container node name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The container schema data for this container node.</p> Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def parse_container(container):\n    \"\"\"Return the container node's full container data.\n\n    Args:\n        container (str): A container node name.\n\n    Returns:\n        dict: The container schema data for this container node.\n\n    \"\"\"\n    data = lib.read(container)\n\n    # Backwards compatibility pre-schemas for containers\n    data[\"schema\"] = data.get(\"schema\", \"openpype:container-3.0\")\n\n    # Append transient data\n    data[\"objectName\"] = container.Name\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.remove_container_data","title":"<code>remove_container_data(container_node)</code>","text":"<p>Function to remove container data after updating, switching or deleting it.</p> <p>Parameters:</p> Name Type Description Default <code>container_node</code> <code>str</code> <p>container node</p> required Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def remove_container_data(container_node: str):\n    \"\"\"Function to remove container data after updating, switching or deleting it.\n\n    Args:\n        container_node (str): container node\n    \"\"\"\n    if container_node.modifiers[0].name == \"OP Data\":\n        all_set_members_names = [\n            member.node for member\n            in container_node.modifiers[0].openPypeData.all_handles]\n        # clean up the children of alembic dummy objects\n        for current_set_member in all_set_members_names:\n            shape_list = [members for members in current_set_member.Children\n                          if rt.ClassOf(members) == rt.AlembicObject\n                          or rt.isValidNode(members)]\n            if shape_list:  # noqa\n                rt.Delete(shape_list)\n            rt.Delete(current_set_member)\n        rt.deleteModifier(container_node, container_node.modifiers[0])\n\n    rt.Delete(container_node)\n    rt.redrawViews()\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/pipeline.html#client.ayon_max.api.pipeline.update_custom_attribute_data","title":"<code>update_custom_attribute_data(container, selections)</code>","text":"<p>Updating the AYON custom parameter built by the creator</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>str</code> <p>target container which adds custom attributes</p> required <code>selections</code> <code>list</code> <p>nodes to be added into</p> required Source code in <code>client/ayon_max/api/pipeline.py</code> <pre><code>def update_custom_attribute_data(container: str, selections: list):\n    \"\"\"Updating the AYON custom parameter built by the creator\n\n    Args:\n        container (str): target container which adds custom attributes\n        selections (list): nodes to be added into\n        group in custom attributes\n    \"\"\"\n    if container.modifiers[0].name == \"OP Data\":\n        rt.deleteModifier(container, container.modifiers[0])\n    import_custom_attribute_data(container, selections)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html","title":"plugin","text":"<p>3dsmax specific AYON/Pyblish plugin definitions.</p>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxCacheCreator","title":"<code>MaxCacheCreator</code>","text":"<p>               Bases: <code>Creator</code>, <code>MaxTyFlowDataCreatorBase</code></p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>class MaxCacheCreator(Creator, MaxTyFlowDataCreatorBase):\n    settings_category = \"max\"\n    def create(self, product_name, instance_data, pre_create_data):\n        tyflow_op_nodes = get_tyflow_export_operators()\n        if not tyflow_op_nodes:\n            raise CreatorError(\"No Export Particle Operators\"\n                               \" found in tyCache Editor.\")\n        instance_node = self.create_instance_node(product_name)\n        instance_data[\"instance_node\"] = instance_node.name\n        instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=instance_data,\n            creator=self,\n        )\n        # Setting the property\n        node_list = [sub_anim.name for sub_anim in tyflow_op_nodes]\n        rt.setProperty(\n            instance_node.modifiers[0].AYONTyCacheData,\n            \"tyc_handles\", node_list)\n        self._add_instance_to_context(instance)\n        imprint(instance_node.name, instance.data_to_store())\n\n        return instance\n\n    def collect_instances(self):\n        self.cache_instance_data(self.collection_shared_data)\n        for instance in self.collection_shared_data[\"max_cached_instances\"].get(self.identifier, []):  # noqa\n            created_instance = CreatedInstance.from_existing(\n                read(rt.GetNodeByName(instance)), self\n            )\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, changes in update_list:\n            instance_node = created_inst.get(\"instance_node\")\n            new_values = {\n                key: changes[key].new_value\n                for key in changes.changed_keys\n            }\n            product_name = new_values.get(\"productName\", \"\")\n            if product_name and instance_node != product_name:\n                node = rt.getNodeByName(instance_node)\n                new_product_name = new_values[\"productName\"]\n                if rt.getNodeByName(new_product_name):\n                    raise CreatorError(\n                        \"The product '{}' already exists.\".format(\n                            new_product_name))\n                instance_node = new_product_name\n                created_inst[\"instance_node\"] = instance_node\n                node.name = instance_node\n\n            imprint(\n                instance_node,\n                created_inst.data_to_store(),\n            )\n\n    def remove_instances(self, instances):\n        \"\"\"Remove specified instance from the scene.\n\n        This is only removing AYON-related parameters based on the modifier\n        so instance is no longer instance, because it might contain\n        valuable data for artist.\n\n        \"\"\"\n        for instance in instances:\n            instance_node = rt.GetNodeByName(\n                instance.data.get(\"instance_node\"))\n            if instance_node:\n                count = rt.custAttributes.count(instance_node.modifiers[0])\n                rt.custAttributes.delete(instance_node.modifiers[0], count)\n                rt.Delete(instance_node)\n\n            self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxCacheCreator.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Remove specified instance from the scene.</p> <p>This is only removing AYON-related parameters based on the modifier so instance is no longer instance, because it might contain valuable data for artist.</p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Remove specified instance from the scene.\n\n    This is only removing AYON-related parameters based on the modifier\n    so instance is no longer instance, because it might contain\n    valuable data for artist.\n\n    \"\"\"\n    for instance in instances:\n        instance_node = rt.GetNodeByName(\n            instance.data.get(\"instance_node\"))\n        if instance_node:\n            count = rt.custAttributes.count(instance_node.modifiers[0])\n            rt.custAttributes.delete(instance_node.modifiers[0], count)\n            rt.Delete(instance_node)\n\n        self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxCreator","title":"<code>MaxCreator</code>","text":"<p>               Bases: <code>Creator</code>, <code>MaxCreatorBase</code></p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>class MaxCreator(Creator, MaxCreatorBase):\n    selected_nodes = []\n\n    def create(self, product_name, instance_data, pre_create_data):\n        if pre_create_data.get(\"use_selection\"):\n            self.selected_nodes = rt.GetCurrentSelection()\n        if rt.getNodeByName(product_name):\n            raise CreatorError(f\"'{product_name}' is already created..\")\n\n        instance_node = self.create_instance_node(product_name)\n        instance_data[\"instance_node\"] = instance_node.name\n        instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=instance_data,\n            creator=self,\n        )\n        if pre_create_data.get(\"use_selection\"):\n\n            node_list = []\n            sel_list = []\n            for i in self.selected_nodes:\n                node_ref = rt.NodeTransformMonitor(node=i)\n                node_list.append(node_ref)\n                sel_list.append(str(i))\n\n            # Setting the property\n            rt.setProperty(\n                instance_node.modifiers[0].openPypeData,\n                \"all_handles\", node_list)\n            rt.setProperty(\n                instance_node.modifiers[0].openPypeData,\n                \"sel_list\", sel_list)\n\n        self._add_instance_to_context(instance)\n        imprint(instance_node.name, instance.data_to_store())\n\n        return instance\n\n    def collect_instances(self):\n        self.cache_instance_data(self.collection_shared_data)\n        for instance in self.collection_shared_data[\"max_cached_instances\"].get(self.identifier, []):  # noqa\n            created_instance = CreatedInstance.from_existing(\n                read(rt.GetNodeByName(instance)), self\n            )\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, changes in update_list:\n            instance_node = created_inst.get(\"instance_node\")\n            new_values = {\n                key: changes[key].new_value\n                for key in changes.changed_keys\n            }\n            product_name = new_values.get(\"productName\", \"\")\n            if product_name and instance_node != product_name:\n                node = rt.getNodeByName(instance_node)\n                new_product_name = new_values[\"productName\"]\n                if rt.getNodeByName(new_product_name):\n                    raise CreatorError(\n                        \"The product '{}' already exists.\".format(\n                            new_product_name))\n                instance_node = new_product_name\n                created_inst[\"instance_node\"] = instance_node\n                node.name = instance_node\n\n            imprint(\n                instance_node,\n                created_inst.data_to_store(),\n            )\n\n    def remove_instances(self, instances):\n        \"\"\"Remove specified instance from the scene.\n\n        This is only removing `id` parameter so instance is no longer\n        instance, because it might contain valuable data for artist.\n\n        \"\"\"\n        for instance in instances:\n            instance_node = rt.GetNodeByName(\n                instance.data.get(\"instance_node\"))\n            if instance_node:\n                count = rt.custAttributes.count(instance_node.modifiers[0])\n                rt.custAttributes.delete(instance_node.modifiers[0], count)\n                rt.Delete(instance_node)\n\n            self._remove_instance_from_context(instance)\n\n    def get_pre_create_attr_defs(self):\n        return [\n            BoolDef(\"use_selection\", label=\"Use selection\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxCreator.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Remove specified instance from the scene.</p> <p>This is only removing <code>id</code> parameter so instance is no longer instance, because it might contain valuable data for artist.</p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Remove specified instance from the scene.\n\n    This is only removing `id` parameter so instance is no longer\n    instance, because it might contain valuable data for artist.\n\n    \"\"\"\n    for instance in instances:\n        instance_node = rt.GetNodeByName(\n            instance.data.get(\"instance_node\"))\n        if instance_node:\n            count = rt.custAttributes.count(instance_node.modifiers[0])\n            rt.custAttributes.delete(instance_node.modifiers[0], count)\n            rt.Delete(instance_node)\n\n        self._remove_instance_from_context(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxCreatorBase","title":"<code>MaxCreatorBase</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>class MaxCreatorBase(object):\n\n    @staticmethod\n    def cache_instance_data(shared_data):\n        if shared_data.get(\"max_cached_instances\") is not None:\n            return shared_data\n\n        shared_data[\"max_cached_instances\"] = {}\n\n        cached_instances = []\n        for id_type in [AYON_INSTANCE_ID, AVALON_INSTANCE_ID]:\n            cached_instances.extend(lsattr(\"id\", id_type))\n\n        for i in cached_instances:\n            creator_id = rt.GetUserProp(i, \"creator_identifier\")\n            if creator_id not in shared_data[\"max_cached_instances\"]:\n                shared_data[\"max_cached_instances\"][creator_id] = [i.name]\n            else:\n                shared_data[\n                    \"max_cached_instances\"][creator_id].append(i.name)\n        return shared_data\n\n    @staticmethod\n    def create_instance_node(node):\n        \"\"\"Create instance node.\n\n        If the supplied node is existing node, it will be used to hold the\n        instance, otherwise new node of type Dummy will be created.\n\n        Args:\n            node (rt.MXSWrapperBase, str): Node or node name to use.\n\n        Returns:\n            instance\n        \"\"\"\n        if not isinstance(node, str):\n            raise CreatorError(\"Instance node is not at the string value.\")\n\n        node = rt.Container(name=node)\n        attrs = rt.Execute(MS_CUSTOM_ATTRIB)\n        modifier = rt.EmptyModifier()\n        rt.addModifier(node, modifier)\n        node.modifiers[0].name = \"OP Data\"\n        rt.custAttributes.add(node.modifiers[0], attrs)\n\n        return node\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxCreatorBase.create_instance_node","title":"<code>create_instance_node(node)</code>  <code>staticmethod</code>","text":"<p>Create instance node.</p> <p>If the supplied node is existing node, it will be used to hold the instance, otherwise new node of type Dummy will be created.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>(MXSWrapperBase, str)</code> <p>Node or node name to use.</p> required <p>Returns:</p> Type Description <p>instance</p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>@staticmethod\ndef create_instance_node(node):\n    \"\"\"Create instance node.\n\n    If the supplied node is existing node, it will be used to hold the\n    instance, otherwise new node of type Dummy will be created.\n\n    Args:\n        node (rt.MXSWrapperBase, str): Node or node name to use.\n\n    Returns:\n        instance\n    \"\"\"\n    if not isinstance(node, str):\n        raise CreatorError(\"Instance node is not at the string value.\")\n\n    node = rt.Container(name=node)\n    attrs = rt.Execute(MS_CUSTOM_ATTRIB)\n    modifier = rt.EmptyModifier()\n    rt.addModifier(node, modifier)\n    node.modifiers[0].name = \"OP Data\"\n    rt.custAttributes.add(node.modifiers[0], attrs)\n\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxTyFlowDataCreatorBase","title":"<code>MaxTyFlowDataCreatorBase</code>","text":"<p>               Bases: <code>MaxCreatorBase</code></p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>class MaxTyFlowDataCreatorBase(MaxCreatorBase):\n    @staticmethod\n    def create_instance_node(node):\n        \"\"\"Create instance node.\n\n        If the supplied node is existing node, it will be used to hold the\n        instance, otherwise new node of type Dummy will be created.\n\n        Args:\n            node (rt.MXSWrapperBase, str): Node or node name to use.\n\n        Returns:\n            instance\n        \"\"\"\n        if not isinstance(node, str):\n            raise CreatorError(\"Instance node is not at the string value.\")\n        node = rt.Container(name=node)\n        attrs = rt.Execute(MS_TYCACHE_ATTRIB)\n        modifier = rt.EmptyModifier()\n        rt.addModifier(node, modifier)\n        node.modifiers[0].name = \"AYON TyCache Data\"\n        rt.custAttributes.add(node.modifiers[0], attrs)\n\n        return node\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/plugin.html#client.ayon_max.api.plugin.MaxTyFlowDataCreatorBase.create_instance_node","title":"<code>create_instance_node(node)</code>  <code>staticmethod</code>","text":"<p>Create instance node.</p> <p>If the supplied node is existing node, it will be used to hold the instance, otherwise new node of type Dummy will be created.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>(MXSWrapperBase, str)</code> <p>Node or node name to use.</p> required <p>Returns:</p> Type Description <p>instance</p> Source code in <code>client/ayon_max/api/plugin.py</code> <pre><code>@staticmethod\ndef create_instance_node(node):\n    \"\"\"Create instance node.\n\n    If the supplied node is existing node, it will be used to hold the\n    instance, otherwise new node of type Dummy will be created.\n\n    Args:\n        node (rt.MXSWrapperBase, str): Node or node name to use.\n\n    Returns:\n        instance\n    \"\"\"\n    if not isinstance(node, str):\n        raise CreatorError(\"Instance node is not at the string value.\")\n    node = rt.Container(name=node)\n    attrs = rt.Execute(MS_TYCACHE_ATTRIB)\n    modifier = rt.EmptyModifier()\n    rt.addModifier(node, modifier)\n    node.modifiers[0].name = \"AYON TyCache Data\"\n    rt.custAttributes.add(node.modifiers[0], attrs)\n\n    return node\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/preview_animation.html","title":"preview_animation","text":""},{"location":"autoapi/client/ayon_max/api/preview_animation.html#client.ayon_max.api.preview_animation.play_preview_when_done","title":"<code>play_preview_when_done(has_autoplay)</code>","text":"<p>Set preview playback option during context</p> <p>Parameters:</p> Name Type Description Default <code>has_autoplay</code> <code>bool</code> <p>autoplay during creating preview animation</p> required Source code in <code>client/ayon_max/api/preview_animation.py</code> <pre><code>@contextlib.contextmanager\ndef play_preview_when_done(has_autoplay):\n    \"\"\"Set preview playback option during context\n\n    Args:\n        has_autoplay (bool): autoplay during creating\n            preview animation\n    \"\"\"\n    current_playback = rt.preferences.playPreviewWhenDone\n    try:\n        rt.preferences.playPreviewWhenDone = has_autoplay\n        yield\n    finally:\n        rt.preferences.playPreviewWhenDone = current_playback\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/preview_animation.html#client.ayon_max.api.preview_animation.render_preview_animation","title":"<code>render_preview_animation(filepath, ext, camera, start_frame=None, end_frame=None, percentSize=100.0, width=1920, height=1080, viewport_options=None)</code>","text":"<p>Render camera review animation Args:     filepath (str): filepath to render to, without frame number and         extension     ext (str): output file extension     camera (str): viewport camera for preview render     start_frame (int): start frame     end_frame (int): end frame     percentSize (float): render resolution multiplier by 100         e.g. 100.0 is 1x, 50.0 is 0.5x, 150.0 is 1.5x     width (int): render resolution width     height (int): render resolution height     viewport_options (dict): viewport setting options Returns:     list: Rendered output files</p> Source code in <code>client/ayon_max/api/preview_animation.py</code> <pre><code>def render_preview_animation(\n        filepath,\n        ext,\n        camera,\n        start_frame=None,\n        end_frame=None,\n        percentSize=100.0,\n        width=1920,\n        height=1080,\n        viewport_options=None):\n    \"\"\"Render camera review animation\n    Args:\n        filepath (str): filepath to render to, without frame number and\n            extension\n        ext (str): output file extension\n        camera (str): viewport camera for preview render\n        start_frame (int): start frame\n        end_frame (int): end frame\n        percentSize (float): render resolution multiplier by 100\n            e.g. 100.0 is 1x, 50.0 is 0.5x, 150.0 is 1.5x\n        width (int): render resolution width\n        height (int): render resolution height\n        viewport_options (dict): viewport setting options\n    Returns:\n        list: Rendered output files\n    \"\"\"\n    if start_frame is None:\n        start_frame = int(rt.animationRange.start)\n    if end_frame is None:\n        end_frame = int(rt.animationRange.end)\n\n    if viewport_options is None:\n        viewport_options = viewport_options_for_preview_animation()\n    with play_preview_when_done(False):\n        with viewport_layout_and_camera(camera):\n            if int(get_max_version()) &lt; 2024:\n                with viewport_preference_setting(\n                        viewport_options[\"general_viewport\"],\n                        viewport_options[\"nitrous_manager\"],\n                        viewport_options[\"nitrous_viewport\"],\n                        viewport_options[\"vp_btn_mgr\"]\n                ):\n                    return _render_preview_animation_max_pre_2024(\n                        filepath,\n                        start_frame,\n                        end_frame,\n                        width,\n                        height,\n                        percentSize,\n                        ext\n                    )\n            else:\n                with render_resolution(width, height):\n                    return _render_preview_animation_max_2024(\n                        filepath,\n                        start_frame,\n                        end_frame,\n                        percentSize,\n                        ext,\n                        viewport_options\n                    )\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/preview_animation.html#client.ayon_max.api.preview_animation.viewport_layout_and_camera","title":"<code>viewport_layout_and_camera(camera, layout='layout_1')</code>","text":"<p>Set viewport layout and camera during context ***For 3dsMax 2024+ Args:     camera (str): viewport camera     layout (str): layout to use in viewport, defaults to <code>layout_1</code>         Use None to not change viewport layout during context.</p> Source code in <code>client/ayon_max/api/preview_animation.py</code> <pre><code>@contextlib.contextmanager\ndef viewport_layout_and_camera(camera, layout=\"layout_1\"):\n    \"\"\"Set viewport layout and camera during context\n    ***For 3dsMax 2024+\n    Args:\n        camera (str): viewport camera\n        layout (str): layout to use in viewport, defaults to `layout_1`\n            Use None to not change viewport layout during context.\n    \"\"\"\n    needs_maximise = 0\n    # Set to first active non extended viewport\n    rt.viewport.activeViewportEx(1)\n    original_camera = rt.viewport.getCamera()\n    original_type = rt.viewport.getType()\n    review_camera = rt.getNodeByName(camera)\n\n    try:\n        if rt.viewport.getLayout() != rt.name(layout):\n            rt.execute(\"max tool maximize\")\n            needs_maximise = 1\n        rt.viewport.setCamera(review_camera)\n        yield\n    finally:\n        if needs_maximise == 1:\n            rt.execute(\"max tool maximize\")\n        if original_type == rt.Name(\"view_camera\"):\n            rt.viewport.setCamera(original_camera)\n        else:\n            rt.viewport.setType(original_type)\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/preview_animation.html#client.ayon_max.api.preview_animation.viewport_options_for_preview_animation","title":"<code>viewport_options_for_preview_animation()</code>","text":"<p>Get default viewport options for <code>render_preview_animation</code>.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>viewport setting options</p> Source code in <code>client/ayon_max/api/preview_animation.py</code> <pre><code>def viewport_options_for_preview_animation():\n    \"\"\"Get default viewport options for `render_preview_animation`.\n\n    Returns:\n        dict: viewport setting options\n    \"\"\"\n    # viewport_options should be the dictionary\n    if int(get_max_version()) &lt; 2024:\n        return {\n            \"visualStyleMode\": \"defaultshading\",\n            \"viewportPreset\": \"highquality\",\n            \"vpTexture\": False,\n            \"dspGeometry\": True,\n            \"dspShapes\": False,\n            \"dspLights\": False,\n            \"dspCameras\": False,\n            \"dspHelpers\": False,\n            \"dspParticles\": True,\n            \"dspBones\": False,\n            \"dspBkg\": True,\n            \"dspGrid\": False,\n            \"dspSafeFrame\": False,\n            \"dspFrameNums\": False\n        }\n    else:\n        viewport_options = {}\n        viewport_options[\"general_viewport\"] = {\n            \"dspBkg\": True,\n            \"dspGrid\": False\n        }\n        viewport_options[\"nitrous_manager\"] = {\n            \"AntialiasingQuality\": \"None\"\n        }\n        viewport_options[\"nitrous_viewport\"] = {\n            \"VisualStyleMode\": \"defaultshading\",\n            \"ViewportPreset\": \"highquality\",\n            \"UseTextureEnabled\": False\n        }\n        viewport_options[\"vp_btn_mgr\"] = {\n            \"EnableButtons\": False}\n        return viewport_options\n</code></pre>"},{"location":"autoapi/client/ayon_max/api/preview_animation.html#client.ayon_max.api.preview_animation.viewport_preference_setting","title":"<code>viewport_preference_setting(general_viewport, nitrous_manager, nitrous_viewport, vp_button_mgr)</code>","text":"<p>Function to set viewport setting during context ***For Max Version &lt; 2024 Args:     camera (str): Viewport camera for review render     general_viewport (dict): General viewport setting     nitrous_manager (dict): Nitrous graphic manager     nitrous_viewport (dict): Nitrous setting for         preview animation     vp_button_mgr (dict): Viewport button manager Setting     preview_preferences (dict): Preview Preferences Setting</p> Source code in <code>client/ayon_max/api/preview_animation.py</code> <pre><code>@contextlib.contextmanager\ndef viewport_preference_setting(general_viewport,\n                                nitrous_manager,\n                                nitrous_viewport,\n                                vp_button_mgr):\n    \"\"\"Function to set viewport setting during context\n    ***For Max Version &lt; 2024\n    Args:\n        camera (str): Viewport camera for review render\n        general_viewport (dict): General viewport setting\n        nitrous_manager (dict): Nitrous graphic manager\n        nitrous_viewport (dict): Nitrous setting for\n            preview animation\n        vp_button_mgr (dict): Viewport button manager Setting\n        preview_preferences (dict): Preview Preferences Setting\n    \"\"\"\n    orig_vp_grid = rt.viewport.getGridVisibility(1)\n    orig_vp_bkg = rt.viewport.IsSolidBackgroundColorMode()\n\n    nitrousGraphicMgr = rt.NitrousGraphicsManager\n    viewport_setting = nitrousGraphicMgr.GetActiveViewportSetting()\n    vp_button_mgr_original = {\n        key: getattr(rt.ViewportButtonMgr, key) for key in vp_button_mgr\n    }\n    nitrous_manager_original = {\n        key: getattr(nitrousGraphicMgr, key) for key in nitrous_manager\n    }\n    nitrous_viewport_original = {\n        key: getattr(viewport_setting, key) for key in nitrous_viewport\n    }\n\n    try:\n        rt.viewport.setGridVisibility(1, general_viewport[\"dspGrid\"])\n        rt.viewport.EnableSolidBackgroundColorMode(general_viewport[\"dspBkg\"])\n        for key, value in vp_button_mgr.items():\n            setattr(rt.ViewportButtonMgr, key, value)\n        for key, value in nitrous_manager.items():\n            setattr(nitrousGraphicMgr, key, value)\n        for key, value in nitrous_viewport.items():\n            if nitrous_viewport[key] != nitrous_viewport_original[key]:\n                setattr(viewport_setting, key, value)\n        yield\n\n    finally:\n        rt.viewport.setGridVisibility(1, orig_vp_grid)\n        rt.viewport.EnableSolidBackgroundColorMode(orig_vp_bkg)\n        for key, value in vp_button_mgr_original.items():\n            setattr(rt.ViewportButtonMgr, key, value)\n        for key, value in nitrous_manager_original.items():\n            setattr(nitrousGraphicMgr, key, value)\n        for key, value in nitrous_viewport_original.items():\n            setattr(viewport_setting, key, value)\n</code></pre>"},{"location":"autoapi/client/ayon_max/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_max/hooks/force_startup_script.html","title":"force_startup_script","text":"<p>Pre-launch to force 3ds max startup script.</p>"},{"location":"autoapi/client/ayon_max/hooks/force_startup_script.html#client.ayon_max.hooks.force_startup_script.ForceStartupScript","title":"<code>ForceStartupScript</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Inject AYON environment to 3ds max.</p> <p>Note that this works in combination whit 3dsmax startup script that is translating it back to PYTHONPATH for cases when 3dsmax drops PYTHONPATH environment.</p> <p>Hook <code>GlobalHostDataHook</code> must be executed before this hook.</p> Source code in <code>client/ayon_max/hooks/force_startup_script.py</code> <pre><code>class ForceStartupScript(PreLaunchHook):\n    \"\"\"Inject AYON environment to 3ds max.\n\n    Note that this works in combination whit 3dsmax startup script that\n    is translating it back to PYTHONPATH for cases when 3dsmax drops PYTHONPATH\n    environment.\n\n    Hook `GlobalHostDataHook` must be executed before this hook.\n    \"\"\"\n    app_groups = {\"3dsmax\", \"adsk_3dsmax\"}\n    order = 11\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        startup_args = [\n            \"-U\",\n            \"MAXScript\",\n            os.path.join(MAX_HOST_DIR, \"startup\", \"startup.ms\"),\n        ]\n        self.launch_context.launch_args.append(startup_args)\n</code></pre>"},{"location":"autoapi/client/ayon_max/hooks/inject_python.html","title":"inject_python","text":"<p>Pre-launch hook to inject python environment.</p>"},{"location":"autoapi/client/ayon_max/hooks/inject_python.html#client.ayon_max.hooks.inject_python.InjectPythonPath","title":"<code>InjectPythonPath</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Inject AYON environment to 3dsmax.</p> <p>Note that this works in combination whit 3dsmax startup script that is translating it back to PYTHONPATH for cases when 3dsmax drops PYTHONPATH environment.</p> <p>Hook <code>GlobalHostDataHook</code> must be executed before this hook.</p> Source code in <code>client/ayon_max/hooks/inject_python.py</code> <pre><code>class InjectPythonPath(PreLaunchHook):\n    \"\"\"Inject AYON environment to 3dsmax.\n\n    Note that this works in combination whit 3dsmax startup script that\n    is translating it back to PYTHONPATH for cases when 3dsmax drops PYTHONPATH\n    environment.\n\n    Hook `GlobalHostDataHook` must be executed before this hook.\n    \"\"\"\n    app_groups = {\"3dsmax\", \"adsk_3dsmax\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        self.launch_context.env[\"MAX_PYTHONPATH\"] = os.environ[\"PYTHONPATH\"]\n</code></pre>"},{"location":"autoapi/client/ayon_max/hooks/pre_copy_mxp.html","title":"pre_copy_mxp","text":""},{"location":"autoapi/client/ayon_max/hooks/pre_copy_mxp.html#client.ayon_max.hooks.pre_copy_mxp.PreCopyMxp","title":"<code>PreCopyMxp</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Copy workspace.mxp to workdir.</p> <p>Hook <code>GlobalHostDataHook</code> must be executed before this hook.</p> Source code in <code>client/ayon_max/hooks/pre_copy_mxp.py</code> <pre><code>class PreCopyMxp(PreLaunchHook):\n    \"\"\"Copy workspace.mxp to workdir.\n\n    Hook `GlobalHostDataHook` must be executed before this hook.\n    \"\"\"\n    app_groups = {\"3dsmax\", \"adsk_3dsmax\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        max_setting = self.data[\"project_settings\"][\"max\"]\n        mxp_workspace = max_setting.get(\"mxp_workspace\")\n        # Ensure the hook would not cause possible error\n        # when using the old addon.\n        if mxp_workspace is None:\n            self.log.warning(\"No mxp workspace setting found in the \"\n                             \"latest Max Addon.\")\n            return\n        enabled_project_creation = mxp_workspace.get(\"enabled_project_creation\")\n        if not enabled_project_creation:\n            self.log.debug(\"3dsmax project creation is not enabled. \"\n                           \"Skipping creating workspace.mxp to workdir.\")\n            return\n        workdir = self.launch_context.env.get(\"AYON_WORKDIR\")\n        if not workdir:\n            self.log.warning(\"BUG: Workdir is not filled.\")\n            return\n\n        create_workspace_mxp(workdir, mxp_workspace=mxp_workspace)\n</code></pre>"},{"location":"autoapi/client/ayon_max/hooks/set_paths.html","title":"set_paths","text":""},{"location":"autoapi/client/ayon_max/hooks/set_paths.html#client.ayon_max.hooks.set_paths.SetPath","title":"<code>SetPath</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Set current dir to workdir.</p> <p>Hook <code>GlobalHostDataHook</code> must be executed before this hook.</p> Source code in <code>client/ayon_max/hooks/set_paths.py</code> <pre><code>class SetPath(PreLaunchHook):\n    \"\"\"Set current dir to workdir.\n\n    Hook `GlobalHostDataHook` must be executed before this hook.\n    \"\"\"\n    app_groups = {\"max\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        workdir = self.launch_context.env.get(\"AYON_WORKDIR\", \"\")\n        if not workdir:\n            self.log.warning(\"BUG: Workdir is not filled.\")\n            return\n\n        self.launch_context.kwargs[\"cwd\"] = workdir\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_max/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_max/plugins/create/create_camera.html","title":"create_camera","text":"<p>Creator plugin for creating camera.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_camera.html#client.ayon_max.plugins.create.create_camera.CreateCamera","title":"<code>CreateCamera</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Creator plugin for Camera.</p> Source code in <code>client/ayon_max/plugins/create/create_camera.py</code> <pre><code>class CreateCamera(plugin.MaxCreator):\n    \"\"\"Creator plugin for Camera.\"\"\"\n    identifier = \"io.openpype.creators.max.camera\"\n    label = \"Camera\"\n    product_type = \"camera\"\n    product_base_type = \"camera\"\n    icon = \"gear\"\n\n    settings_category = \"max\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_maxScene.html","title":"create_maxScene","text":"<p>Creator plugin for creating raw max scene.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_maxScene.html#client.ayon_max.plugins.create.create_maxScene.CreateMaxScene","title":"<code>CreateMaxScene</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Creator plugin for 3ds max scenes.</p> Source code in <code>client/ayon_max/plugins/create/create_maxScene.py</code> <pre><code>class CreateMaxScene(plugin.MaxCreator):\n    \"\"\"Creator plugin for 3ds max scenes.\"\"\"\n    identifier = \"io.openpype.creators.max.maxScene\"\n    label = \"Max Scene\"\n    product_type = \"maxScene\"\n    product_base_type = \"maxScene\"\n    icon = \"gear\"\n\n    settings_category = \"max\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_model.html","title":"create_model","text":"<p>Creator plugin for model.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_model.html#client.ayon_max.plugins.create.create_model.CreateModel","title":"<code>CreateModel</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Creator plugin for Model.</p> Source code in <code>client/ayon_max/plugins/create/create_model.py</code> <pre><code>class CreateModel(plugin.MaxCreator):\n    \"\"\"Creator plugin for Model.\"\"\"\n    identifier = \"io.openpype.creators.max.model\"\n    label = \"Model\"\n    product_type = \"model\"\n    product_base_type = \"model\"\n    icon = \"gear\"\n\n    settings_category = \"max\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_pointcache.html","title":"create_pointcache","text":"<p>Creator plugin for creating pointcache alembics.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_pointcache.html#client.ayon_max.plugins.create.create_pointcache.CreatePointCache","title":"<code>CreatePointCache</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Creator plugin for Point caches.</p> Source code in <code>client/ayon_max/plugins/create/create_pointcache.py</code> <pre><code>class CreatePointCache(plugin.MaxCreator):\n    \"\"\"Creator plugin for Point caches.\"\"\"\n    identifier = \"io.openpype.creators.max.pointcache\"\n    label = \"Point Cache\"\n    product_type = \"pointcache\"\n    product_base_type = \"pointcache\"\n    icon = \"gear\"\n\n    settings_category = \"max\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_pointcloud.html","title":"create_pointcloud","text":"<p>Creator plugin for creating point cloud.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_pointcloud.html#client.ayon_max.plugins.create.create_pointcloud.CreatePointCloud","title":"<code>CreatePointCloud</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Creator plugin for Point Clouds.</p> Source code in <code>client/ayon_max/plugins/create/create_pointcloud.py</code> <pre><code>class CreatePointCloud(plugin.MaxCreator):\n    \"\"\"Creator plugin for Point Clouds.\"\"\"\n    identifier = \"io.openpype.creators.max.pointcloud\"\n    label = \"Point Cloud\"\n    product_type = \"pointcloud\"\n    product_base_type = \"pointcloud\"\n    icon = \"gear\"\n\n    settings_category = \"max\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_redshift_proxy.html","title":"create_redshift_proxy","text":"<p>Creator plugin for creating camera.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_render.html","title":"create_render","text":"<p>Creator plugin for creating camera.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_render.html#client.ayon_max.plugins.create.create_render.CreateRender","title":"<code>CreateRender</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Creator plugin for Renders.</p> Source code in <code>client/ayon_max/plugins/create/create_render.py</code> <pre><code>class CreateRender(plugin.MaxCreator):\n    \"\"\"Creator plugin for Renders.\"\"\"\n    identifier = \"io.openpype.creators.max.render\"\n    label = \"Render\"\n    product_type = \"maxrender\"\n    product_base_type = \"maxrender\"\n    icon = \"gear\"\n\n    settings_category = \"max\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        file = rt.maxFileName\n        filename, _ = os.path.splitext(file)\n        instance_data[\"AssetName\"] = filename\n        instance_data[\"multiCamera\"] = pre_create_data.get(\"multi_cam\")\n        num_of_renderlayer = rt.batchRenderMgr.numViews\n        if num_of_renderlayer &gt; 0:\n            rt.batchRenderMgr.DeleteView(num_of_renderlayer)\n\n        container = rt.getNodeByName(product_name)\n        product_type = instance_data[\"productType\"]\n        # check if there is existing render instance\n        if container and product_name.startswith(product_type):\n            raise CreatorError(\"Render instance already exists\")\n\n        instance = super(CreateRender, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n        container_name = instance.data.get(\"instance_node\")\n        # set output paths for rendering(mandatory for deadline)\n        RenderSettings().render_output(container_name)\n        # TODO: create multiple camera options\n        if self.selected_nodes:\n            selected_nodes_name = []\n            for sel in self.selected_nodes:\n                name = sel.name\n                selected_nodes_name.append(name)\n            output_dir = os.path.dirname(rt.rendOutputFilename)\n            RenderSettings().batch_render_layer(\n                container_name, output_dir, selected_nodes_name\n            )\n\n    def get_pre_create_attr_defs(self):\n        attrs = super(CreateRender, self).get_pre_create_attr_defs()\n        return attrs + [\n            BoolDef(\"multi_cam\",\n                    label=\"Multiple Cameras Submission\",\n                    default=False),\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_review.html","title":"create_review","text":"<p>Creator plugin for creating review in Max.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_review.html#client.ayon_max.plugins.create.create_review.CreateReview","title":"<code>CreateReview</code>","text":"<p>               Bases: <code>MaxCreator</code></p> <p>Review in 3dsMax</p> Source code in <code>client/ayon_max/plugins/create/create_review.py</code> <pre><code>class CreateReview(plugin.MaxCreator):\n    \"\"\"Review in 3dsMax\"\"\"\n\n    identifier = \"io.openpype.creators.max.review\"\n    label = \"Review\"\n    product_type = \"review\"\n    product_base_type = \"review\"\n    icon = \"video-camera\"\n\n    settings_category = \"max\"\n\n    review_width = 1920\n    review_height = 1080\n    percentSize = 100\n    keep_images = False\n    image_format = \"png\"\n    visual_style = \"Realistic\"\n    viewport_preset = \"Quality\"\n    vp_texture = True\n    anti_aliasing = \"None\"\n\n    def apply_settings(self, project_settings):\n        settings = project_settings[\"max\"][\"CreateReview\"]  # noqa\n\n        # Take some defaults from settings\n        self.review_width = settings.get(\"review_width\", self.review_width)\n        self.review_height = settings.get(\"review_height\", self.review_height)\n        self.percentSize = settings.get(\"percentSize\", self.percentSize)\n        self.keep_images = settings.get(\"keep_images\", self.keep_images)\n        self.image_format = settings.get(\"image_format\", self.image_format)\n        self.visual_style = settings.get(\"visual_style\", self.visual_style)\n        self.viewport_preset = settings.get(\n            \"viewport_preset\", self.viewport_preset)\n        self.anti_aliasing = settings.get(\n            \"anti_aliasing\", self.anti_aliasing)\n        self.vp_texture = settings.get(\"vp_texture\", self.vp_texture)\n\n    def create(self, product_name, instance_data, pre_create_data):\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\"imageFormat\",\n                    \"keepImages\",\n                    \"review_width\",\n                    \"review_height\",\n                    \"percentSize\",\n                    \"visualStyleMode\",\n                    \"viewportPreset\",\n                    \"antialiasingQuality\",\n                    \"vpTexture\"]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        super(CreateReview, self).create(\n            product_name,\n            instance_data,\n            pre_create_data)\n\n    def get_instance_attr_defs(self):\n        image_format_enum = [\"exr\", \"jpg\", \"png\", \"tga\"]\n\n        visual_style_preset_enum = [\n            \"Realistic\", \"Shaded\", \"Facets\",\n            \"ConsistentColors\", \"HiddenLine\",\n            \"Wireframe\", \"BoundingBox\", \"Ink\",\n            \"ColorInk\", \"Acrylic\", \"Tech\", \"Graphite\",\n            \"ColorPencil\", \"Pastel\", \"Clay\", \"ModelAssist\"\n        ]\n        preview_preset_enum = [\n            \"Quality\", \"Standard\", \"Performance\",\n            \"DXMode\", \"Customize\"]\n        anti_aliasing_enum = [\"None\", \"2X\", \"4X\", \"8X\"]\n\n        return [\n            NumberDef(\"review_width\",\n                      label=\"Review width\",\n                      decimals=0,\n                      minimum=0,\n                      default=self.review_width),\n            NumberDef(\"review_height\",\n                      label=\"Review height\",\n                      decimals=0,\n                      minimum=0,\n                      default=self.review_height),\n            NumberDef(\"percentSize\",\n                      label=\"Percent of Output\",\n                      default=self.percentSize,\n                      minimum=1,\n                      decimals=0),\n            BoolDef(\"keepImages\",\n                    label=\"Keep Image Sequences\",\n                    default=self.keep_images),\n            EnumDef(\"imageFormat\",\n                    image_format_enum,\n                    default=self.image_format,\n                    label=\"Image Format Options\"),\n            EnumDef(\"visualStyleMode\",\n                    visual_style_preset_enum,\n                    default=self.visual_style,\n                    label=\"Preference\"),\n            EnumDef(\"viewportPreset\",\n                    preview_preset_enum,\n                    default=self.viewport_preset,\n                    label=\"Preview Preset\"),\n            EnumDef(\"antialiasingQuality\",\n                    anti_aliasing_enum,\n                    default=self.anti_aliasing,\n                    label=\"Anti-aliasing Quality\"),\n            BoolDef(\"vpTexture\",\n                    label=\"Viewport Texture\",\n                    default=self.vp_texture)\n        ]\n\n    def get_pre_create_attr_defs(self):\n        # Use same attributes as for instance attributes\n        attrs = super().get_pre_create_attr_defs()\n        return attrs + self.get_instance_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_tyflow.html","title":"create_tyflow","text":"<p>Creator plugin for creating TyFlow.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_tyflow.html#client.ayon_max.plugins.create.create_tyflow.CreateTyFlow","title":"<code>CreateTyFlow</code>","text":"<p>               Bases: <code>MaxCacheCreator</code></p> <p>Creator plugin for TyFlow.</p> Source code in <code>client/ayon_max/plugins/create/create_tyflow.py</code> <pre><code>class CreateTyFlow(plugin.MaxCacheCreator):\n    \"\"\"Creator plugin for TyFlow.\"\"\"\n    identifier = \"io.ayon.creators.max.tyflow\"\n    label = \"TyFlow\"\n    product_type = \"tyflow\"\n    product_base_type = \"tyflow\"\n    icon = \"gear\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_max/plugins/create/create_workfile.html#client.ayon_max.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>MaxCreatorBase</code>, <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_max/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(plugin.MaxCreatorBase, AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.ayon.creators.max.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    product_base_type = \"workfile\"\n    icon = \"fa5.file\"\n\n    default_variant = \"Main\"\n\n    settings_category = \"max\"\n\n    def create(self):\n        variant = self.default_variant\n        current_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ), None)\n\n        project_entity = self.create_context.get_current_project_entity()\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n\n        project_name = project_entity[\"name\"]\n        folder_path = folder_entity[\"path\"]\n        task_name = task_entity[\"name\"]\n        host_name = self.create_context.host_name\n\n        if current_instance is None:\n            product_name = self.get_product_name(\n                project_name=project_name,\n                project_entity=project_entity,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                variant=variant,\n                host_name=host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": variant\n            }\n\n            data.update(\n                self.get_dynamic_data(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    variant,\n                    host_name,\n                    current_instance)\n            )\n            self.log.info(\"Auto-creating workfile instance...\")\n            instance_node = self.create_node(product_name)\n            data[\"instance_node\"] = instance_node.name\n            current_instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=data,\n            creator=self\n            )\n            self._add_instance_to_context(current_instance)\n            imprint(instance_node.name, current_instance.data)\n        elif (\n            current_instance[\"folderPath\"] != folder_path\n            or current_instance[\"task\"] != task_name\n        ):\n            # Update instance context if is not the same\n            product_name = self.get_product_name(\n                project_name=project_name,\n                project_entity=project_entity,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                variant=variant,\n                host_name=host_name,\n            )\n\n            current_instance[\"folderPath\"] = folder_entity[\"path\"]\n            current_instance[\"task\"] = task_name\n            current_instance[\"productName\"] = product_name\n\n    def collect_instances(self):\n        self.cache_instance_data(self.collection_shared_data)\n        cached_instances = self.collection_shared_data[\"max_cached_instances\"]\n        for instance in cached_instances.get(self.identifier, []):\n            if not rt.getNodeByName(instance):\n                continue\n            created_instance = CreatedInstance.from_existing(\n                read(rt.GetNodeByName(instance)), self\n            )\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _ in update_list:\n            instance_node = created_inst.get(\"instance_node\")\n            imprint(\n                instance_node,\n                created_inst.data_to_store()\n            )\n\n    def create_node(self, product_name):\n        if rt.getNodeByName(product_name):\n            node = rt.getNodeByName(product_name)\n            return node\n        node = rt.Container(name=product_name)\n        node.isHidden = True\n        return node\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_camera_fbx.html","title":"load_camera_fbx","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_camera_fbx.html#client.ayon_max.plugins.load.load_camera_fbx.FbxLoader","title":"<code>FbxLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Fbx Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_camera_fbx.py</code> <pre><code>class FbxLoader(load.LoaderPlugin):\n    \"\"\"Fbx Loader.\"\"\"\n\n    product_types = {\"camera\"}\n    representations = {\"fbx\"}\n    order = -9\n    icon = \"code-fork\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pymxs import runtime as rt\n        filepath = self.filepath_from_context(context)\n        filepath = os.path.normpath(filepath)\n        rt.FBXImporterSetParam(\"Animation\", True)\n        rt.FBXImporterSetParam(\"Camera\", True)\n        rt.FBXImporterSetParam(\"AxisConversionMethod\", True)\n        rt.FBXImporterSetParam(\"Mode\", rt.Name(\"create\"))\n        rt.FBXImporterSetParam(\"Preserveinstances\", True)\n        rt.ImportFile(\n            filepath,\n            rt.name(\"noPrompt\"),\n            using=rt.FBXIMP)\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        selections = rt.GetCurrentSelection()\n\n        for selection in selections:\n            selection.name = f\"{namespace}:{selection.name}\"\n\n        return containerise(\n            name, selections, context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node_name = container[\"instance_node\"]\n        node = rt.getNodeByName(node_name)\n        namespace, _ = get_namespace(node_name)\n\n        node_list = get_previous_loaded_object(node)\n        rt.Select(node_list)\n        prev_fbx_objects = rt.GetCurrentSelection()\n        transform_data = object_transform_set(prev_fbx_objects)\n        for prev_fbx_obj in prev_fbx_objects:\n            if rt.isValidNode(prev_fbx_obj):\n                rt.Delete(prev_fbx_obj)\n\n        rt.FBXImporterSetParam(\"Animation\", True)\n        rt.FBXImporterSetParam(\"Camera\", True)\n        rt.FBXImporterSetParam(\"Mode\", rt.Name(\"merge\"))\n        rt.FBXImporterSetParam(\"AxisConversionMethod\", True)\n        rt.FBXImporterSetParam(\"Preserveinstances\", True)\n        rt.ImportFile(\n            path, rt.name(\"noPrompt\"), using=rt.FBXIMP)\n        current_fbx_objects = rt.GetCurrentSelection()\n        fbx_objects = []\n        for fbx_object in current_fbx_objects:\n            fbx_object.name = f\"{namespace}:{fbx_object.name}\"\n            fbx_objects.append(fbx_object)\n            fbx_transform = f\"{fbx_object.name}.transform\"\n            if fbx_transform in transform_data.keys():\n                fbx_object.pos = transform_data[fbx_transform] or 0\n                fbx_object.scale = transform_data[\n                    f\"{fbx_object.name}.scale\"] or 0\n\n        update_custom_attribute_data(node, fbx_objects)\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_image.html","title":"load_image","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_image.html#client.ayon_max.plugins.load.load_image.ImageLoader","title":"<code>ImageLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Loading image files to Slate Material Editor.</p> Source code in <code>client/ayon_max/plugins/load/load_image.py</code> <pre><code>class ImageLoader(load.LoaderPlugin):\n    \"\"\"Loading image files to Slate Material Editor.\"\"\"\n\n    product_types = {\"render\", \"image\", \"plate\", \"texture\"}\n    representations = {\"*\"}\n    label = \"Load Image\"\n    icon = \"image\"\n    color = \"orange\"\n    order = 2\n\n    bitmap_default = \"osl\"\n    bitmap_enum_dict = {\n        \"vray_bitmap\": \"Vray Bitmap\",\n        \"osl\": \"OSL Bitmap Lookup\",\n    }\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                \"bitmap_type\",\n                items=cls.bitmap_enum_dict,\n                default=cls.bitmap_default,\n                label=\"Bitmap Type\"\n            )\n        ]\n\n    def _create_texture_node(self, bitmap_type, file_path, context):\n        \"\"\"Create texture node based on bitmap type.\n\n        Args:\n            bitmap_type (str): Type of bitmap (\"vray_bitmap\" or \"osl\")\n            file_path (str): Path to the image file\n            context (dict): Load context\n\n        Returns:\n            Node: The created texture node\n        \"\"\"\n        if bitmap_type == \"vray_bitmap\":\n            if not find_plugins(\"vray\"):\n                raise LoadError(\"V-Ray plugin is not available in 3ds Max.\")\n            texture_node = rt.VRayBitmap()\n            texture_node.fileName = file_path\n        elif bitmap_type == \"osl\":\n            texture_node = rt.OSLMap()\n            texture_node.OSLPath = os.path.join(\n                rt.getdir(rt.Name(\"maxroot\")), \"OSL/OSLBitmap2.osl\"\n            )\n            texture_node.Filename = file_path\n            self._set_udim(context, texture_node)\n            texture_node.Filename_ColorSpace = self._get_colorspace(context)\n        else:\n            raise LoadError(f\"Unsupported bitmap type: {bitmap_type}\")\n\n        return texture_node\n\n    def load(self, context, name=None, namespace=None, options=None):\n        file_path = os.path.normpath(self.filepath_from_context(context))\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        bitmap_type = options.get(\"bitmap_type\", self.bitmap_default)\n        texture_node = self._create_texture_node(bitmap_type, file_path, context)\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(ensure_sme_editor_active())\n            active_view_number = rt.sme.ActiveView\n            current_sme_view = get_target_sme_view(active_view_number)\n            view_node = current_sme_view.createNode(texture_node, rt.Point2(0, 0))\n            view_node.name = f\"{namespace}:{name}\"\n\n        return containerise_texture(\n            name,\n            context,\n            view_node.name,\n            active_view_number,\n            namespace,\n            loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        file_path = os.path.normpath(self.filepath_from_context(context))\n        repre_entity = context[\"representation\"]\n        view_node_name = container[\"view_node\"]\n        sme_view_number = int(container[\"sme_view_number\"])\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(ensure_sme_editor_active())\n            current_sme_view = get_target_sme_view(sme_view_number)\n            view_node = get_view_node_from_sme_view(\n                current_sme_view, view_node_name\n            )\n            texture_node = view_node.reference\n\n            if find_plugins(\"vray\") and (\n                rt.classOf(texture_node) == getattr(rt, \"VRayBitmap\", None)\n            ):\n                texture_node.fileName = file_path\n            elif rt.classOf(texture_node) == rt.OSLMap:\n                texture_node.Filename = file_path\n                self._set_udim(context, texture_node)\n                texture_node.Filename_ColorSpace = self._get_colorspace(context)\n            else:\n                raise LoadError(\n                    f\"Unsupported texture node type: {rt.classOf(texture_node)}\"\n                )\n\n        imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        view_node_name = container[\"view_node\"]\n        sme_view_number = int(container[\"sme_view_number\"])\n        with contextlib.ExitStack() as stack:\n            stack.enter_context(ensure_sme_editor_active())\n            current_sme_view = get_target_sme_view(sme_view_number)\n            view_node = get_view_node_from_sme_view(\n                current_sme_view, view_node_name\n            )\n            stack.enter_context(\n                maintained_sme_view_nodes_selection(\n                    current_sme_view, view_node.reference\n                )\n            )\n            current_sme_view.DeleteSelection()\n\n        container_node = rt.GetNodeByName(container[\"instance_node\"])\n        rt.Delete(container_node)\n\n    def _set_udim(self, context, texture_node):\n        \"\"\"Return UDIM list for the file to load.\n\n        Retrieves the UDIM list from the publish data if available.\n        This function is not fully working due to the limitations of\n        OSLBitmap2 requires users to choose the specific UDIM tile manually\n        by dialog.  For now, it helps the users to identify the published\n        path of the UDIM textures. Users need to reload the texture again to\n        set up the UDIM token.\n\n        Returns:\n            list or None: The UDIM list or None if not available.\n\n        \"\"\"\n        repre_context = context[\"representation\"][\"context\"]\n        udims = repre_context.get(\"udim\", [])\n        texture_node.UDIM = bool(udims)\n        texture_node.LoadUDIM = self.filepath_from_context(context)\n\n    def _get_colorspace(self, context):\n        \"\"\"Return colorspace of the file to load.\n\n        Retrieves the explicit colorspace from the publish. If no colorspace\n        data is stored with published content then project imageio settings\n        are used to make an assumption of the colorspace based on the file\n        rules. If no file rules match then None is returned.\n\n        Returns:\n            str or None: The colorspace of the file or None if not detected.\n\n        \"\"\"\n        representation = context[\"representation\"]\n        colorspace_data = representation.get(\"data\", {}).get(\"colorspaceData\")\n        if colorspace_data:\n            return colorspace_data[\"colorspace\"]\n\n        # Assume colorspace from filepath based on project settings\n        project_name = context[\"project\"][\"name\"]\n        host_name = get_current_host_name()\n        project_settings = get_project_settings(project_name)\n\n        config_data = get_current_context_imageio_config_preset(\n            project_settings=project_settings\n        )\n\n        # Ignore if host imageio is not enabled\n        if not config_data:\n            return None\n\n        file_rules = get_imageio_file_rules(\n            project_name, host_name,\n            project_settings=project_settings\n        )\n\n        path = self.filepath_from_context(context)\n        return get_imageio_file_rules_colorspace_from_filepath(\n            path,\n            host_name,\n            project_name,\n            config_data=config_data,\n            file_rules=file_rules,\n            project_settings=project_settings\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_max_scene.html","title":"load_max_scene","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_max_scene.html#client.ayon_max.plugins.load.load_max_scene.MaterialDupOptionsWindow","title":"<code>MaterialDupOptionsWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>The pop-up dialog allows users to choose material duplicate options for importing Max objects when updating or switching assets.</p> Source code in <code>client/ayon_max/plugins/load/load_max_scene.py</code> <pre><code>class MaterialDupOptionsWindow(QtWidgets.QDialog):\n    \"\"\"The pop-up dialog allows users to choose material\n    duplicate options for importing Max objects when updating\n    or switching assets.\n    \"\"\"\n    def __init__(self, material_options):\n        super(MaterialDupOptionsWindow, self).__init__()\n        self.setWindowFlags(self.windowFlags() | QtCore.Qt.FramelessWindowHint)\n\n        self.material_option = None\n        self.material_options = material_options\n\n        self.widgets = {\n            \"label\": QtWidgets.QLabel(\n                \"Select material duplicate options before loading the max scene.\"),\n            \"material_options_list\": QtWidgets.QListWidget(),\n            \"warning\": QtWidgets.QLabel(\"No material options selected!\"),\n            \"buttons\": QtWidgets.QWidget(),\n            \"okButton\": QtWidgets.QPushButton(\"Ok\"),\n            \"cancelButton\": QtWidgets.QPushButton(\"Cancel\")\n        }\n        for key, value in material_options.items():\n            item = QtWidgets.QListWidgetItem(value)\n            self.widgets[\"material_options_list\"].addItem(item)\n            item.setData(QtCore.Qt.UserRole, key)\n        # Build buttons.\n        layout = QtWidgets.QHBoxLayout(self.widgets[\"buttons\"])\n        layout.addWidget(self.widgets[\"okButton\"])\n        layout.addWidget(self.widgets[\"cancelButton\"])\n        # Build layout.\n        layout = QtWidgets.QVBoxLayout(self)\n        layout.addWidget(self.widgets[\"label\"])\n        layout.addWidget(self.widgets[\"material_options_list\"])\n        layout.addWidget(self.widgets[\"buttons\"])\n\n        self.widgets[\"okButton\"].pressed.connect(self.on_ok_pressed)\n        self.widgets[\"cancelButton\"].pressed.connect(self.on_cancel_pressed)\n        self.widgets[\"material_options_list\"].itemPressed.connect(\n            self.on_material_options_pressed)\n\n    def on_material_options_pressed(self, item):\n        self.material_option = item.data(QtCore.Qt.UserRole)\n\n    def on_ok_pressed(self):\n        if self.material_option is None:\n            self.widgets[\"warning\"].setVisible(True)\n            return\n        self.close()\n\n    def on_cancel_pressed(self):\n        self.material_option = \"promptMtlDups\"\n        self.close()\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_max_scene.html#client.ayon_max.plugins.load.load_max_scene.MaxSceneLoader","title":"<code>MaxSceneLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Max Scene Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_max_scene.py</code> <pre><code>class MaxSceneLoader(load.LoaderPlugin):\n    \"\"\"Max Scene Loader.\"\"\"\n\n    product_types = {\n        \"camera\",\n        \"maxScene\",\n        \"model\",\n    }\n\n    representations = {\"max\"}\n    order = -8\n    icon = \"code-fork\"\n    color = \"green\"\n    mtl_dup_default = \"promptMtlDups\"\n    mtl_dup_enum_dict = {\n        \"promptMtlDups\": \"Prompt on Duplicate Materials\",\n        \"useMergedMtlDups\": \"Use Incoming Material\",\n        \"useSceneMtlDups\": \"Use Scene Material\",\n        \"renameMtlDups\": \"Merge and Rename Incoming Material\"\n        }\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\"mtldup\",\n                    items=cls.mtl_dup_enum_dict,\n                    default=cls.mtl_dup_default,\n                    label=\"Material Duplicate Options\")\n        ]\n\n    def load(self, context, name=None, namespace=None, options=None):\n        from pymxs import runtime as rt\n        mat_dup_options = options.get(\"mtldup\", self.mtl_dup_default)\n        path = self.filepath_from_context(context)\n        path = os.path.normpath(path)\n        # import the max scene by using \"merge file\"\n        path = path.replace('\\\\', '/')\n        rt.MergeMaxFile(path, rt.Name(mat_dup_options),\n                        quiet=True, includeFullGroup=True)\n        max_objects = rt.getLastMergedNodes()\n        max_object_names = [obj.name for obj in max_objects]\n        # implement the OP/AYON custom attributes before load\n        max_container = []\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        for max_obj, obj_name in zip(max_objects, max_object_names):\n            max_obj.name = f\"{namespace}:{obj_name}\"\n            max_container.append(max_obj)\n        return containerise(\n            name, max_container, context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node_name = container[\"instance_node\"]\n        node = rt.getNodeByName(node_name)\n        namespace, _ = get_namespace(node_name)\n        # delete the old container with attribute\n        # delete old duplicate\n        # use the modifier OP data to delete the data\n        node_list = get_previous_loaded_object(node)\n        rt.select(node_list)\n        prev_max_objects = rt.GetCurrentSelection()\n        transform_data = object_transform_set(prev_max_objects)\n        for prev_max_obj in prev_max_objects:\n            if rt.isValidNode(prev_max_obj):  # noqa\n                rt.Delete(prev_max_obj)\n        material_option = self.mtl_dup_default\n        if not is_headless():\n            window = MaterialDupOptionsWindow(self.mtl_dup_enum_dict)\n            window.exec_()\n            material_option = window.material_option\n        rt.MergeMaxFile(path, rt.Name(material_option), quiet=True)\n\n        current_max_objects = rt.getLastMergedNodes()\n\n        current_max_object_names = [obj.name for obj\n                                    in current_max_objects]\n\n        max_objects = []\n        for max_obj, obj_name in zip(current_max_objects,\n                                     current_max_object_names):\n            max_obj.name = f\"{namespace}:{obj_name}\"\n            max_objects.append(max_obj)\n            max_translate = f\"{max_obj.name}.translate\"\n            if max_translate in transform_data:\n                translate_data = transform_data[max_translate] or (\n                    rt.Point3(0, 0, 0)\n                )\n                rotation_data = transform_data[f\"{max_obj.name}.rotation\"] or (\n                    rt.Quat(0, 0, 0, 1)\n                )\n                max_obj.pos = translate_data\n                max_obj.scale = transform_data[f\"{max_obj.name}.scale\"] or (\n                    rt.Point3(1, 1, 1)\n                )\n                max_obj.rotation = rotation_data\n\n        update_custom_attribute_data(node, max_objects)\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_model.html","title":"load_model","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_model.html#client.ayon_max.plugins.load.load_model.ModelAbcLoader","title":"<code>ModelAbcLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Loading model with the Alembic loader.</p> Source code in <code>client/ayon_max/plugins/load/load_model.py</code> <pre><code>class ModelAbcLoader(load.LoaderPlugin):\n    \"\"\"Loading model with the Alembic loader.\"\"\"\n\n    product_types = {\"model\"}\n    label = \"Load Model with Alembic\"\n    representations = {\"abc\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pymxs import runtime as rt\n\n        file_path = os.path.normpath(self.filepath_from_context(context))\n\n        abc_before = {\n            c\n            for c in rt.rootNode.Children\n            if rt.classOf(c) == rt.AlembicContainer\n        }\n\n        rt.AlembicImport.ImportToRoot = False\n        rt.AlembicImport.CustomAttributes = True\n        rt.AlembicImport.UVs = True\n        rt.AlembicImport.VertexColors = True\n        rt.importFile(file_path, rt.name(\"noPrompt\"), using=rt.AlembicImport)\n\n        abc_after = {\n            c\n            for c in rt.rootNode.Children\n            if rt.classOf(c) == rt.AlembicContainer\n        }\n\n        # This should yield new AlembicContainer node\n        abc_containers = abc_after.difference(abc_before)\n\n        if len(abc_containers) != 1:\n            self.log.error(\"Something failed when loading.\")\n\n        abc_container = abc_containers.pop()\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        abc_objects = []\n        for abc_object in abc_container.Children:\n            abc_object.name = f\"{namespace}:{abc_object.name}\"\n            abc_objects.append(abc_object)\n        # rename the abc container with namespace\n        abc_container_name = f\"{namespace}:{name}\"\n        abc_container.name = abc_container_name\n        abc_objects.append(abc_container)\n\n        return containerise(\n            name, abc_objects, context,\n            namespace, loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        node_list = [n for n in get_previous_loaded_object(node)\n                     if rt.ClassOf(n) == rt.AlembicContainer]\n        with maintained_selection():\n            rt.Select(node_list)\n\n            for alembic in rt.Selection:\n                abc = rt.GetNodeByName(alembic.name)\n                rt.Select(abc.Children)\n                for abc_con in abc.Children:\n                    abc_con.source = path\n                    rt.Select(abc_con.Children)\n                    for abc_obj in abc_con.Children:\n                        abc_obj.source = path\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n\n\n    @staticmethod\n    def get_container_children(parent, type_name):\n        from pymxs import runtime as rt\n\n        def list_children(node):\n            children = []\n            for c in node.Children:\n                children.append(c)\n                children += list_children(c)\n            return children\n\n        filtered = []\n        for child in list_children(parent):\n            class_type = str(rt.ClassOf(child.baseObject))\n            if class_type == type_name:\n                filtered.append(child)\n\n        return filtered\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_model_fbx.html","title":"load_model_fbx","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_model_fbx.html#client.ayon_max.plugins.load.load_model_fbx.FbxModelLoader","title":"<code>FbxModelLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Fbx Model Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_model_fbx.py</code> <pre><code>class FbxModelLoader(load.LoaderPlugin):\n    \"\"\"Fbx Model Loader.\"\"\"\n\n    product_types = {\"model\"}\n    representations = {\"fbx\"}\n    order = -9\n    icon = \"code-fork\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pymxs import runtime as rt\n        filepath = self.filepath_from_context(context)\n        filepath = os.path.normpath(filepath)\n        rt.FBXImporterSetParam(\"Animation\", False)\n        rt.FBXImporterSetParam(\"Cameras\", False)\n        rt.FBXImporterSetParam(\"Mode\", rt.Name(\"create\"))\n        rt.FBXImporterSetParam(\"Preserveinstances\", True)\n        rt.importFile(\n            filepath, rt.name(\"noPrompt\"), using=rt.FBXIMP)\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        selections = rt.GetCurrentSelection()\n\n        for selection in selections:\n            selection.name = f\"{namespace}:{selection.name}\"\n\n        return containerise(\n            name, selections, context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node_name = container[\"instance_node\"]\n        node = rt.getNodeByName(node_name)\n        if not node:\n            rt.Container(name=node_name)\n        namespace, _ = get_namespace(node_name)\n\n        node_list = get_previous_loaded_object(node)\n        rt.Select(node_list)\n        prev_fbx_objects = rt.GetCurrentSelection()\n        transform_data = object_transform_set(prev_fbx_objects)\n        for prev_fbx_obj in prev_fbx_objects:\n            if rt.isValidNode(prev_fbx_obj):\n                rt.Delete(prev_fbx_obj)\n\n        rt.FBXImporterSetParam(\"Animation\", False)\n        rt.FBXImporterSetParam(\"Cameras\", False)\n        rt.FBXImporterSetParam(\"Mode\", rt.Name(\"create\"))\n        rt.FBXImporterSetParam(\"Preserveinstances\", True)\n        rt.importFile(path, rt.name(\"noPrompt\"), using=rt.FBXIMP)\n        current_fbx_objects = rt.GetCurrentSelection()\n        fbx_objects = []\n        for fbx_object in current_fbx_objects:\n            fbx_object.name = f\"{namespace}:{fbx_object.name}\"\n            fbx_objects.append(fbx_object)\n            fbx_transform = f\"{fbx_object}.transform\"\n            if fbx_transform in transform_data.keys():\n                fbx_object.pos = transform_data[fbx_transform] or 0\n                fbx_object.scale = transform_data[\n                    f\"{fbx_object}.scale\"] or 0\n\n        with maintained_selection():\n            rt.Select(node)\n        update_custom_attribute_data(node, fbx_objects)\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_model_obj.html","title":"load_model_obj","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_model_obj.html#client.ayon_max.plugins.load.load_model_obj.ObjLoader","title":"<code>ObjLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Obj Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_model_obj.py</code> <pre><code>class ObjLoader(load.LoaderPlugin):\n    \"\"\"Obj Loader.\"\"\"\n\n    product_types = {\"model\"}\n    representations = {\"obj\"}\n    order = -9\n    icon = \"code-fork\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pymxs import runtime as rt\n\n        filepath = os.path.normpath(self.filepath_from_context(context))\n        self.log.debug(\"Executing command to import..\")\n\n        rt.Execute(f'importFile @\"{filepath}\" #noPrompt using:ObjImp')\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        # create \"missing\" container for obj import\n        selections = rt.GetCurrentSelection()\n        # get current selection\n        for selection in selections:\n            selection.name = f\"{namespace}:{selection.name}\"\n        return containerise(\n            name, selections, context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node_name = container[\"instance_node\"]\n        node = rt.getNodeByName(node_name)\n        namespace, _ = get_namespace(node_name)\n        node_list = get_previous_loaded_object(node)\n        rt.Select(node_list)\n        previous_objects = rt.GetCurrentSelection()\n        transform_data = object_transform_set(previous_objects)\n        for prev_obj in previous_objects:\n            if rt.isValidNode(prev_obj):\n                rt.Delete(prev_obj)\n\n        rt.Execute(f'importFile @\"{path}\" #noPrompt using:ObjImp')\n        # get current selection\n        selections = rt.GetCurrentSelection()\n        for selection in selections:\n            selection.name = f\"{namespace}:{selection.name}\"\n            selection_transform = f\"{selection}.transform\"\n            if selection_transform in transform_data.keys():\n                selection.pos = transform_data[selection_transform] or 0\n                selection.scale = transform_data[\n                    f\"{selection}.scale\"] or 0\n        update_custom_attribute_data(node, selections)\n        with maintained_selection():\n            rt.Select(node)\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_model_usd.html","title":"load_model_usd","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_model_usd.html#client.ayon_max.plugins.load.load_model_usd.ModelUSDLoader","title":"<code>ModelUSDLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Loading model with the USD loader.</p> Source code in <code>client/ayon_max/plugins/load/load_model_usd.py</code> <pre><code>class ModelUSDLoader(load.LoaderPlugin):\n    \"\"\"Loading model with the USD loader.\"\"\"\n\n    product_types = {\"model\"}\n    label = \"Load Model(USD)\"\n    representations = {\"usda\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        # asset_filepath\n        plugin_info = get_plugins()\n        if \"usdimport.dli\" not in plugin_info:\n            raise LoadError(\"No USDImporter loaded/installed in Max..\")\n        filepath = os.path.normpath(self.filepath_from_context(context))\n        import_options = rt.USDImporter.CreateOptions()\n        base_filename = os.path.basename(filepath)\n        _, ext = os.path.splitext(base_filename)\n        log_filepath = filepath.replace(ext, \"txt\")\n\n        rt.LogPath = log_filepath\n        rt.LogLevel = rt.Name(\"info\")\n        rt.USDImporter.importFile(filepath,\n                                  importOptions=import_options)\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        asset = rt.GetNodeByName(name)\n        usd_objects = []\n\n        for usd_asset in asset.Children:\n            usd_asset.name = f\"{namespace}:{usd_asset.name}\"\n            usd_objects.append(usd_asset)\n\n        asset_name = f\"{namespace}:{name}\"\n        asset.name = asset_name\n        # need to get the correct container after renamed\n        asset = rt.GetNodeByName(asset_name)\n        usd_objects.append(asset)\n\n        return containerise(\n            name, usd_objects, context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node_name = container[\"instance_node\"]\n        node = rt.GetNodeByName(node_name)\n        namespace, name = get_namespace(node_name)\n        node_list = get_previous_loaded_object(node)\n        rt.Select(node_list)\n        prev_objects = [sel for sel in rt.GetCurrentSelection()\n                        if sel != rt.Container\n                        and sel.name != node_name]\n        transform_data = object_transform_set(prev_objects)\n        for n in prev_objects:\n            rt.Delete(n)\n\n        import_options = rt.USDImporter.CreateOptions()\n        base_filename = os.path.basename(path)\n        _, ext = os.path.splitext(base_filename)\n        log_filepath = path.replace(ext, \"txt\")\n\n        rt.LogPath = log_filepath\n        rt.LogLevel = rt.Name(\"info\")\n        rt.USDImporter.importFile(\n            path, importOptions=import_options)\n\n        asset = rt.GetNodeByName(name)\n        usd_objects = []\n        for children in asset.Children:\n            children.name = f\"{namespace}:{children.name}\"\n            usd_objects.append(children)\n            children_transform = f\"{children}.transform\"\n            if children_transform in transform_data.keys():\n                children.pos = transform_data[children_transform] or 0\n                children.scale = transform_data[\n                    f\"{children}.scale\"] or 0\n\n        asset.name = f\"{namespace}:{asset.name}\"\n        usd_objects.append(asset)\n        update_custom_attribute_data(node, usd_objects)\n        with maintained_selection():\n            rt.Select(node)\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcache.html","title":"load_pointcache","text":"<p>Simple alembic loader for 3dsmax.</p> <p>Because of limited api, alembics can be only loaded, but not easily updated.</p>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcache.html#client.ayon_max.plugins.load.load_pointcache.AbcLoader","title":"<code>AbcLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Alembic loader.</p> Source code in <code>client/ayon_max/plugins/load/load_pointcache.py</code> <pre><code>class AbcLoader(load.LoaderPlugin):\n    \"\"\"Alembic loader.\"\"\"\n\n    product_types = {\"camera\", \"animation\", \"pointcache\"}\n    label = \"Load Alembic\"\n    representations = {\"abc\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pymxs import runtime as rt\n\n        file_path = self.filepath_from_context(context)\n        file_path = os.path.normpath(file_path)\n\n        abc_before = {\n            c\n            for c in rt.rootNode.Children\n            if rt.classOf(c) == rt.AlembicContainer\n        }\n\n        rt.AlembicImport.ImportToRoot = False\n        # TODO: it will be removed after the improvement\n        # on the post-system setup\n        reset_frame_range()\n        rt.importFile(file_path, rt.name(\"noPrompt\"), using=rt.AlembicImport)\n\n        abc_after = {\n            c\n            for c in rt.rootNode.Children\n            if rt.classOf(c) == rt.AlembicContainer\n        }\n\n        # This should yield new AlembicContainer node\n        abc_containers = abc_after.difference(abc_before)\n\n        if len(abc_containers) != 1:\n            self.log.error(\"Something failed when loading.\")\n\n        abc_container = abc_containers.pop()\n        selections = rt.GetCurrentSelection()\n        for abc in selections:\n            for cam_shape in abc.Children:\n                cam_shape.playbackType = 0\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        abc_objects = []\n        for abc_object in abc_container.Children:\n            abc_object.name = f\"{namespace}:{abc_object.name}\"\n            abc_objects.append(abc_object)\n        # rename the abc container with namespace\n        abc_container_name = f\"{namespace}:{name}\"\n        abc_container.name = abc_container_name\n        abc_objects.append(abc_container)\n\n        return containerise(\n            name, abc_objects, context,\n            namespace, loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        abc_container = [n for n in get_previous_loaded_object(node)\n                         if rt.ClassOf(n) == rt.AlembicContainer]\n        with maintained_selection():\n            rt.Select(abc_container)\n\n            for alembic in rt.Selection:\n                abc = rt.GetNodeByName(alembic.name)\n                rt.Select(abc.Children)\n                for abc_con in abc.Children:\n                    abc_con.source = path\n                    rt.Select(abc_con.Children)\n                    for abc_obj in abc_con.Children:\n                        abc_obj.source = path\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n\n\n    @staticmethod\n    def get_container_children(parent, type_name):\n        from pymxs import runtime as rt\n\n        def list_children(node):\n            children = []\n            for c in node.Children:\n                children.append(c)\n                children += list_children(c)\n            return children\n\n        filtered = []\n        for child in list_children(parent):\n            class_type = str(rt.classOf(child.baseObject))\n            if class_type == type_name:\n                filtered.append(child)\n\n        return filtered\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcache_ornatrix.html","title":"load_pointcache_ornatrix","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcache_ornatrix.html#client.ayon_max.plugins.load.load_pointcache_ornatrix.OxAbcLoader","title":"<code>OxAbcLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Ornatrix Alembic loader.</p> Source code in <code>client/ayon_max/plugins/load/load_pointcache_ornatrix.py</code> <pre><code>class OxAbcLoader(load.LoaderPlugin):\n    \"\"\"Ornatrix Alembic loader.\"\"\"\n\n    product_types = {\"camera\", \"animation\", \"pointcache\"}\n    label = \"Load Alembic with Ornatrix\"\n    representations = {\"abc\"}\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n    postfix = \"param\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        plugin_list = get_plugins()\n        if \"ephere.plugins.autodesk.max.ornatrix.dlo\" not in plugin_list:\n            raise LoadError(\"Ornatrix plugin not \"\n                            \"found/installed in Max yet..\")\n\n        file_path = os.path.normpath(self.filepath_from_context(context))\n        rt.AlembicImport.ImportToRoot = True\n        rt.AlembicImport.CustomAttributes = True\n        rt.importFile(\n            file_path, rt.name(\"noPrompt\"),\n            using=rt.Ornatrix_Alembic_Importer)\n\n        scene_object = []\n        for obj in rt.rootNode.Children:\n            obj_type = rt.ClassOf(obj)\n            if str(obj_type).startswith(\"Ox_\"):\n                scene_object.append(obj)\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        abc_container = []\n        for abc in scene_object:\n            abc.name = f\"{namespace}:{abc.name}\"\n            abc_container.append(abc)\n\n        return containerise(\n            name, abc_container, context,\n            namespace, loader=self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node_name = container[\"instance_node\"]\n        namespace, name = get_namespace(node_name)\n        node = rt.getNodeByName(node_name)\n        node_list = get_previous_loaded_object(node)\n        rt.Select(node_list)\n        selections = rt.getCurrentSelection()\n        transform_data = object_transform_set(selections)\n        for prev_obj in selections:\n            if rt.isValidNode(prev_obj):\n                rt.Delete(prev_obj)\n\n        rt.AlembicImport.ImportToRoot = False\n        rt.AlembicImport.CustomAttributes = True\n        rt.importFile(\n            path, rt.name(\"noPrompt\"),\n            using=rt.Ornatrix_Alembic_Importer)\n\n        scene_object = []\n        for obj in rt.rootNode.Children:\n            obj_type = rt.ClassOf(obj)\n            if str(obj_type).startswith(\"Ox_\"):\n                scene_object.append(obj)\n        ox_abc_objects = []\n        for abc in scene_object:\n            abc.Parent = container\n            abc.name = f\"{namespace}:{abc.name}\"\n            ox_abc_objects.append(abc)\n            ox_transform = f\"{abc}.transform\"\n            if ox_transform in transform_data.keys():\n                abc.pos = transform_data[ox_transform] or 0\n                abc.scale = transform_data[f\"{abc}.scale\"] or 0\n        update_custom_attribute_data(node, ox_abc_objects)\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcloud.html","title":"load_pointcloud","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcloud.html#client.ayon_max.plugins.load.load_pointcloud.PointCloudLoader","title":"<code>PointCloudLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Point Cloud Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_pointcloud.py</code> <pre><code>class PointCloudLoader(load.LoaderPlugin):\n    \"\"\"Point Cloud Loader.\"\"\"\n\n    product_types = {\"*\"}\n    representations = {\"prt\"}\n    order = -8\n    icon = \"code-fork\"\n    color = \"green\"\n    postfix = \"param\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"load point cloud by tyCache\"\"\"\n        from pymxs import runtime as rt\n        filepath = os.path.normpath(self.filepath_from_context(context))\n        obj = rt.tyCache()\n        obj.filename = filepath\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        obj.name = f\"{namespace}:{obj.name}\"\n\n        return containerise(\n            name, [obj], context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        \"\"\"update the container\"\"\"\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        node_list = get_previous_loaded_object(node)\n        update_custom_attribute_data(\n            node, node_list)\n        with maintained_selection():\n            rt.Select(node_list)\n            for prt in rt.Selection:\n                prt.filename = path\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        \"\"\"remove the container\"\"\"\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcloud.html#client.ayon_max.plugins.load.load_pointcloud.PointCloudLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>load point cloud by tyCache</p> Source code in <code>client/ayon_max/plugins/load/load_pointcloud.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"load point cloud by tyCache\"\"\"\n    from pymxs import runtime as rt\n    filepath = os.path.normpath(self.filepath_from_context(context))\n    obj = rt.tyCache()\n    obj.filename = filepath\n\n    folder_name = context[\"folder\"][\"name\"]\n    namespace = unique_namespace(\n        name + \"_\",\n        prefix=f\"{folder_name}_\",\n        suffix=\"_\",\n    )\n    obj.name = f\"{namespace}:{obj.name}\"\n\n    return containerise(\n        name, [obj], context,\n        namespace, loader=self.__class__.__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcloud.html#client.ayon_max.plugins.load.load_pointcloud.PointCloudLoader.remove","title":"<code>remove(container)</code>","text":"<p>remove the container</p> Source code in <code>client/ayon_max/plugins/load/load_pointcloud.py</code> <pre><code>def remove(self, container):\n    \"\"\"remove the container\"\"\"\n    from pymxs import runtime as rt\n    node = rt.GetNodeByName(container[\"instance_node\"])\n    remove_container_data(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_pointcloud.html#client.ayon_max.plugins.load.load_pointcloud.PointCloudLoader.update","title":"<code>update(container, context)</code>","text":"<p>update the container</p> Source code in <code>client/ayon_max/plugins/load/load_pointcloud.py</code> <pre><code>def update(self, container, context):\n    \"\"\"update the container\"\"\"\n    from pymxs import runtime as rt\n\n    repre_entity = context[\"representation\"]\n    path = os.path.normpath(self.filepath_from_context(context))\n    node = rt.GetNodeByName(container[\"instance_node\"])\n    node_list = get_previous_loaded_object(node)\n    update_custom_attribute_data(\n        node, node_list)\n    with maintained_selection():\n        rt.Select(node_list)\n        for prt in rt.Selection:\n            prt.filename = path\n\n    lib.imprint(container[\"instance_node\"], {\n        \"representation\": repre_entity[\"id\"],\n        \"project_name\": context[\"project\"][\"name\"]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_redshift_proxy.html","title":"load_redshift_proxy","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_redshift_proxy.html#client.ayon_max.plugins.load.load_redshift_proxy.RedshiftProxyLoader","title":"<code>RedshiftProxyLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load rs files with Redshift Proxy</p> Source code in <code>client/ayon_max/plugins/load/load_redshift_proxy.py</code> <pre><code>class RedshiftProxyLoader(load.LoaderPlugin):\n    \"\"\"Load rs files with Redshift Proxy\"\"\"\n\n    label = \"Load Redshift Proxy\"\n    product_types = {\"redshiftproxy\"}\n    representations = {\"rs\"}\n    order = -9\n    icon = \"code-fork\"\n    color = \"white\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        plugin_info = get_plugins()\n        if \"redshift4max.dlr\" not in plugin_info:\n            raise LoadError(\"Redshift not loaded/installed in Max..\")\n        filepath = self.filepath_from_context(context)\n        rs_obj = self._get_redshift_object_type()\n        rs_obj.file = filepath\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        rs_obj.name = f\"{namespace}:{rs_obj.name}\"\n\n        return containerise(\n            name, [rs_obj], context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node = rt.getNodeByName(container[\"instance_node\"])\n        node_list = get_previous_loaded_object(node)\n        rt.Select(node_list)\n        update_custom_attribute_data(\n            node, rt.Selection)\n        for rs_obj in rt.Selection:\n            rs_obj.file = path\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n\n    def _get_redshift_object_type(self):\n        return rt.RedshiftProxy()\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_redshift_proxy.html#client.ayon_max.plugins.load.load_redshift_proxy.RedshiftVolumeLoader","title":"<code>RedshiftVolumeLoader</code>","text":"<p>               Bases: <code>RedshiftProxyLoader</code></p> <p>Load vdb files with Redshift Volume Grid</p> Source code in <code>client/ayon_max/plugins/load/load_redshift_proxy.py</code> <pre><code>class RedshiftVolumeLoader(RedshiftProxyLoader):\n    \"\"\"Load vdb files with Redshift Volume Grid\"\"\"\n\n    label = \"Load VDB\"\n    product_types = {\"vdbcache\"}\n    representations = {\"vdb\"}\n    order = -9\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def _get_redshift_object_type(self):\n        return rt.RedshiftVolumeGrid()\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_tycache.html","title":"load_tycache","text":""},{"location":"autoapi/client/ayon_max/plugins/load/load_tycache.html#client.ayon_max.plugins.load.load_tycache.TyCacheLoader","title":"<code>TyCacheLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>TyCache Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_tycache.py</code> <pre><code>class TyCacheLoader(load.LoaderPlugin):\n    \"\"\"TyCache Loader.\"\"\"\n\n    product_types = {\"tycache\"}\n    representations = {\"tyc\"}\n    order = -8\n    icon = \"code-fork\"\n    color = \"green\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        \"\"\"Load tyCache\"\"\"\n        from pymxs import runtime as rt\n        filepath = os.path.normpath(self.filepath_from_context(context))\n        obj = rt.tyCache()\n        obj.filename = filepath\n\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = unique_namespace(\n            name + \"_\",\n            prefix=f\"{folder_name}_\",\n            suffix=\"_\",\n        )\n        obj.name = f\"{namespace}:{obj.name}\"\n\n        return containerise(\n            name, [obj], context,\n            namespace, loader=self.__class__.__name__)\n\n    def update(self, container, context):\n        \"\"\"update the container\"\"\"\n        from pymxs import runtime as rt\n\n        repre_entity = context[\"representation\"]\n        path = os.path.normpath(self.filepath_from_context(context))\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        node_list = get_previous_loaded_object(node)\n        update_custom_attribute_data(node, node_list)\n        with maintained_selection():\n            for tyc in node_list:\n                tyc.filename = path\n\n        lib.imprint(container[\"instance_node\"], {\n            \"representation\": repre_entity[\"id\"],\n            \"project_name\": context[\"project\"][\"name\"]\n        })\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def remove(self, container):\n        \"\"\"remove the container\"\"\"\n        from pymxs import runtime as rt\n        node = rt.GetNodeByName(container[\"instance_node\"])\n        remove_container_data(node)\n        rt.Delete(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_tycache.html#client.ayon_max.plugins.load.load_tycache.TyCacheLoader.load","title":"<code>load(context, name=None, namespace=None, data=None)</code>","text":"<p>Load tyCache</p> Source code in <code>client/ayon_max/plugins/load/load_tycache.py</code> <pre><code>def load(self, context, name=None, namespace=None, data=None):\n    \"\"\"Load tyCache\"\"\"\n    from pymxs import runtime as rt\n    filepath = os.path.normpath(self.filepath_from_context(context))\n    obj = rt.tyCache()\n    obj.filename = filepath\n\n    folder_name = context[\"folder\"][\"name\"]\n    namespace = unique_namespace(\n        name + \"_\",\n        prefix=f\"{folder_name}_\",\n        suffix=\"_\",\n    )\n    obj.name = f\"{namespace}:{obj.name}\"\n\n    return containerise(\n        name, [obj], context,\n        namespace, loader=self.__class__.__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_tycache.html#client.ayon_max.plugins.load.load_tycache.TyCacheLoader.remove","title":"<code>remove(container)</code>","text":"<p>remove the container</p> Source code in <code>client/ayon_max/plugins/load/load_tycache.py</code> <pre><code>def remove(self, container):\n    \"\"\"remove the container\"\"\"\n    from pymxs import runtime as rt\n    node = rt.GetNodeByName(container[\"instance_node\"])\n    remove_container_data(node)\n    rt.Delete(node)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_tycache.html#client.ayon_max.plugins.load.load_tycache.TyCacheLoader.update","title":"<code>update(container, context)</code>","text":"<p>update the container</p> Source code in <code>client/ayon_max/plugins/load/load_tycache.py</code> <pre><code>def update(self, container, context):\n    \"\"\"update the container\"\"\"\n    from pymxs import runtime as rt\n\n    repre_entity = context[\"representation\"]\n    path = os.path.normpath(self.filepath_from_context(context))\n    node = rt.GetNodeByName(container[\"instance_node\"])\n    node_list = get_previous_loaded_object(node)\n    update_custom_attribute_data(node, node_list)\n    with maintained_selection():\n        for tyc in node_list:\n            tyc.filename = path\n\n    lib.imprint(container[\"instance_node\"], {\n        \"representation\": repre_entity[\"id\"],\n        \"project_name\": context[\"project\"][\"name\"]\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/load/load_tycache.html#client.ayon_max.plugins.load.load_tycache.TySplineCacheLoader","title":"<code>TySplineCacheLoader</code>","text":"<p>               Bases: <code>TyCacheLoader</code></p> <p>TyCache(Spline) Loader.</p> Source code in <code>client/ayon_max/plugins/load/load_tycache.py</code> <pre><code>class TySplineCacheLoader(TyCacheLoader):\n    \"\"\"TyCache(Spline) Loader.\"\"\"\n\n    product_types = {\"tyspline\"}\n    representations = {\"tyc\"}\n    order = -8\n    icon = \"code-fork\"\n    color = \"green\"\n\n    def load(self, context, name=None, namespace=None, data=None):\n        from pymxs import runtime as rt\n        filepath = os.path.normpath(self.filepath_from_context(context))\n        obj = rt.tyCache()\n        obj.filename = filepath\n        tySplineCache_modifier = rt.tySplineCache()\n        rt.addModifier(obj, tySplineCache_modifier)\n        namespace = unique_namespace(\n            name + \"_\",\n            suffix=\"_\",\n        )\n        obj.name = f\"{namespace}:{obj.name}\"\n\n        return containerise(\n            name, [obj], context,\n            namespace, loader=self.__class__.__name__)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/collect_current_file.html#client.ayon_max.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file.</p> Source code in <code>client/ayon_max/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Max Current File\"\n    hosts = ['max']\n\n    def process(self, context):\n        \"\"\"Inject the current working file\"\"\"\n        folder = rt.maxFilePath\n        file = rt.maxFileName\n        if not folder or not file:\n            self.log.error(\"Scene is not saved.\")\n        current_file = os.path.join(folder, file)\n\n        context.data[\"currentFile\"] = current_file\n        self.log.debug(\"Scene path: {}\".format(current_file))\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_current_file.html#client.ayon_max.plugins.publish.collect_current_file.CollectCurrentFile.process","title":"<code>process(context)</code>","text":"<p>Inject the current working file</p> Source code in <code>client/ayon_max/plugins/publish/collect_current_file.py</code> <pre><code>def process(self, context):\n    \"\"\"Inject the current working file\"\"\"\n    folder = rt.maxFilePath\n    file = rt.maxFileName\n    if not folder or not file:\n        self.log.error(\"Scene is not saved.\")\n    current_file = os.path.join(folder, file)\n\n    context.data[\"currentFile\"] = current_file\n    self.log.debug(\"Scene path: {}\".format(current_file))\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_frame_range.html","title":"collect_frame_range","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/collect_frame_range.html#client.ayon_max.plugins.publish.collect_frame_range.CollectFrameRange","title":"<code>CollectFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Frame Range.</p> Source code in <code>client/ayon_max/plugins/publish/collect_frame_range.py</code> <pre><code>class CollectFrameRange(pyblish.api.InstancePlugin):\n    \"\"\"Collect Frame Range.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.011\n    label = \"Collect Frame Range\"\n    hosts = ['max']\n    families = [\"camera\", \"maxrender\",\n                \"pointcache\", \"pointcloud\",\n                \"review\", \"tycache\",\n                \"tyspline\", \"redshiftproxy\"]\n\n    def process(self, instance):\n        if instance.data[\"productType\"] == \"maxrender\":\n            instance.data[\"frameStartHandle\"] = int(rt.rendStart)\n            instance.data[\"frameEndHandle\"] = int(rt.rendEnd)\n\n        elif instance.data[\"family\"] in {\"tycache\", \"tyspline\"}:\n            operator = instance.data[\"operator\"]\n            instance.data[\"frameStartHandle\"] = rt.getProperty(operator, \"frameStart\")\n            instance.data[\"frameEndHandle\"] = rt.getProperty(operator, \"frameEnd\")\n        else:\n            instance.data[\"frameStartHandle\"] = int(rt.animationRange.start)\n            instance.data[\"frameEndHandle\"] = int(rt.animationRange.end)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_members.html","title":"collect_members","text":"<p>Collect instance members.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_members.html#client.ayon_max.plugins.publish.collect_members.CollectMembers","title":"<code>CollectMembers</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Set Members.</p> Source code in <code>client/ayon_max/plugins/publish/collect_members.py</code> <pre><code>class CollectMembers(pyblish.api.InstancePlugin):\n    \"\"\"Collect Set Members.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.01\n    label = \"Collect Instance Members\"\n    hosts = ['max']\n\n    def process(self, instance):\n        if instance.data[\"productType\"] in {\n            \"workfile\", \"tyflow\", \"tycache\", \"tyspline\"}:\n                self.log.debug(\n                    \"Skipping Collecting Members for workfile \"\n                    \"and tyflow product type.\"\n                )\n                return\n\n        elif instance.data.get(\"instance_node\"):\n            container = rt.GetNodeByName(instance.data[\"instance_node\"])\n            instance.data[\"members\"] = [\n                member.node for member\n                in container.modifiers[0].openPypeData.all_handles\n            ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_render.html","title":"collect_render","text":"<p>Collect Render</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_render.html#client.ayon_max.plugins.publish.collect_render.CollectRender","title":"<code>CollectRender</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Render for Deadline</p> Source code in <code>client/ayon_max/plugins/publish/collect_render.py</code> <pre><code>class CollectRender(pyblish.api.InstancePlugin):\n    \"\"\"Collect Render for Deadline\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.02\n    label = \"Collect 3dsmax Render Layers\"\n    hosts = ['max']\n    families = [\"maxrender\"]\n\n    def process(self, instance):\n        context = instance.context\n        folder = rt.maxFilePath\n        file = rt.maxFileName\n        current_file = os.path.join(folder, file)\n        filename = os.path.splitext(file)[0]\n        self.log.debug(f\"Current: {filename}\")\n        filepath = current_file.replace(\"\\\\\", \"/\")\n        context.data['currentFile'] = current_file\n        renderer_class = get_current_renderer()\n        renderer = str(renderer_class).split(\":\")[0]\n        render_dir = os.path.dirname(rt.rendOutputFilename)\n\n        files_by_aov = RenderProducts().get_beauty(instance.name, renderer, filename)\n        aovs = RenderProducts().get_aovs(instance.name, filename)\n        files_by_aov.update(aovs)\n\n        camera = rt.viewport.GetCamera()\n        camera_list = get_camera_from_node(instance.data.get(\"members\"))\n        if camera_list:\n            camera = camera_list[-1]\n\n        instance.data[\"cameras\"] = [camera.name] if camera else None        # noqa\n\n        if instance.data.get(\"multiCamera\"):\n            cameras = instance.data.get(\"members\")\n            if not cameras:\n                raise KnownPublishError(\"There should be at least\"\n                                        \" one renderable camera in container\")\n            sel_cam = get_camera_from_node(cameras)\n\n            container_name = instance.data.get(\"instance_node\")\n            outputs = RenderSettings().batch_render_layer(\n                container_name, render_dir, sel_cam\n            )\n\n            instance.data[\"cameras\"] = sel_cam\n\n            files_by_aov = RenderProducts().get_multiple_beauty(\n                outputs, sel_cam)\n            aovs = RenderProducts().get_multiple_aovs(\n                outputs, sel_cam)\n            files_by_aov.update(aovs)\n\n        if \"expectedFiles\" not in instance.data:\n            instance.data[\"expectedFiles\"] = list()\n            instance.data[\"files\"] = list()\n            instance.data[\"expectedFiles\"].append(files_by_aov)\n            instance.data[\"files\"].append(files_by_aov)\n        img_format = RenderProducts().image_format()\n        # OCIO config not support in\n        # most of the 3dsmax renderers\n        # so this is currently hard coded\n        # TODO: add options for redshift/vray ocio config\n        instance.data[\"colorspaceConfig\"] = \"\"\n        instance.data[\"colorspaceDisplay\"] = \"sRGB\"\n        instance.data[\"colorspaceView\"] = \"ACES 1.0 SDR-video\"\n\n        if int(get_max_version()) &gt;= 2024:\n            colorspace_mgr = rt.ColorPipelineMgr      # noqa\n            display = next(\n                (display for display in colorspace_mgr.GetDisplayList()))\n            view_transform = next(\n                (view for view in colorspace_mgr.GetViewList(display)))\n            instance.data[\"colorspaceConfig\"] = colorspace_mgr.OCIOConfigPath\n            instance.data[\"colorspaceDisplay\"] = display\n            instance.data[\"colorspaceView\"] = view_transform\n\n        instance.data[\"renderProducts\"] = colorspace.ARenderProduct()\n        instance.data[\"publishJobState\"] = \"Suspended\"\n        instance.data[\"attachTo\"] = []\n        product_type = \"maxrender\"\n        # also need to get the render dir for conversion\n        data = {\n            \"folderPath\": instance.data[\"folderPath\"],\n            \"productName\": str(instance.name),\n            \"publish\": True,\n            \"original_workfile_pattern\": render_dir.rsplit(\"\\\\\")[-1],\n            \"maxversion\": str(get_max_version()),\n            \"imageFormat\": img_format,\n            \"productType\": product_type,\n            \"family\": product_type,\n            \"families\": [product_type],\n            \"renderer\": renderer,\n            \"source\": filepath,\n            \"plugin\": \"3dsmax\",\n            \"frameStart\": instance.data[\"frameStartHandle\"],\n            \"frameEnd\": instance.data[\"frameEndHandle\"],\n            \"farm\": True\n        }\n        instance.data.update(data)\n        self.log.debug(instance.data)\n        # TODO: this should be unified with maya and its \"multipart\" flag\n        #       on instance.\n        if renderer == \"Redshift_Renderer\":\n            instance.data.update(\n                {\"separateAovFiles\": rt.Execute(\n                    \"renderers.current.separateAovFiles\")})\n\n        self.log.info(\"data: {0}\".format(data))\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_render.html#client.ayon_max.plugins.publish.collect_render.get_camera_from_node","title":"<code>get_camera_from_node(members)</code>","text":"<p>Get camera from instance members.</p> Source code in <code>client/ayon_max/plugins/publish/collect_render.py</code> <pre><code>def get_camera_from_node(members):\n    \"\"\"Get camera from instance members.\"\"\"\n    cameras = []\n    for member in members:\n        if rt.classOf(member) in rt.Camera.classes:\n            cameras.append(member)\n        if hasattr(member, \"children\"):\n            for child in member.children:\n                if rt.classOf(child) in rt.Camera.classes:\n                    cameras.append(child)\n    return cameras\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_review.html","title":"collect_review","text":"<p>Collect Review</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_review.html#client.ayon_max.plugins.publish.collect_review.CollectReview","title":"<code>CollectReview</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect Review Data for Preview Animation</p> Source code in <code>client/ayon_max/plugins/publish/collect_review.py</code> <pre><code>class CollectReview(pyblish.api.InstancePlugin,\n                    AYONPyblishPluginMixin):\n    \"\"\"Collect Review Data for Preview Animation\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.02\n    label = \"Collect Review Data\"\n    hosts = ['max']\n    families = [\"review\"]\n\n    def process(self, instance):\n        nodes = instance.data[\"members\"]\n\n        def is_camera(node):\n            is_camera_class = rt.classOf(node) in rt.Camera.classes\n            if hasattr(node, \"children\") and not is_camera_class:\n                for node_children in node.children:\n                    is_camera_class = rt.classOf(node_children) in rt.Camera.classes\n                    return is_camera_class\n\n            return is_camera_class\n\n        def get_focal_length(camera_node):\n            \"\"\"Get focal length from camera node or its children.\"\"\"\n            # Check direct FOV attribute\n            if hasattr(camera_node, 'fov'):\n                return camera_node.fov\n\n            # Check children for FOV attribute\n            if hasattr(camera_node, \"children\"):\n                for child in camera_node.children:\n                    if hasattr(child, 'fov'):\n                        return child.fov\n\n            # Return default focal length\n            return 45.0\n\n        # Use first camera in instance\n        cameras = [node for node in nodes if is_camera(node)]\n        if cameras:\n            if len(cameras) &gt; 1:\n                self.log.warning(\n                    \"Found more than one camera in instance, using first \"\n                    f\"one found: {cameras[0]}\"\n                )\n            camera = cameras[0]\n            camera_name = camera.name\n            # use default focal length if not found\n            # implement this specifically for imported cameras\n            focal_length = get_focal_length(camera)\n        else:\n            raise KnownPublishError(\n                \"Unable to find a valid camera in 'Review' container.\"\n                \" Only native max Camera supported. \"\n                f\"Found objects: {nodes}\"\n            )\n        creator_attrs = instance.data[\"creator_attributes\"]\n        attr_values = self.get_attr_values_from_data(instance.data)\n\n        general_preview_data = {\n            \"review_camera\": camera_name,\n            \"frameStart\": instance.data[\"frameStartHandle\"],\n            \"frameEnd\": instance.data[\"frameEndHandle\"],\n            \"percentSize\": creator_attrs[\"percentSize\"],\n            \"imageFormat\": creator_attrs[\"imageFormat\"],\n            \"keepImages\": creator_attrs[\"keepImages\"],\n            \"fps\": instance.context.data[\"fps\"],\n            \"resolutionWidth\": creator_attrs[\"review_width\"],\n            \"resolutionHeight\": creator_attrs[\"review_height\"],\n        }\n\n        if int(get_max_version()) &gt;= 2024:\n            colorspace_mgr = rt.ColorPipelineMgr      # noqa\n            display = next(\n                (display for display in colorspace_mgr.GetDisplayList()))\n            view_transform = next(\n                (view for view in colorspace_mgr.GetViewList(display)))\n            instance.data[\"colorspaceConfig\"] = colorspace_mgr.OCIOConfigPath\n            instance.data[\"colorspaceDisplay\"] = display\n            instance.data[\"colorspaceView\"] = view_transform\n\n            preview_data = {\n                \"vpStyle\": creator_attrs[\"visualStyleMode\"],\n                \"vpPreset\": creator_attrs[\"viewportPreset\"],\n                \"vpTextures\": creator_attrs[\"vpTexture\"],\n                \"dspGeometry\": attr_values.get(\"dspGeometry\"),\n                \"dspShapes\": attr_values.get(\"dspShapes\"),\n                \"dspLights\": attr_values.get(\"dspLights\"),\n                \"dspCameras\": attr_values.get(\"dspCameras\"),\n                \"dspHelpers\": attr_values.get(\"dspHelpers\"),\n                \"dspParticles\": attr_values.get(\"dspParticles\"),\n                \"dspBones\": attr_values.get(\"dspBones\"),\n                \"dspBkg\": attr_values.get(\"dspBkg\"),\n                \"dspGrid\": attr_values.get(\"dspGrid\"),\n                \"dspSafeFrame\": attr_values.get(\"dspSafeFrame\"),\n                \"dspFrameNums\": attr_values.get(\"dspFrameNums\")\n            }\n        else:\n            general_viewport = {\n                \"dspBkg\": attr_values.get(\"dspBkg\"),\n                \"dspGrid\": attr_values.get(\"dspGrid\")\n            }\n            nitrous_manager = {\n                \"AntialiasingQuality\": creator_attrs[\"antialiasingQuality\"],\n            }\n            nitrous_viewport = {\n                \"VisualStyleMode\": creator_attrs[\"visualStyleMode\"],\n                \"ViewportPreset\": creator_attrs[\"viewportPreset\"],\n                \"UseTextureEnabled\": creator_attrs[\"vpTexture\"]\n            }\n            preview_data = {\n                \"general_viewport\": general_viewport,\n                \"nitrous_manager\": nitrous_manager,\n                \"nitrous_viewport\": nitrous_viewport,\n                \"vp_btn_mgr\": {\"EnableButtons\": False}\n            }\n\n        # Enable ftrack functionality\n        instance.data.setdefault(\"families\", []).append('ftrack')\n\n        burnin_members = instance.data.setdefault(\"burninDataMembers\", {})\n        burnin_members[\"focalLength\"] = focal_length\n\n        instance.data.update(general_preview_data)\n        instance.data[\"viewport_options\"] = preview_data\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            UISeparatorDef(\"sep_export_options\"),\n            UILabelDef(\"Export Options\"),\n            BoolDef(\"dspGeometry\",\n                    label=\"Geometry\",\n                    default=True),\n            BoolDef(\"dspShapes\",\n                    label=\"Shapes\",\n                    default=False),\n            BoolDef(\"dspLights\",\n                    label=\"Lights\",\n                    default=False),\n            BoolDef(\"dspCameras\",\n                    label=\"Cameras\",\n                    default=False),\n            BoolDef(\"dspHelpers\",\n                    label=\"Helpers\",\n                    default=False),\n            BoolDef(\"dspParticles\",\n                    label=\"Particle Systems\",\n                    default=True),\n            BoolDef(\"dspBones\",\n                    label=\"Bone Objects\",\n                    default=False),\n            BoolDef(\"dspBkg\",\n                    label=\"Background\",\n                    default=True),\n            BoolDef(\"dspGrid\",\n                    label=\"Active Grid\",\n                    default=False),\n            BoolDef(\"dspSafeFrame\",\n                    label=\"Safe Frames\",\n                    default=False),\n            BoolDef(\"dspFrameNums\",\n                    label=\"Frame Numbers\",\n                    default=False),\n            UISeparatorDef(\"sep_export_options_end\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_tycache_attributes.html","title":"collect_tycache_attributes","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/collect_tycache_attributes.html#client.ayon_max.plugins.publish.collect_tycache_attributes.CollectTyFlowData","title":"<code>CollectTyFlowData</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>AYONPyblishPluginMixin</code></p> <p>Collect Channel Attributes for TyCache Export</p> Source code in <code>client/ayon_max/plugins/publish/collect_tycache_attributes.py</code> <pre><code>class CollectTyFlowData(pyblish.api.InstancePlugin,\n                        AYONPyblishPluginMixin):\n    \"\"\"Collect Channel Attributes for TyCache Export\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.005\n    label = \"Collect tyCache attribute Data\"\n    hosts = ['max']\n    families = [\"tyflow\"]\n    validate_tycache_frame_range = True\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n\n        settings = (\n            project_settings[\"max\"][\"publish\"][\"ValidateTyCacheFrameRange\"]\n        )\n        cls.validate_tycache_frame_range = settings[\"active\"]\n\n    def process(self, instance):\n        context = instance.context\n        container_name = instance.data[\"instance_node\"]\n        container = rt.GetNodeByName(container_name)\n        tyc_product_names = [\n            name for name\n            in container.modifiers[0].AYONTyCacheData.tyc_exports\n        ]\n        attr_values = self.get_attr_values_from_data(instance.data)\n        for tyc_product_name in tyc_product_names:\n            self.log.debug(f\"Creating instance for operator:{tyc_product_name}\")\n            tyc_instance = context.create_instance(tyc_product_name)\n            tyc_instance[:] = instance[:]\n            tyc_instance.data.update(copy.deepcopy(dict(instance.data)))\n            # Replace all runs of whitespace with underscore\n            prod_name = re.sub(r\"\\s+\", \"_\", tyc_product_name)\n            operator = next((node for node in get_tyflow_export_operators()\n                             if node.name == tyc_product_name), None)   # noqa\n            product_type = \"tycache\" if operator.exportMode == 2 else \"tyspline\"\n            tyc_instance.data.update({\n                \"name\": f\"{container_name}_{prod_name}\",\n                \"label\": f\"{container_name}_{prod_name}\",\n                \"family\": product_type,\n                \"families\": [product_type],\n                \"productName\": f\"{container_name}_{prod_name}\",\n                # get the name of operator for the export\n                \"operator\": operator,\n                \"exportMode\": operator.exportMode,\n                \"material_cache\": attr_values.get(\"material\"),\n                \"productType\": product_type,\n                \"productBaseType\": product_type,\n                \"creator_identifier\": (\n                    f\"io.openpype.creators.max.{product_type}\"),\n                \"publish_attributes\": {\n                    \"ValidateTyCacheFrameRange\": {\n                        \"active\": attr_values.get(\"has_frame_range_validator\")}\n                }\n            })\n            instance.append(tyc_instance)\n\n    @classmethod\n    def get_attribute_defs(cls):\n        return [\n            BoolDef(\"has_frame_range_validator\",\n                    label=\"Validate TyCache Frame Range\",\n                    default=cls.validate_tycache_frame_range),\n            BoolDef(\"material\",\n                    label=\"Publish along with Material\",\n                    default=True)\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_workfile.html","title":"collect_workfile","text":"<p>Collect current work file.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_workfile.html#client.ayon_max.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_max/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.01\n    label = \"Collect 3dsmax Workfile\"\n    hosts = ['max']\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        \"\"\"Inject the current working file.\"\"\"\n        context = instance.context\n        folder = rt.maxFilePath\n        file = rt.maxFileName\n        if not folder or not file:\n            self.log.error(\"Scene is not saved.\")\n        ext = os.path.splitext(file)[-1].lstrip(\".\")\n\n        data = {}\n\n        data.update({\n            \"setMembers\": context.data[\"currentFile\"],\n            \"frameStart\": context.data[\"frameStart\"],\n            \"frameEnd\": context.data[\"frameEnd\"],\n            \"handleStart\": context.data[\"handleStart\"],\n            \"handleEnd\": context.data[\"handleEnd\"]\n        })\n\n        data[\"representations\"] = [{\n            \"name\": ext,\n            \"ext\": ext,\n            \"files\": file,\n            \"stagingDir\": folder,\n        }]\n\n        instance.data.update(data)\n        self.log.debug(\"Collected data: {}\".format(data))\n        self.log.debug(\"Collected instance: {}\".format(file))\n        self.log.debug(\"staging Dir: {}\".format(folder))\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/collect_workfile.html#client.ayon_max.plugins.publish.collect_workfile.CollectWorkfile.process","title":"<code>process(instance)</code>","text":"<p>Inject the current working file.</p> Source code in <code>client/ayon_max/plugins/publish/collect_workfile.py</code> <pre><code>def process(self, instance):\n    \"\"\"Inject the current working file.\"\"\"\n    context = instance.context\n    folder = rt.maxFilePath\n    file = rt.maxFileName\n    if not folder or not file:\n        self.log.error(\"Scene is not saved.\")\n    ext = os.path.splitext(file)[-1].lstrip(\".\")\n\n    data = {}\n\n    data.update({\n        \"setMembers\": context.data[\"currentFile\"],\n        \"frameStart\": context.data[\"frameStart\"],\n        \"frameEnd\": context.data[\"frameEnd\"],\n        \"handleStart\": context.data[\"handleStart\"],\n        \"handleEnd\": context.data[\"handleEnd\"]\n    })\n\n    data[\"representations\"] = [{\n        \"name\": ext,\n        \"ext\": ext,\n        \"files\": file,\n        \"stagingDir\": folder,\n    }]\n\n    instance.data.update(data)\n    self.log.debug(\"Collected data: {}\".format(data))\n    self.log.debug(\"Collected instance: {}\".format(file))\n    self.log.debug(\"staging Dir: {}\".format(folder))\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_alembic.html","title":"extract_alembic","text":"<p>Export alembic file.</p> Note <p>Parameters on AlembicExport (AlembicExport.Parameter):</p> <p>ParticleAsMesh (bool): Sets whether particle shapes are exported     as meshes. AnimTimeRange (enum): How animation is saved:     #CurrentFrame: saves current frame     #TimeSlider: saves the active time segments on time slider (default)     #StartEnd: saves a range specified by the Step StartFrame (int) EnFrame (int) ShapeSuffix (bool): When set to true, appends the string \"Shape\" to the     name of each exported mesh. This property is set to false by default. SamplesPerFrame (int): Sets the number of animation samples per frame. Hidden (bool): When true, export hidden geometry. UVs (bool): When true, export the mesh UV map channel. Normals (bool): When true, export the mesh normals. VertexColors (bool): When true, export the mesh vertex color map 0 and the     current vertex color display data when it differs ExtraChannels (bool): When true, export the mesh extra map channels     (map channels greater than channel 1) Velocity (bool): When true, export the meh vertex and particle velocity     data. MaterialIDs (bool): When true, export the mesh material ID as     Alembic face sets. Visibility (bool): When true, export the node visibility data. LayerName (bool): When true, export the node layer name as an Alembic     object property. MaterialName (bool): When true, export the geometry node material name as     an Alembic object property ObjectID (bool): When true, export the geometry node g-buffer object ID as     an Alembic object property. CustomAttributes (bool): When true, export the node and its modifiers     custom attributes into an Alembic object compound property.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_alembic.html#client.ayon_max.plugins.publish.extract_alembic.ExtractCameraAlembic","title":"<code>ExtractCameraAlembic</code>","text":"<p>               Bases: <code>ExtractAlembic</code></p> <p>Extract Camera with AlembicExport.</p> Source code in <code>client/ayon_max/plugins/publish/extract_alembic.py</code> <pre><code>class ExtractCameraAlembic(ExtractAlembic):\n    \"\"\"Extract Camera with AlembicExport.\"\"\"\n    label = \"Extract Alembic Camera\"\n    families = [\"camera\"]\n    optional = True\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_alembic.html#client.ayon_max.plugins.publish.extract_alembic.ExtractModelAlembic","title":"<code>ExtractModelAlembic</code>","text":"<p>               Bases: <code>ExtractAlembic</code></p> <p>Extract Geometry in Alembic Format</p> Source code in <code>client/ayon_max/plugins/publish/extract_alembic.py</code> <pre><code>class ExtractModelAlembic(ExtractAlembic):\n    \"\"\"Extract Geometry in Alembic Format\"\"\"\n    label = \"Extract Geometry (Alembic)\"\n    families = [\"model\"]\n    optional = True\n\n    def _set_abc_attributes(self, instance):\n        attr_values = self.get_attr_values_from_data(instance.data)\n        custom_attrs = attr_values.get(\"custom_attrs\", False)\n        if not custom_attrs:\n            self.log.debug(\n                \"No Custom Attributes included in this abc export...\")\n        rt.AlembicExport.ArchiveType = rt.name(\"ogawa\")\n        rt.AlembicExport.CoordinateSystem = rt.name(\"maya\")\n        rt.AlembicExport.CustomAttributes = custom_attrs\n        rt.AlembicExport.UVs = True\n        rt.AlembicExport.VertexColors = True\n        rt.AlembicExport.PreserveInstances = True\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_fbx.html","title":"extract_fbx","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_fbx.html#client.ayon_max.plugins.publish.extract_fbx.ExtractCameraFbx","title":"<code>ExtractCameraFbx</code>","text":"<p>               Bases: <code>ExtractModelFbx</code></p> <p>Extract Camera with FbxExporter.</p> Source code in <code>client/ayon_max/plugins/publish/extract_fbx.py</code> <pre><code>class ExtractCameraFbx(ExtractModelFbx):\n    \"\"\"Extract Camera with FbxExporter.\"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.2\n    label = \"Extract Fbx Camera\"\n    families = [\"camera\"]\n    optional = True\n\n    def _set_fbx_attributes(self):\n        unit_scale = convert_unit_scale()\n        rt.FBXExporterSetParam(\"Animation\", True)\n        rt.FBXExporterSetParam(\"Cameras\", True)\n        rt.FBXExporterSetParam(\"AxisConversionMethod\", \"Animation\")\n        rt.FBXExporterSetParam(\"UpAxis\", \"Y\")\n        rt.FBXExporterSetParam(\"Preserveinstances\", True)\n        if unit_scale:\n            rt.FBXExporterSetParam(\"ConvertUnit\", unit_scale)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_fbx.html#client.ayon_max.plugins.publish.extract_fbx.ExtractModelFbx","title":"<code>ExtractModelFbx</code>","text":"<p>               Bases: <code>Extractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract Geometry in FBX Format</p> Source code in <code>client/ayon_max/plugins/publish/extract_fbx.py</code> <pre><code>class ExtractModelFbx(publish.Extractor, OptionalPyblishPluginMixin):\n    \"\"\"\n    Extract Geometry in FBX Format\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.05\n    label = \"Extract FBX\"\n    hosts = [\"max\"]\n    families = [\"model\"]\n    optional = True\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        stagingdir = self.staging_dir(instance)\n        filename = \"{name}.fbx\".format(**instance.data)\n        filepath = os.path.join(stagingdir, filename)\n        self._set_fbx_attributes()\n\n        with maintained_selection():\n            # select and export\n            node_list = instance.data[\"members\"]\n            rt.Select(node_list)\n            rt.exportFile(\n                filepath,\n                rt.name(\"noPrompt\"),\n                selectedOnly=True,\n                using=rt.FBXEXP,\n            )\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": \"fbx\",\n            \"ext\": \"fbx\",\n            \"files\": filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n        self.log.info(\n            \"Extracted instance '%s' to: %s\" % (instance.name, filepath)\n        )\n\n    def _set_fbx_attributes(self):\n        unit_scale = convert_unit_scale()\n        rt.FBXExporterSetParam(\"Animation\", False)\n        rt.FBXExporterSetParam(\"Cameras\", False)\n        rt.FBXExporterSetParam(\"Lights\", False)\n        rt.FBXExporterSetParam(\"PointCache\", False)\n        rt.FBXExporterSetParam(\"AxisConversionMethod\", \"Animation\")\n        rt.FBXExporterSetParam(\"UpAxis\", \"Y\")\n        rt.FBXExporterSetParam(\"Preserveinstances\", True)\n        if unit_scale:\n            rt.FBXExporterSetParam(\"ConvertUnit\", unit_scale)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_max_scene_raw.html","title":"extract_max_scene_raw","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_max_scene_raw.html#client.ayon_max.plugins.publish.extract_max_scene_raw.ExtractMaxSceneRaw","title":"<code>ExtractMaxSceneRaw</code>","text":"<p>               Bases: <code>Extractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract Raw Max Scene with SaveSelected</p> Source code in <code>client/ayon_max/plugins/publish/extract_max_scene_raw.py</code> <pre><code>class ExtractMaxSceneRaw(publish.Extractor, OptionalPyblishPluginMixin):\n    \"\"\"\n    Extract Raw Max Scene with SaveSelected\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.2\n    label = \"Extract Max Scene (Raw)\"\n    hosts = [\"max\"]\n    families = [\"camera\", \"maxScene\", \"model\"]\n    optional = True\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        # publish the raw scene for camera\n        self.log.debug(\"Extracting Raw Max Scene ...\")\n\n        stagingdir = self.staging_dir(instance)\n        filename = \"{name}.max\".format(**instance.data)\n\n        max_path = os.path.join(stagingdir, filename)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        nodes = instance.data[\"members\"]\n        rt.saveNodes(nodes, max_path, quiet=True)\n\n        self.log.info(\"Performing Extraction ...\")\n\n        representation = {\n            \"name\": \"max\",\n            \"ext\": \"max\",\n            \"files\": filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n        self.log.info(\n            \"Extracted instance '%s' to: %s\" % (instance.name, max_path)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_model_obj.html","title":"extract_model_obj","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_model_obj.html#client.ayon_max.plugins.publish.extract_model_obj.ExtractModelObj","title":"<code>ExtractModelObj</code>","text":"<p>               Bases: <code>Extractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract Geometry in OBJ Format</p> Source code in <code>client/ayon_max/plugins/publish/extract_model_obj.py</code> <pre><code>class ExtractModelObj(publish.Extractor, OptionalPyblishPluginMixin):\n    \"\"\"\n    Extract Geometry in OBJ Format\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.05\n    label = \"Extract OBJ\"\n    hosts = [\"max\"]\n    families = [\"model\"]\n    optional = True\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        stagingdir = self.staging_dir(instance)\n        filename = \"{name}.obj\".format(**instance.data)\n        filepath = os.path.join(stagingdir, filename)\n\n        with suspended_refresh():\n            with maintained_selection():\n                # select and export\n                node_list = instance.data[\"members\"]\n                rt.Select(node_list)\n                rt.exportFile(\n                    filepath,\n                    rt.name(\"noPrompt\"),\n                    selectedOnly=True,\n                    using=rt.ObjExp,\n                )\n        if not os.path.exists(filepath):\n            raise KnownPublishError(\n                \"File {} wasn't produced by 3ds max, please check the logs.\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            \"name\": \"obj\",\n            \"ext\": \"obj\",\n            \"files\": filename,\n            \"stagingDir\": stagingdir,\n        }\n\n        instance.data[\"representations\"].append(representation)\n        self.log.info(\n            \"Extracted instance '%s' to: %s\" % (instance.name, filepath)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_model_usd.html","title":"extract_model_usd","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_model_usd.html#client.ayon_max.plugins.publish.extract_model_usd.ExtractModelUSD","title":"<code>ExtractModelUSD</code>","text":"<p>               Bases: <code>Extractor</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Extract Geometry in USDA Format.</p> Source code in <code>client/ayon_max/plugins/publish/extract_model_usd.py</code> <pre><code>class ExtractModelUSD(publish.Extractor,\n                      OptionalPyblishPluginMixin):\n    \"\"\"Extract Geometry in USDA Format.\"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.05\n    label = \"Extract Geometry (USD)\"\n    hosts = [\"max\"]\n    families = [\"model\"]\n    optional = True\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        self.log.info(\"Extracting Geometry ...\")\n\n        stagingdir = self.staging_dir(instance)\n        asset_filename = \"{name}.usda\".format(**instance.data)\n        asset_filepath = os.path.join(stagingdir,\n                                      asset_filename)\n        self.log.info(f\"Writing USD '{asset_filepath}' to '{stagingdir}'\")\n\n        log_filename = \"{name}.txt\".format(**instance.data)\n        log_filepath = os.path.join(stagingdir,\n                                    log_filename)\n        self.log.info(f\"Writing log '{log_filepath}' to '{stagingdir}'\")\n\n        # get the nodes which need to be exported\n        export_options = self.get_export_options(log_filepath)\n        with maintained_selection():\n            # select and export\n            node_list = instance.data[\"members\"]\n            rt.Select(node_list)\n            rt.USDExporter.ExportFile(asset_filepath,\n                                      exportOptions=export_options,\n                                      contentSource=rt.Name(\"selected\"),\n                                      nodeList=node_list)\n\n        self.log.info(\"Performing Extraction ...\")\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'usda',\n            'ext': 'usda',\n            'files': asset_filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n\n        log_representation = {\n            'name': 'txt',\n            'ext': 'txt',\n            'files': log_filename,\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(log_representation)\n\n        self.log.info(\n            f\"Extracted instance '{instance.name}' to: {asset_filepath}\")\n\n    @staticmethod\n    def get_export_options(log_path):\n        \"\"\"Set Export Options for USD Exporter\"\"\"\n\n        export_options = rt.USDExporter.createOptions()\n\n        export_options.Meshes = True\n        export_options.Shapes = False\n        export_options.Lights = False\n        export_options.Cameras = False\n        export_options.Materials = False\n        export_options.MeshFormat = rt.Name('fromScene')\n        export_options.FileFormat = rt.Name('ascii')\n        export_options.UpAxis = rt.Name('y')\n        export_options.LogLevel = rt.Name('info')\n        export_options.LogPath = log_path\n        export_options.PreserveEdgeOrientation = True\n        export_options.TimeMode = rt.Name('current')\n\n        rt.USDexporter.UIOptions = export_options\n\n        return export_options\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_model_usd.html#client.ayon_max.plugins.publish.extract_model_usd.ExtractModelUSD.get_export_options","title":"<code>get_export_options(log_path)</code>  <code>staticmethod</code>","text":"<p>Set Export Options for USD Exporter</p> Source code in <code>client/ayon_max/plugins/publish/extract_model_usd.py</code> <pre><code>@staticmethod\ndef get_export_options(log_path):\n    \"\"\"Set Export Options for USD Exporter\"\"\"\n\n    export_options = rt.USDExporter.createOptions()\n\n    export_options.Meshes = True\n    export_options.Shapes = False\n    export_options.Lights = False\n    export_options.Cameras = False\n    export_options.Materials = False\n    export_options.MeshFormat = rt.Name('fromScene')\n    export_options.FileFormat = rt.Name('ascii')\n    export_options.UpAxis = rt.Name('y')\n    export_options.LogLevel = rt.Name('info')\n    export_options.LogPath = log_path\n    export_options.PreserveEdgeOrientation = True\n    export_options.TimeMode = rt.Name('current')\n\n    rt.USDexporter.UIOptions = export_options\n\n    return export_options\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html","title":"extract_pointcloud","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud","title":"<code>ExtractPointCloud</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract PRT format with tyFlow operators.</p> Notes <p>Currently only works for the default partition setting</p> <p>Parameters:</p> Name Type Description Default <code>self.export_particle</code> <p>sets up all job arguments for attributes to be exported in MAXscript</p> required <code>self.get_operators</code> <p>get the export_particle operator</p> required <code>self.get_custom_attr</code> <p>get all custom channel attributes from Openpype setting and sets it as job arguments before exporting</p> required <code>self.get_files</code> <p>get the files with tyFlow naming convention before publishing</p> required <code>self.partition_output_name</code> <p>get the naming with partition settings.</p> required <code>self.get_partition</code> <p>get partition value</p> required Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>class ExtractPointCloud(publish.Extractor):\n    \"\"\"\n    Extract PRT format with tyFlow operators.\n\n    Notes:\n        Currently only works for the default partition setting\n\n    Args:\n        self.export_particle(): sets up all job arguments for attributes\n            to be exported in MAXscript\n\n        self.get_operators(): get the export_particle operator\n\n        self.get_custom_attr(): get all custom channel attributes from Openpype\n            setting and sets it as job arguments before exporting\n\n        self.get_files(): get the files with tyFlow naming convention\n            before publishing\n\n        self.partition_output_name(): get the naming with partition settings.\n\n        self.get_partition(): get partition value\n\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.2\n    label = \"Extract Point Cloud\"\n    hosts = [\"max\"]\n    families = [\"pointcloud\"]\n    settings = []\n\n    def process(self, instance):\n        self.settings = self.get_setting(instance)\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n        self.log.info(\"Extracting PRT...\")\n\n        stagingdir = self.staging_dir(instance)\n        filename = \"{name}.prt\".format(**instance.data)\n        path = os.path.join(stagingdir, filename)\n\n        with maintained_selection():\n            job_args = self.export_particle(instance.data[\"members\"],\n                                            start,\n                                            end,\n                                            path)\n\n            for job in job_args:\n                rt.Execute(job)\n\n        self.log.info(\"Performing Extraction ...\")\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        self.log.info(\"Writing PRT with TyFlow Plugin...\")\n        filenames = self.get_files(\n            instance.data[\"members\"], path, start, end)\n        self.log.debug(f\"filenames: {filenames}\")\n\n        partition = self.partition_output_name(\n            instance.data[\"members\"])\n\n        representation = {\n            'name': 'prt',\n            'ext': 'prt',\n            'files': filenames if len(filenames) &gt; 1 else filenames[0],\n            \"stagingDir\": stagingdir,\n            \"outputName\": partition         # partition value\n        }\n        instance.data[\"representations\"].append(representation)\n        self.log.info(f\"Extracted instance '{instance.name}' to: {path}\")\n\n    def export_particle(self,\n                        members,\n                        start,\n                        end,\n                        filepath):\n        \"\"\"Sets up all job arguments for attributes.\n\n        Those attributes are to be exported in MAX Script.\n\n        Args:\n            members (list): Member nodes of the instance.\n            start (int): Start frame.\n            end (int): End frame.\n            filepath (str): Path to PRT file.\n\n        Returns:\n            list of arguments for MAX Script.\n\n        \"\"\"\n        job_args = []\n        opt_list = self.get_operators(members)\n        for operator in opt_list:\n            start_frame = f\"{operator}.frameStart={start}\"\n            job_args.append(start_frame)\n            end_frame = f\"{operator}.frameEnd={end}\"\n            job_args.append(end_frame)\n            filepath = filepath.replace(\"\\\\\", \"/\")\n            prt_filename = f'{operator}.PRTFilename=\"{filepath}\"'\n            job_args.append(prt_filename)\n            # Partition\n            mode = f\"{operator}.PRTPartitionsMode=2\"\n            job_args.append(mode)\n\n            additional_args = self.get_custom_attr(operator)\n            job_args.extend(iter(additional_args))\n            prt_export = f\"{operator}.exportPRT()\"\n            job_args.append(prt_export)\n\n        return job_args\n\n    @staticmethod\n    def get_operators(members):\n        \"\"\"Get Export Particles Operator.\n\n        Args:\n            members (list): Instance members.\n\n        Returns:\n            list of particle operators\n\n        \"\"\"\n        opt_list = []\n        for member in members:\n            obj = member.baseobject\n            anim_names = rt.GetSubAnimNames(obj)\n            for anim_name in anim_names:\n                sub_anim = rt.GetSubAnim(obj, anim_name)\n                # Isolate only the events\n                if not rt.isKindOf(sub_anim, rt.tyEvent):\n                    continue\n\n                # Look through all the nodes in the events\n                node_names = rt.GetSubAnimNames(sub_anim)\n                for node_name in node_names:\n                    node_sub_anim = rt.GetSubAnim(sub_anim, node_name)\n                    if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                        opt = f\"${member.Name}.{sub_anim.Name}.{node_name}\"\n                        opt_list.append(opt)\n        return opt_list\n\n    @staticmethod\n    def get_setting(instance):\n        project_setting = instance.context.data[\"project_settings\"]\n        return project_setting[\"max\"][\"PointCloud\"]\n\n    def get_custom_attr(self, operator):\n        \"\"\"Get Custom Attributes\"\"\"\n\n        custom_attr_list = []\n        attr_settings = self.settings[\"attribute\"]\n        for attr in attr_settings:\n            key = attr[\"name\"]\n            value = attr[\"value\"]\n            custom_attr = \"{0}.PRTChannels_{1}=True\".format(operator,\n                                                            value)\n            self.log.debug(\n                \"{0} will be added as custom attribute\".format(key)\n            )\n            custom_attr_list.append(custom_attr)\n\n        return custom_attr_list\n\n    def get_files(self,\n                  container,\n                  path,\n                  start_frame,\n                  end_frame):\n        \"\"\"Get file names for tyFlow.\n\n        Set the filenames accordingly to the tyFlow file\n        naming extension for the publishing purpose\n\n        Actual File Output from tyFlow::\n            &lt;SceneFile&gt;__part&lt;PartitionStart&gt;of&lt;PartitionCount&gt;.&lt;frame&gt;.prt\n\n            e.g. tyFlow_cloth_CCCS_blobbyFill_001__part1of1_00004.prt\n\n        Args:\n            container: Instance node.\n            path (str): Output directory.\n            start_frame (int): Start frame.\n            end_frame (int): End frame.\n\n        Returns:\n            list of filenames\n\n        \"\"\"\n        filenames = []\n        filename = os.path.basename(path)\n        orig_name, ext = os.path.splitext(filename)\n        partition_count, partition_start = self.get_partition(container)\n        for frame in range(int(start_frame), int(end_frame) + 1):\n            actual_name = \"{}__part{:03}of{}_{:05}\".format(orig_name,\n                                                           partition_start,\n                                                           partition_count,\n                                                           frame)\n            actual_filename = path.replace(orig_name, actual_name)\n            filenames.append(os.path.basename(actual_filename))\n\n        return filenames\n\n    def partition_output_name(self, container):\n        \"\"\"Get partition output name.\n\n        Partition output name set for mapping\n        the published file output.\n\n        Todo:\n            Customizes the setting for the output.\n\n        Args:\n            container: Instance node.\n\n        Returns:\n            str: Partition name.\n\n        \"\"\"\n        partition_count, partition_start = self.get_partition(container)\n        return f\"_part{partition_start:03}of{partition_count}\"\n\n    def get_partition(self, container):\n        \"\"\"Get Partition value.\n\n        Args:\n            container: Instance node.\n\n        \"\"\"\n        opt_list = self.get_operators(container)\n        # TODO: This looks strange? Iterating over\n        #   the opt_list but returning from inside?\n        for operator in opt_list:\n            count = rt.Execute(f'{operator}.PRTPartitionsCount')\n            start = rt.Execute(f'{operator}.PRTPartitionsFrom')\n\n            return count, start\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud.export_particle","title":"<code>export_particle(members, start, end, filepath)</code>","text":"<p>Sets up all job arguments for attributes.</p> <p>Those attributes are to be exported in MAX Script.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>list</code> <p>Member nodes of the instance.</p> required <code>start</code> <code>int</code> <p>Start frame.</p> required <code>end</code> <code>int</code> <p>End frame.</p> required <code>filepath</code> <code>str</code> <p>Path to PRT file.</p> required <p>Returns:</p> Type Description <p>list of arguments for MAX Script.</p> Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>def export_particle(self,\n                    members,\n                    start,\n                    end,\n                    filepath):\n    \"\"\"Sets up all job arguments for attributes.\n\n    Those attributes are to be exported in MAX Script.\n\n    Args:\n        members (list): Member nodes of the instance.\n        start (int): Start frame.\n        end (int): End frame.\n        filepath (str): Path to PRT file.\n\n    Returns:\n        list of arguments for MAX Script.\n\n    \"\"\"\n    job_args = []\n    opt_list = self.get_operators(members)\n    for operator in opt_list:\n        start_frame = f\"{operator}.frameStart={start}\"\n        job_args.append(start_frame)\n        end_frame = f\"{operator}.frameEnd={end}\"\n        job_args.append(end_frame)\n        filepath = filepath.replace(\"\\\\\", \"/\")\n        prt_filename = f'{operator}.PRTFilename=\"{filepath}\"'\n        job_args.append(prt_filename)\n        # Partition\n        mode = f\"{operator}.PRTPartitionsMode=2\"\n        job_args.append(mode)\n\n        additional_args = self.get_custom_attr(operator)\n        job_args.extend(iter(additional_args))\n        prt_export = f\"{operator}.exportPRT()\"\n        job_args.append(prt_export)\n\n    return job_args\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud.get_custom_attr","title":"<code>get_custom_attr(operator)</code>","text":"<p>Get Custom Attributes</p> Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>def get_custom_attr(self, operator):\n    \"\"\"Get Custom Attributes\"\"\"\n\n    custom_attr_list = []\n    attr_settings = self.settings[\"attribute\"]\n    for attr in attr_settings:\n        key = attr[\"name\"]\n        value = attr[\"value\"]\n        custom_attr = \"{0}.PRTChannels_{1}=True\".format(operator,\n                                                        value)\n        self.log.debug(\n            \"{0} will be added as custom attribute\".format(key)\n        )\n        custom_attr_list.append(custom_attr)\n\n    return custom_attr_list\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud.get_files","title":"<code>get_files(container, path, start_frame, end_frame)</code>","text":"<p>Get file names for tyFlow.</p> <p>Set the filenames accordingly to the tyFlow file naming extension for the publishing purpose</p> <p>Actual File Output from tyFlow::     __partof..prt <pre><code>e.g. tyFlow_cloth_CCCS_blobbyFill_001__part1of1_00004.prt\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>container</code> <p>Instance node.</p> required <code>path</code> <code>str</code> <p>Output directory.</p> required <code>start_frame</code> <code>int</code> <p>Start frame.</p> required <code>end_frame</code> <code>int</code> <p>End frame.</p> required <p>Returns:</p> Type Description <p>list of filenames</p> Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>def get_files(self,\n              container,\n              path,\n              start_frame,\n              end_frame):\n    \"\"\"Get file names for tyFlow.\n\n    Set the filenames accordingly to the tyFlow file\n    naming extension for the publishing purpose\n\n    Actual File Output from tyFlow::\n        &lt;SceneFile&gt;__part&lt;PartitionStart&gt;of&lt;PartitionCount&gt;.&lt;frame&gt;.prt\n\n        e.g. tyFlow_cloth_CCCS_blobbyFill_001__part1of1_00004.prt\n\n    Args:\n        container: Instance node.\n        path (str): Output directory.\n        start_frame (int): Start frame.\n        end_frame (int): End frame.\n\n    Returns:\n        list of filenames\n\n    \"\"\"\n    filenames = []\n    filename = os.path.basename(path)\n    orig_name, ext = os.path.splitext(filename)\n    partition_count, partition_start = self.get_partition(container)\n    for frame in range(int(start_frame), int(end_frame) + 1):\n        actual_name = \"{}__part{:03}of{}_{:05}\".format(orig_name,\n                                                       partition_start,\n                                                       partition_count,\n                                                       frame)\n        actual_filename = path.replace(orig_name, actual_name)\n        filenames.append(os.path.basename(actual_filename))\n\n    return filenames\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud.get_operators","title":"<code>get_operators(members)</code>  <code>staticmethod</code>","text":"<p>Get Export Particles Operator.</p> <p>Parameters:</p> Name Type Description Default <code>members</code> <code>list</code> <p>Instance members.</p> required <p>Returns:</p> Type Description <p>list of particle operators</p> Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>@staticmethod\ndef get_operators(members):\n    \"\"\"Get Export Particles Operator.\n\n    Args:\n        members (list): Instance members.\n\n    Returns:\n        list of particle operators\n\n    \"\"\"\n    opt_list = []\n    for member in members:\n        obj = member.baseobject\n        anim_names = rt.GetSubAnimNames(obj)\n        for anim_name in anim_names:\n            sub_anim = rt.GetSubAnim(obj, anim_name)\n            # Isolate only the events\n            if not rt.isKindOf(sub_anim, rt.tyEvent):\n                continue\n\n            # Look through all the nodes in the events\n            node_names = rt.GetSubAnimNames(sub_anim)\n            for node_name in node_names:\n                node_sub_anim = rt.GetSubAnim(sub_anim, node_name)\n                if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                    opt = f\"${member.Name}.{sub_anim.Name}.{node_name}\"\n                    opt_list.append(opt)\n    return opt_list\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud.get_partition","title":"<code>get_partition(container)</code>","text":"<p>Get Partition value.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <p>Instance node.</p> required Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>def get_partition(self, container):\n    \"\"\"Get Partition value.\n\n    Args:\n        container: Instance node.\n\n    \"\"\"\n    opt_list = self.get_operators(container)\n    # TODO: This looks strange? Iterating over\n    #   the opt_list but returning from inside?\n    for operator in opt_list:\n        count = rt.Execute(f'{operator}.PRTPartitionsCount')\n        start = rt.Execute(f'{operator}.PRTPartitionsFrom')\n\n        return count, start\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_pointcloud.html#client.ayon_max.plugins.publish.extract_pointcloud.ExtractPointCloud.partition_output_name","title":"<code>partition_output_name(container)</code>","text":"<p>Get partition output name.</p> <p>Partition output name set for mapping the published file output.</p> Todo <p>Customizes the setting for the output.</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <p>Instance node.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>Partition name.</p> Source code in <code>client/ayon_max/plugins/publish/extract_pointcloud.py</code> <pre><code>def partition_output_name(self, container):\n    \"\"\"Get partition output name.\n\n    Partition output name set for mapping\n    the published file output.\n\n    Todo:\n        Customizes the setting for the output.\n\n    Args:\n        container: Instance node.\n\n    Returns:\n        str: Partition name.\n\n    \"\"\"\n    partition_count, partition_start = self.get_partition(container)\n    return f\"_part{partition_start:03}of{partition_count}\"\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_redshift_proxy.html","title":"extract_redshift_proxy","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_redshift_proxy.html#client.ayon_max.plugins.publish.extract_redshift_proxy.ExtractRedshiftProxy","title":"<code>ExtractRedshiftProxy</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract Redshift Proxy with rsProxy</p> Source code in <code>client/ayon_max/plugins/publish/extract_redshift_proxy.py</code> <pre><code>class ExtractRedshiftProxy(publish.Extractor):\n    \"\"\"\n    Extract Redshift Proxy with rsProxy\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.1\n    label = \"Extract RedShift Proxy\"\n    hosts = [\"max\"]\n    families = [\"redshiftproxy\"]\n\n    def process(self, instance):\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n\n        self.log.debug(\"Extracting Redshift Proxy...\")\n        stagingdir = self.staging_dir(instance)\n        rs_filename = \"{name}.rs\".format(**instance.data)\n        rs_filepath = os.path.join(stagingdir, rs_filename)\n        rs_filepath = rs_filepath.replace(\"\\\\\", \"/\")\n\n        rs_filenames = self.get_rsfiles(instance, start, end)\n\n        with maintained_selection():\n            # select and export\n            node_list = instance.data[\"members\"]\n            rt.Select(node_list)\n            # Redshift rsProxy command\n            # rsProxy fp selected compress connectivity startFrame endFrame\n            # camera warnExisting transformPivotToOrigin\n            rt.rsProxy(rs_filepath, 1, 0, 0, start, end, 0, 1, 1)\n\n        self.log.info(\"Performing Extraction ...\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        representation = {\n            'name': 'rs',\n            'ext': 'rs',\n            'files': rs_filenames if len(rs_filenames) &gt; 1 else rs_filenames[0],    # noqa\n            \"stagingDir\": stagingdir,\n        }\n        instance.data[\"representations\"].append(representation)\n        self.log.info(\"Extracted instance '%s' to: %s\" % (instance.name,\n                                                          stagingdir))\n\n    def get_rsfiles(self, instance, startFrame, endFrame):\n        rs_filenames = []\n        rs_name = instance.data[\"name\"]\n        for frame in range(startFrame, endFrame + 1):\n            rs_filename = \"%s.%04d.rs\" % (rs_name, frame)\n            rs_filenames.append(rs_filename)\n\n        return rs_filenames\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_review_animation.html","title":"extract_review_animation","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_review_animation.html#client.ayon_max.plugins.publish.extract_review_animation.ExtractReviewAnimation","title":"<code>ExtractReviewAnimation</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract Review by Review Animation</p> Source code in <code>client/ayon_max/plugins/publish/extract_review_animation.py</code> <pre><code>class ExtractReviewAnimation(publish.Extractor):\n    \"\"\"\n    Extract Review by Review Animation\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder + 0.001\n    label = \"Extract Review Animation\"\n    hosts = [\"max\"]\n    families = [\"review\"]\n\n    def process(self, instance):\n        staging_dir = self.staging_dir(instance)\n        ext = instance.data.get(\"imageFormat\")\n        start = int(instance.data[\"frameStart\"])\n        end = int(instance.data[\"frameEnd\"])\n        filepath = os.path.join(staging_dir, instance.name)\n        self.log.debug(\n            \"Writing Review Animation to '{}'\".format(filepath))\n\n        review_camera = instance.data[\"review_camera\"]\n        viewport_options = instance.data.get(\"viewport_options\", {})\n        with set_viewport_type():\n            files = render_preview_animation(\n                filepath,\n                ext,\n                review_camera,\n                start,\n                end,\n                percentSize=instance.data[\"percentSize\"],\n                width=instance.data[\"resolutionWidth\"],\n                height=instance.data[\"resolutionHeight\"],\n                viewport_options=viewport_options)\n\n        filenames = [os.path.basename(path) for path in files]\n\n        tags = [\"review\"]\n        if not instance.data.get(\"keepImages\"):\n            tags.append(\"delete\")\n\n        self.log.debug(\"Performing Extraction ...\")\n\n        representation = {\n            \"name\": instance.data[\"imageFormat\"],\n            \"ext\": instance.data[\"imageFormat\"],\n            \"files\": filenames,\n            \"stagingDir\": staging_dir,\n            \"frameStart\": instance.data[\"frameStartHandle\"],\n            \"frameEnd\": instance.data[\"frameEndHandle\"],\n            \"tags\": tags,\n            \"preview\": True,\n            \"camera_name\": review_camera\n        }\n        self.log.debug(f\"{representation}\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_thumbnail.html","title":"extract_thumbnail","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_thumbnail.html#client.ayon_max.plugins.publish.extract_thumbnail.ExtractThumbnail","title":"<code>ExtractThumbnail</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract Thumbnail for Review</p> Source code in <code>client/ayon_max/plugins/publish/extract_thumbnail.py</code> <pre><code>class ExtractThumbnail(publish.Extractor):\n    \"\"\"Extract Thumbnail for Review\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.3\n    label = \"Extract Thumbnail\"\n    hosts = [\"max\"]\n    families = [\"review\"]\n\n    def process(self, instance):\n        ext = instance.data.get(\"imageFormat\")\n        frame = int(instance.data[\"frameStart\"])\n        staging_dir = self.staging_dir(instance)\n        filepath = os.path.join(\n            staging_dir, f\"{instance.name}_thumbnail\")\n        self.log.debug(\"Writing Thumbnail to '{}'\".format(filepath))\n\n        review_camera = instance.data[\"review_camera\"]\n        viewport_options = instance.data.get(\"viewport_options\", {})\n        files = render_preview_animation(\n            filepath,\n            ext,\n            review_camera,\n            start_frame=frame,\n            end_frame=frame,\n            percentSize=instance.data[\"percentSize\"],\n            width=instance.data[\"resolutionWidth\"],\n            height=instance.data[\"resolutionHeight\"],\n            viewport_options=viewport_options)\n\n        thumbnail = next(os.path.basename(path) for path in files)\n\n        representation = {\n            \"name\": \"thumbnail\",\n            \"ext\": ext,\n            \"files\": thumbnail,\n            \"stagingDir\": staging_dir,\n            \"thumbnail\": True\n        }\n\n        self.log.debug(f\"{representation}\")\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_tycache.html","title":"extract_tycache","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/extract_tycache.html#client.ayon_max.plugins.publish.extract_tycache.ExtractTyCache","title":"<code>ExtractTyCache</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract tycache format with tyFlow operators. Notes:     - TyCache only works for TyFlow Pro Plugin.</p> <p>Methods:</p> Name Description <code>self._extract_tyflow_particles</code> <p>sets the necessary attributes and export tyCache with the export particle operator(s)</p> <code>self.get_files</code> <p>get the files with tyFlow naming convention before publishing</p> Source code in <code>client/ayon_max/plugins/publish/extract_tycache.py</code> <pre><code>class ExtractTyCache(publish.Extractor):\n    \"\"\"Extract tycache format with tyFlow operators.\n    Notes:\n        - TyCache only works for TyFlow Pro Plugin.\n\n    Methods:\n        self._extract_tyflow_particles: sets the necessary\n            attributes and export tyCache with the export\n            particle operator(s)\n\n        self.get_files(): get the files with tyFlow naming convention\n            before publishing\n    \"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.2\n    label = \"Extract TyCache\"\n    hosts = [\"max\"]\n    families = [\"tycache\", \"tyspline\"]\n\n    def process(self, instance):\n        # TODO: let user decide the param\n        self.log.debug(\"Extracting Tycache...\")\n\n        stagingdir = self.staging_dir(instance)\n\n        export_mode = instance.data.get(\"exportMode\", 2)\n        material_cache = instance.data.get(\"material_cache\")\n        operator = instance.data[\"operator\"]\n        representations = instance.data.setdefault(\"representations\", [])\n        start_frame = instance.data[\"frameStartHandle\"]\n        end_frame = instance.data[\"frameEndHandle\"]\n        product_name = instance.data.get(\"productName\")\n        tyc_fnames = []\n        tyc_mesh_fnames = []\n        with maintained_selection():\n            filename = f\"{product_name}.tyc\"\n            path = os.path.join(stagingdir, filename)\n            filenames = self.get_files(\n                product_name, start_frame, end_frame)\n            self._extract_tyflow_particles(\n                operator, path, export_mode, material_cache)\n            mesh_filename = f\"{product_name}__tyMesh.tyc\"\n            tyc_fnames.extend(filenames)\n            tyc_mesh_fnames.append(mesh_filename)\n        representation = {\n            \"name\": \"tyc\",\n            \"ext\": \"tyc\",\n            \"files\": (\n                tyc_fnames if len(tyc_fnames) &gt; 1\n                else tyc_fnames[0]),\n            \"stagingDir\": stagingdir\n        }\n        representations.append(representation)\n        mesh_repres = {\n            'name': 'tyMesh',\n            'ext': 'tyc',\n            'files': (\n                tyc_mesh_fnames if len(tyc_mesh_fnames) &gt; 1\n                else tyc_mesh_fnames[0]),\n            \"stagingDir\": stagingdir\n        }\n        representations.append(mesh_repres)\n        # Get the material filename of which assigned in\n        # tyCache for extraction\n        material_filename = f\"{product_name}__tyMtl.mat\"\n        full_material_name = os.path.join(stagingdir, material_filename)\n        full_material_name = full_material_name.replace(\"\\\\\", \"/\")\n        if material_cache and os.path.exists(full_material_name):\n            self.log.debug(\"Extracting material along with tycache.\")\n            mateiral_repres = {\n                \"name\": 'tyMtl',\n                \"ext\": 'mat',\n                'files': material_filename,\n                'stagingDir': stagingdir,\n                \"outputName\": '__tyMtl'\n            }\n            representations.append(mateiral_repres)\n        self.log.debug(\n            f\"Extracted instance '{instance.name}' to: {stagingdir}\")\n\n    def get_files(self, product_name, start_frame, end_frame):\n        \"\"\"Get file names for tyFlow in tyCache format.\n\n        Set the filenames accordingly to the tyCache file\n        naming extension(.tyc) for the publishing purpose\n\n        Actual File Output from tyFlow in tyCache format:\n        &lt;InstanceName&gt;_&lt;operator&gt;__tyPart_&lt;frame&gt;.tyc\n\n        e.g. tycacheMain__tyPart_00000.tyc\n\n        Args:\n            product_name (str): product name\n            start_frame (int): frame start\n            end_frame (int): frame end\n\n        Returns:\n            filenames(list): list of filenames\n\n        \"\"\"\n        filenames = []\n        for frame in range(int(start_frame), int(end_frame) + 1):\n            filename = f\"{product_name}__tyPart_{frame:05}.tyc\"\n            filenames.append(filename)\n        return filenames\n\n    def _extract_tyflow_particles(self, operator, filepath,\n                                  export_mode, material_cache):\n        \"\"\"Exports tyCache particle with the necessary export settings\n\n        Args:\n            operators (list): List of Export Particle operator\n            start (int): Start frame.\n            end (int): End frame.\n            filepath (str): Output path of the TyCache file.\n            export_mode (int): Export Mode for the TyCache Output.\n            material_cache (bool): Whether tycache should publish\n                along with material\n\n        \"\"\"\n        if rt.getProperty(operator, \"exportMode\") != export_mode:\n            return\n        export_settings = {\n            \"tycacheCreateObject\": False,\n            \"tycacheCreateObjectIfNotCreated\": False,\n            \"tycacheChanMaterials\": True if material_cache else False,\n            \"tyCacheFilename\": filepath.replace(\"\\\\\", \"/\"),\n        }\n\n        for key, value in export_settings.items():\n            rt.setProperty(operator, key, value)\n        # export tyCache\n        operator.ExportTyCache()\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/extract_tycache.html#client.ayon_max.plugins.publish.extract_tycache.ExtractTyCache.get_files","title":"<code>get_files(product_name, start_frame, end_frame)</code>","text":"<p>Get file names for tyFlow in tyCache format.</p> <p>Set the filenames accordingly to the tyCache file naming extension(.tyc) for the publishing purpose</p> <p>Actual File Output from tyFlow in tyCache format: __tyPart.tyc <p>e.g. tycacheMain__tyPart_00000.tyc</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>product name</p> required <code>start_frame</code> <code>int</code> <p>frame start</p> required <code>end_frame</code> <code>int</code> <p>frame end</p> required <p>Returns:</p> Name Type Description <code>filenames</code> <code>list</code> <p>list of filenames</p> Source code in <code>client/ayon_max/plugins/publish/extract_tycache.py</code> <pre><code>def get_files(self, product_name, start_frame, end_frame):\n    \"\"\"Get file names for tyFlow in tyCache format.\n\n    Set the filenames accordingly to the tyCache file\n    naming extension(.tyc) for the publishing purpose\n\n    Actual File Output from tyFlow in tyCache format:\n    &lt;InstanceName&gt;_&lt;operator&gt;__tyPart_&lt;frame&gt;.tyc\n\n    e.g. tycacheMain__tyPart_00000.tyc\n\n    Args:\n        product_name (str): product name\n        start_frame (int): frame start\n        end_frame (int): frame end\n\n    Returns:\n        filenames(list): list of filenames\n\n    \"\"\"\n    filenames = []\n    for frame in range(int(start_frame), int(end_frame) + 1):\n        filename = f\"{product_name}__tyPart_{frame:05}.tyc\"\n        filenames.append(filename)\n    return filenames\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/increment_workfile_version.html","title":"increment_workfile_version","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/increment_workfile_version.html#client.ayon_max.plugins.publish.increment_workfile_version.IncrementWorkfileVersion","title":"<code>IncrementWorkfileVersion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Increment current workfile version.</p> Source code in <code>client/ayon_max/plugins/publish/increment_workfile_version.py</code> <pre><code>class IncrementWorkfileVersion(pyblish.api.ContextPlugin):\n    \"\"\"Increment current workfile version.\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 0.9\n    label = \"Increment Workfile Version\"\n    hosts = [\"max\"]\n    families = [\"maxrender\", \"workfile\"]\n\n    def process(self, context):\n        path = context.data[\"currentFile\"]\n        try:\n            from ayon_core.pipeline.workfile import save_next_version\n            from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n            current_filename = os.path.basename(path)\n            save_next_version(\n                description=(\n                    f\"Incremented by publishing from {current_filename}\"\n                ),\n                # Optimize the save by reducing needed queries for context\n                prepared_data=SaveWorkfileOptionalData(\n                    project_entity=context.data[\"projectEntity\"],\n                    project_settings=context.data[\"project_settings\"],\n                    anatomy=context.data[\"anatomy\"],\n                )\n            )\n        except ImportError:\n            # Backwards compatibility before ayon-core 1.5.0\n            filepath = version_up(path)\n\n            rt.saveMaxFile(filepath)\n\n        self.log.info(\"Incrementing file version\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/save_scene.html#client.ayon_max.plugins.publish.save_scene.SaveCurrentScene","title":"<code>SaveCurrentScene</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Save current scene</p> Source code in <code>client/ayon_max/plugins/publish/save_scene.py</code> <pre><code>class SaveCurrentScene(pyblish.api.InstancePlugin):\n    \"\"\"Save current scene\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"max\"]\n    families = [\"maxrender\", \"workfile\"]\n\n    def process(self, instance):\n        host = registered_host()\n        current_file = host.get_current_workfile()\n\n        assert instance.context.data[\"currentFile\"] == current_file\n        if instance.data[\"productType\"] == \"maxrender\":\n            host.save_workfile(current_file)\n\n        elif host.workfile_has_unsaved_changes():\n            self.log.info(f\"Saving current file: {current_file}\")\n            host.save_workfile(current_file)\n        else:\n            self.log.debug(\"No unsaved changes, skipping file save..\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/save_scenes_for_cameras.html","title":"save_scenes_for_cameras","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/save_scenes_for_cameras.html#client.ayon_max.plugins.publish.save_scenes_for_cameras.SaveScenesForCamera","title":"<code>SaveScenesForCamera</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Save scene files for multiple cameras without editing the original scene before deadline submission</p> Source code in <code>client/ayon_max/plugins/publish/save_scenes_for_cameras.py</code> <pre><code>class SaveScenesForCamera(pyblish.api.InstancePlugin):\n    \"\"\"Save scene files for multiple cameras without\n    editing the original scene before deadline submission\n\n    \"\"\"\n\n    label = \"Save Scene files for cameras\"\n    order = pyblish.api.ExtractorOrder - 0.48\n    hosts = [\"max\"]\n    families = [\"maxrender\"]\n\n    def process(self, instance):\n        if not instance.data.get(\"multiCamera\"):\n            self.log.debug(\n                \"Multi Camera disabled. \"\n                \"Skipping to save scene files for cameras\")\n            return\n        current_folder = rt.maxFilePath\n        current_filename = rt.maxFileName\n        current_filepath = os.path.join(current_folder, current_filename)\n        camera_scene_files = []\n        scripts = []\n        filename, ext = os.path.splitext(current_filename)\n        fmt = RenderProducts().image_format()\n        cameras = instance.data.get(\"cameras\")\n        if not cameras:\n            return\n        new_folder = f\"{current_folder}_{filename}\"\n        os.makedirs(new_folder, exist_ok=True)\n        for camera in cameras:\n            new_output = RenderSettings().get_batch_render_output(camera)       # noqa\n            new_output = new_output.replace(\"\\\\\", \"/\")\n            camera_name = camera.replace(\":\", \"_\")\n            new_filename = f\"{filename}_{camera_name}{ext}\"\n            new_filepath = os.path.join(new_folder, new_filename)\n            new_filepath = new_filepath.replace(\"\\\\\", \"/\")\n            camera_scene_files.append(new_filepath)\n            RenderSettings().batch_render_elements(camera)\n            rt.rendOutputFilename = new_output\n            rt.saveMaxFile(current_filepath)\n            script = (\"\"\"\nfrom pymxs import runtime as rt\nimport os\nfilename = \"{filename}\"\nnew_filepath = \"{new_filepath}\"\nnew_output = \"{new_output}\"\ncamera = \"{camera}\"\ncamera_name = camera.replace(\":\", \"_\")\ntarget_camera_node = rt.getNodeByName(camera)\nrt.viewport.setCamera(target_camera_node)\nrt.rendOutputFilename = new_output\ndirectory = os.path.dirname(rt.rendOutputFilename)\ndirectory = os.path.join(directory, filename)\nif not os.path.exists(directory):\n    os.mkdir(directory)\nrender_elem = rt.maxOps.GetCurRenderElementMgr()\nrender_elem_num = render_elem.NumRenderElements()\nif render_elem_num &gt; 0:\n    ext = \"{ext}\"\n    for i in range(render_elem_num):\n        renderlayer_name = render_elem.GetRenderElement(i)\n        target, renderpass = str(renderlayer_name).split(\":\")\n        aov_name =  f\"{{directory}}_{{camera_name}}_{{renderpass}}..{ext}\"\n        render_elem.SetRenderElementFileName(i, aov_name)\nrt.saveMaxFile(new_filepath)\n        \"\"\").format(filename=instance.name,\n                    new_filepath=new_filepath,\n                    new_output=new_output,\n                    camera=camera,\n                    ext=fmt)\n            scripts.append(script)\n        maxbatch_exe = os.path.join(\n            os.path.dirname(sys.executable), \"3dsmaxbatch\")\n        maxbatch_exe = maxbatch_exe.replace(\"\\\\\", \"/\")\n        if platform.system().lower() == \"windows\":\n            maxbatch_exe += \".exe\"\n            maxbatch_exe = os.path.normpath(maxbatch_exe)\n        with tempfile.TemporaryDirectory() as tmp_dir_name:\n            tmp_script_path = os.path.join(\n                tmp_dir_name, \"extract_scene_files.py\")\n            self.log.info(\"Using script file: {}\".format(tmp_script_path))\n\n            with open(tmp_script_path, \"wt\") as tmp:\n                for script in scripts:\n                    tmp.write(script + \"\\n\")\n\n            full_script = \"\\n\".join(scripts)\n            self.log.debug(f\"Failed running script {tmp_script_path}:\\n{full_script}\")\n            current_filepath = current_filepath.replace(\"\\\\\", \"/\")\n            tmp_script_path = tmp_script_path.replace(\"\\\\\", \"/\")\n            run_subprocess([maxbatch_exe, tmp_script_path,\n                            \"-sceneFile\", current_filepath],\n                            logger=self.log)\n\n        for camera_scene in camera_scene_files:\n            if not os.path.exists(camera_scene):\n                full_script = \"\\n\".join(scripts)\n                self.log.debug(f\"Failed running script {tmp_script_path}:\\n{full_script}\")\n                self.log.error(\"Camera scene files not existed yet!\")\n                raise RuntimeError(\"MaxBatch.exe doesn't run as expected\")\n            self.log.debug(f\"Found Camera scene:{camera_scene}\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_attributes.html","title":"validate_attributes","text":"<p>Validator for Attributes.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_attributes.html#client.ayon_max.plugins.publish.validate_attributes.ValidateAttributes","title":"<code>ValidateAttributes</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>ContextPlugin</code></p> <p>Validates attributes in the project setting are consistent with the nodes from MaxWrapper Class in 3ds max. E.g. \"renderers.current.separateAovFiles\",      \"renderers.production.PrimaryGIEngine\" Admin(s) need to put the dict below and enable this validator for a check: {    \"renderers.current\":{         \"separateAovFiles\" : True     },     \"renderers.production\":{         \"PrimaryGIEngine\": \"#RS_GIENGINE_BRUTE_FORCE\"     }     .... }</p> Source code in <code>client/ayon_max/plugins/publish/validate_attributes.py</code> <pre><code>class ValidateAttributes(OptionalPyblishPluginMixin,\n                         ContextPlugin):\n    \"\"\"Validates attributes in the project setting are consistent\n    with the nodes from MaxWrapper Class in 3ds max.\n    E.g. \"renderers.current.separateAovFiles\",\n         \"renderers.production.PrimaryGIEngine\"\n    Admin(s) need to put the dict below and enable this validator for a check:\n    {\n       \"renderers.current\":{\n            \"separateAovFiles\" : True\n        },\n        \"renderers.production\":{\n            \"PrimaryGIEngine\": \"#RS_GIENGINE_BRUTE_FORCE\"\n        }\n        ....\n    }\n\n    \"\"\"\n\n    order = ValidatorOrder\n    hosts = [\"max\"]\n    label = \"Attributes\"\n    actions = [RepairContextAction]\n    optional = True\n\n    settings_category = \"max\"\n\n    @classmethod\n    def get_invalid(cls, context):\n        attributes = json.loads(\n            context.data\n            [\"project_settings\"]\n            [\"max\"]\n            [\"publish\"]\n            [\"ValidateAttributes\"]\n            [\"attributes\"]\n        )\n        if not attributes:\n            return\n        invalid = []\n        for object_name, required_properties in attributes.items():\n            if not rt.Execute(f\"isValidValue {object_name}\"):\n                # Skip checking if the node does not\n                # exist in MaxWrapper Class\n                cls.log.debug(f\"Unable to find '{object_name}'.\"\n                              \" Skipping validation of attributes.\")\n                continue\n\n            for property_name, value in required_properties.items():\n                if not has_property(object_name, property_name):\n                    cls.log.error(\n                        \"Non-existing property: \"\n                        f\"{object_name}.{property_name}\")\n                    invalid.append((object_name, property_name))\n\n                if not is_matching_value(object_name, property_name, value):\n                    cls.log.error(\n                        f\"Invalid value for: {object_name}.{property_name}\"\n                        f\" should be: {value}\")\n                    invalid.append((object_name, property_name))\n\n        return invalid\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            self.log.debug(\"Skipping Validate Attributes...\")\n            return\n        invalid_attributes = self.get_invalid(context)\n        if invalid_attributes:\n            bullet_point_invalid_statement = \"\\n\".join(\n                \"- {}\".format(invalid) for invalid\n                in invalid_attributes\n            )\n            report = (\n                \"Required Attribute(s) have invalid value(s).\\n\\n\"\n                f\"{bullet_point_invalid_statement}\\n\\n\"\n                \"You can use repair action to fix them if they are not\\n\"\n                \"unknown property value(s).\"\n            )\n            raise PublishValidationError(\n                report, title=\"Invalid Value(s) for Required Attribute(s)\")\n\n    @classmethod\n    def repair(cls, context):\n        attributes = json.loads(\n            context.data\n            [\"project_settings\"]\n            [\"max\"]\n            [\"publish\"]\n            [\"ValidateAttributes\"]\n            [\"attributes\"]\n        )\n        invalid_attributes = cls.get_invalid(context)\n        for attrs in invalid_attributes:\n            prop, attr = attrs\n            value = attributes[prop][attr]\n            if isinstance(value, str) and not value.startswith(\"#\"):\n                attribute_fix = '{}.{}=\"{}\"'.format(\n                    prop, attr, value\n                )\n            else:\n                attribute_fix = \"{}.{}={}\".format(\n                    prop, attr, value\n                )\n            rt.Execute(attribute_fix)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_attributes.html#client.ayon_max.plugins.publish.validate_attributes.has_property","title":"<code>has_property(object_name, property_name)</code>","text":"<p>Return whether an object has a property with given name</p> Source code in <code>client/ayon_max/plugins/publish/validate_attributes.py</code> <pre><code>def has_property(object_name, property_name):\n    \"\"\"Return whether an object has a property with given name\"\"\"\n    return rt.Execute(f'isProperty {object_name} \"{property_name}\"')\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_attributes.html#client.ayon_max.plugins.publish.validate_attributes.is_matching_value","title":"<code>is_matching_value(object_name, property_name, value)</code>","text":"<p>Return whether an existing property matches value `value</p> Source code in <code>client/ayon_max/plugins/publish/validate_attributes.py</code> <pre><code>def is_matching_value(object_name, property_name, value):\n    \"\"\"Return whether an existing property matches value `value\"\"\"\n    property_value = rt.Execute(f\"{object_name}.{property_name}\")\n\n    # Wrap property value if value is a string valued attributes\n    # starting with a `#`\n    if (\n        isinstance(value, str) and\n        value.startswith(\"#\") and\n        not value.endswith(\")\")\n    ):\n        # prefix value with `#`\n        # not applicable for #() array value type\n        # and only applicable for enum i.e. #bob, #sally\n        property_value = f\"#{property_value}\"\n\n    return property_value == value\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_camera_attributes.html","title":"validate_camera_attributes","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_camera_attributes.html#client.ayon_max.plugins.publish.validate_camera_attributes.ValidateCameraAttributes","title":"<code>ValidateCameraAttributes</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validates Camera has no invalid attribute properties or values.(For 3dsMax Cameras only)</p> Source code in <code>client/ayon_max/plugins/publish/validate_camera_attributes.py</code> <pre><code>class ValidateCameraAttributes(OptionalPyblishPluginMixin,\n                               pyblish.api.InstancePlugin):\n    \"\"\"Validates Camera has no invalid attribute properties\n    or values.(For 3dsMax Cameras only)\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = ['camera']\n    hosts = ['max']\n    label = 'Validate Camera Attributes'\n    actions = [SelectInvalidAction, RepairAction]\n    optional = True\n\n    settings_category = \"max\"\n\n    DEFAULTS = [\"fov\", \"nearrange\", \"farrange\",\n                \"nearclip\", \"farclip\"]\n    CAM_TYPE = [\"Freecamera\", \"Targetcamera\",\n                \"Physical\"]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        if rt.units.DisplayType != rt.Name(\"Generic\"):\n            cls.log.warning(\n                \"Generic Type is not used as a scene unit\\n\\n\"\n                \"sure you tweak the settings with your own values\\n\\n\"\n                \"before validation.\")\n        cameras = instance.data[\"members\"]\n        project_settings = instance.context.data[\"project_settings\"].get(\"max\")\n        cam_attr_settings = (\n            project_settings[\"publish\"][\"ValidateCameraAttributes\"]\n        )\n        for camera in cameras:\n            if str(rt.ClassOf(camera)) not in cls.CAM_TYPE:\n                cls.log.debug(\n                    \"Skipping camera created from external plugin..\")\n                continue\n            for attr in cls.DEFAULTS:\n                default_value = cam_attr_settings.get(attr)\n                if default_value == float(0):\n                    cls.log.debug(\n                        f\"the value of {attr} in setting set to\"\n                        \" zero. Skipping the check.\")\n                    continue\n                if round(rt.getProperty(camera, attr), 1) != default_value:\n                    cls.log.error(\n                        f\"Invalid attribute value for {camera.name}:{attr} \"\n                        f\"(should be: {default_value}))\")\n                    invalid.append(camera)\n\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Camera Attributes.\")\n            return\n        invalid = self.get_invalid(instance)\n\n        if invalid:\n            raise PublishValidationError(\n                \"Invalid camera attributes found. See log.\")\n\n    @classmethod\n    def repair(cls, instance):\n        invalid_cameras = cls.get_invalid(instance)\n        project_settings = instance.context.data[\"project_settings\"].get(\"max\")\n        cam_attr_settings = (\n            project_settings[\"publish\"][\"ValidateCameraAttributes\"]\n        )\n        for camera in invalid_cameras:\n            for attr in cls.DEFAULTS:\n                expected_value = cam_attr_settings.get(attr)\n                if expected_value == float(0):\n                    cls.log.debug(\n                        f\"the value of {attr} in setting set to zero.\")\n                    continue\n                rt.setProperty(camera, attr, expected_value)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_camera_contents.html","title":"validate_camera_contents","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_camera_contents.html#client.ayon_max.plugins.publish.validate_camera_contents.ValidateCameraContent","title":"<code>ValidateCameraContent</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates Camera instance contents.</p> <p>A Camera instance may only hold a SINGLE camera's transform</p> Source code in <code>client/ayon_max/plugins/publish/validate_camera_contents.py</code> <pre><code>class ValidateCameraContent(pyblish.api.InstancePlugin):\n    \"\"\"Validates Camera instance contents.\n\n    A Camera instance may only hold a SINGLE camera's transform\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"camera\", \"review\"]\n    hosts = [\"max\"]\n    label = \"Camera Contents\"\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError((\"Camera instance must only include\"\n                                          \"camera (and camera target). \"\n                                          f\"Invalid content {invalid}\"))\n\n    def get_invalid(self, instance):\n        \"\"\"Get invalid nodes that are not cameras or valid containers.\"\"\"\n        from pymxs import runtime as rt\n\n        container = instance.data[\"instance_node\"]\n        self.log.info(f\"Validating camera content for {container}\")\n\n        invalid = []\n        members = instance.data[\"members\"]\n\n        for member in members:\n            if self._is_valid_member(member, rt):\n                continue\n            invalid.append(member)\n\n        return invalid\n\n    @staticmethod\n    def _is_valid_member(node, rt):\n        \"\"\"Check if a node is a valid camera or container with only cameras.\"\"\"\n        # Direct camera check\n        if rt.classof(node) in rt.Camera.classes:\n            return True\n        # Check if node has children - all must be cameras\n        if hasattr(node, \"children\") and node.children:\n            return all(\n                rt.classof(child) in rt.Camera.classes\n                for child in node.children\n            )\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_camera_contents.html#client.ayon_max.plugins.publish.validate_camera_contents.ValidateCameraContent.get_invalid","title":"<code>get_invalid(instance)</code>","text":"<p>Get invalid nodes that are not cameras or valid containers.</p> Source code in <code>client/ayon_max/plugins/publish/validate_camera_contents.py</code> <pre><code>def get_invalid(self, instance):\n    \"\"\"Get invalid nodes that are not cameras or valid containers.\"\"\"\n    from pymxs import runtime as rt\n\n    container = instance.data[\"instance_node\"]\n    self.log.info(f\"Validating camera content for {container}\")\n\n    invalid = []\n    members = instance.data[\"members\"]\n\n    for member in members:\n        if self._is_valid_member(member, rt):\n            continue\n        invalid.append(member)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_extended_viewport.html","title":"validate_extended_viewport","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_extended_viewport.html#client.ayon_max.plugins.publish.validate_extended_viewport.ValidateExtendedViewport","title":"<code>ValidateExtendedViewport</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Validate if the first viewport is an extended viewport.</p> Source code in <code>client/ayon_max/plugins/publish/validate_extended_viewport.py</code> <pre><code>class ValidateExtendedViewport(pyblish.api.ContextPlugin):\n    \"\"\"Validate if the first viewport is an extended viewport.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"review\"]\n    hosts = [\"max\"]\n    label = \"Validate Extended Viewport\"\n\n    def process(self, context):\n        try:\n            rt.viewport.activeViewportEx(1)\n        except RuntimeError:\n            raise PublishValidationError(\n                \"Please make sure one viewport is not an extended viewport\",\n                description = (\n                        \"Please make sure at least one viewport is not an \"\n                        \"extended viewport but a 3dsmax supported viewport \"\n                        \"i.e camera/persp/orthographic view.\\n\\n\"\n                        \"To rectify it, please go to view in the top menubar, \"\n                        \"go to Views -&gt; Viewports Configuration -&gt; Layout and \"\n                        \"right click on one of the panels to change it.\"\n                ))\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_frame_range.html","title":"validate_frame_range","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_frame_range.html#client.ayon_max.plugins.publish.validate_frame_range.ValidateFrameRange","title":"<code>ValidateFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates the frame ranges.</p> <p>This is an optional validator checking if the frame range on instance matches the frame range specified for the folder.</p> <p>It also validates render frame ranges of render layers.</p> <p>Repair action will change everything to match the folder frame range.</p> <p>This can be turned off by the artist to allow custom ranges.</p> Source code in <code>client/ayon_max/plugins/publish/validate_frame_range.py</code> <pre><code>class ValidateFrameRange(pyblish.api.InstancePlugin,\n                         OptionalPyblishPluginMixin):\n    \"\"\"Validates the frame ranges.\n\n    This is an optional validator checking if the frame range on instance\n    matches the frame range specified for the folder.\n\n    It also validates render frame ranges of render layers.\n\n    Repair action will change everything to match the folder frame range.\n\n    This can be turned off by the artist to allow custom ranges.\n    \"\"\"\n\n    label = \"Validate Frame Range\"\n    order = ValidateContentsOrder\n    families = [\"camera\", \"maxrender\",\n                \"pointcache\", \"pointcloud\",\n                \"review\", \"redshiftproxy\"]\n    hosts = [\"max\"]\n    optional = True\n    actions = [RepairAction]\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Frame Range...\")\n            return\n\n        frame_range = get_frame_range(\n            instance.data[\"taskEntity\"])\n\n        inst_frame_start = instance.data.get(\"frameStartHandle\")\n        inst_frame_end = instance.data.get(\"frameEndHandle\")\n        if inst_frame_start is None or inst_frame_end is None:\n            raise KnownPublishError(\n                \"Missing frame start and frame end on \"\n                \"instance to to validate.\"\n            )\n        frame_start_handle = frame_range[\"frameStartHandle\"]\n        frame_end_handle = frame_range[\"frameEndHandle\"]\n        errors = []\n        if frame_start_handle != inst_frame_start:\n            errors.append(\n                f\"Start frame ({inst_frame_start}) on instance does not match \" # noqa\n                f\"with the start frame ({frame_start_handle}) set on the folder attributes. \")    # noqa\n        if frame_end_handle != inst_frame_end:\n            errors.append(\n                f\"End frame ({inst_frame_end}) on instance does not match \"\n                f\"with the end frame ({frame_end_handle}) \"\n                \"from the folder attributes. \")\n\n        if errors:\n            bullet_point_errors = \"\\n\".join(\n                \"- {}\".format(err) for err in errors\n            )\n            report = (\n                \"Frame range settings are incorrect.\\n\\n\"\n                f\"{bullet_point_errors}\\n\\n\"\n                \"You can use repair action to fix it.\"\n            )\n            raise PublishValidationError(report, title=\"Frame Range incorrect\")\n\n    @classmethod\n    def get_invalid(cls, instance, frameStart, frameEnd):\n        inst_frame_start = instance.data.get(\"frameStartHandle\")\n        inst_frame_end = instance.data.get(\"frameEndHandle\")\n        if inst_frame_start is None or inst_frame_end is None:\n            raise KnownPublishError(\n                \"Missing frame start and frame end on \"\n                \"instance to to validate.\"\n            )\n        invalid = []\n        if frameStart != inst_frame_start:\n            invalid.append(\n                f\"Start frame ({inst_frame_start}) on instance does not match \" # noqa\n                f\"with the start frame ({frameStart}) set on the asset data. \")    # noqa\n        if frameEnd != inst_frame_end:\n            invalid.append(\n                f\"End frame ({inst_frame_end}) on instance does not match \"\n                f\"with the end frame ({frameEnd}) \"\n                \"from the asset data. \")\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        frame_range = get_frame_range()\n        frame_start_handle = frame_range[\"frameStartHandle\"]\n        frame_end_handle = frame_range[\"frameEndHandle\"]\n\n        if instance.data[\"productType\"] == \"maxrender\":\n            rt.rendStart = frame_start_handle\n            rt.rendEnd = frame_end_handle\n        else:\n            set_timeline(frame_start_handle, frame_end_handle)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_instance_has_members.html","title":"validate_instance_has_members","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_instance_has_members.html#client.ayon_max.plugins.publish.validate_instance_has_members.ValidateInstanceHasMembers","title":"<code>ValidateInstanceHasMembers</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates Instance has members.</p> <p>Check if MaxScene containers includes any contents underneath.</p> Source code in <code>client/ayon_max/plugins/publish/validate_instance_has_members.py</code> <pre><code>class ValidateInstanceHasMembers(pyblish.api.InstancePlugin):\n    \"\"\"Validates Instance has members.\n\n    Check if MaxScene containers includes any contents underneath.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"camera\",\n                \"model\",\n                \"maxScene\",\n                \"review\",\n                \"pointcache\",\n                \"pointcloud\",\n                \"redshiftproxy\"]\n    hosts = [\"max\"]\n    label = \"Container Contents\"\n\n    def process(self, instance):\n        if not instance.data[\"members\"]:\n            raise PublishValidationError(\"No content found in the container\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_instance_in_context.html","title":"validate_instance_in_context","text":"<p>Validate if instance context is the same as current context.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_instance_in_context.html#client.ayon_max.plugins.publish.validate_instance_in_context.ValidateInstanceInContext","title":"<code>ValidateInstanceInContext</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validator to check if instance context match current context.</p> <p>When working in per-shot style you always publish data in context of current context (shot). This validator checks if this is so. It is optional so it can be disabled when needed.</p> <p>Action on this validator will select invalid instances.</p> Source code in <code>client/ayon_max/plugins/publish/validate_instance_in_context.py</code> <pre><code>class ValidateInstanceInContext(pyblish.api.InstancePlugin,\n                                OptionalPyblishPluginMixin):\n    \"\"\"Validator to check if instance context match current context.\n\n    When working in per-shot style you always publish data in context of\n    current context (shot). This validator checks if this is so. It is optional\n    so it can be disabled when needed.\n\n    Action on this validator will select invalid instances.\n    \"\"\"\n    order = ValidateContentsOrder\n    label = \"Instance in same Context\"\n    optional = True\n    hosts = [\"max\"]\n    actions = [SelectInvalidAction, RepairAction]\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        folderPath = instance.data.get(\"folderPath\")\n        task = instance.data.get(\"task\")\n        context = self.get_context(instance)\n        if (folderPath, task) != context:\n            context_label = \"{} &gt; {}\".format(*context)\n            instance_label = \"{} &gt; {}\".format(folderPath, task)\n            message = (\n                \"Instance '{}' publishes to different context(folder or task) \"\n                \"than current context: {}. Current context: {}\".format(\n                    instance.name, instance_label, context_label\n                )\n            )\n            raise PublishValidationError(\n                message=message,\n                description=(\n                    \"## Publishing to a different context data(folder or task)\\n\"\n                    \"There are publish instances present which are publishing \"\n                    \"into a different folder path or task than your current context.\\n\\n\"\n                    \"Usually this is not what you want but there can be cases \"\n                    \"where you might want to publish into another context or \"\n                    \"shot. If that's the case you can disable the validation \"\n                    \"on the instance to ignore it.\"\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        invalid = []\n        folderPath = instance.data.get(\"folderPath\")\n        task = instance.data.get(\"task\")\n        context = cls.get_context(instance)\n        if (folderPath, task) != context:\n            invalid.append(rt.getNodeByName(instance.name))\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        context_asset = instance.context.data[\"folderPath\"]\n        context_task = instance.context.data[\"task\"]\n        instance_node = rt.getNodeByName(instance.data.get(\n            \"instance_node\", \"\"))\n        if not instance_node:\n            return\n        rt.SetUserProp(instance_node, \"folderPath\", context_asset)\n        rt.SetUserProp(instance_node, \"task\", context_task)\n\n    @staticmethod\n    def get_context(instance):\n        \"\"\"Return asset, task from publishing context data\"\"\"\n        context = instance.context\n        return context.data[\"folderPath\"], context.data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_instance_in_context.html#client.ayon_max.plugins.publish.validate_instance_in_context.ValidateInstanceInContext.get_context","title":"<code>get_context(instance)</code>  <code>staticmethod</code>","text":"<p>Return asset, task from publishing context data</p> Source code in <code>client/ayon_max/plugins/publish/validate_instance_in_context.py</code> <pre><code>@staticmethod\ndef get_context(instance):\n    \"\"\"Return asset, task from publishing context data\"\"\"\n    context = instance.context\n    return context.data[\"folderPath\"], context.data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_loaded_plugin.html","title":"validate_loaded_plugin","text":"<p>Validator for Loaded Plugin.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_loaded_plugin.html#client.ayon_max.plugins.publish.validate_loaded_plugin.ValidateLoadedPlugin","title":"<code>ValidateLoadedPlugin</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validates if the specific plugin is loaded in 3ds max. Studio Admin(s) can add the plugins they want to check in validation via studio defined project settings</p> Source code in <code>client/ayon_max/plugins/publish/validate_loaded_plugin.py</code> <pre><code>class ValidateLoadedPlugin(OptionalPyblishPluginMixin,\n                           pyblish.api.InstancePlugin):\n    \"\"\"Validates if the specific plugin is loaded in 3ds max.\n    Studio Admin(s) can add the plugins they want to check in validation\n    via studio defined project settings\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"max\"]\n    label = \"Validate Loaded Plugins\"\n    optional = True\n    actions = [RepairAction]\n\n    settings_category = \"max\"\n\n    family_plugins_mapping = []\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        family_plugins_mapping = cls.family_plugins_mapping\n        if not family_plugins_mapping:\n            return\n\n        # Backward compatibility - settings did have 'product_types'\n        if \"product_types\" in family_plugins_mapping:\n            family_plugins_mapping[\"families\"] = family_plugins_mapping.pop(\n                \"product_types\"\n            )\n\n        invalid = []\n        # Find all plug-in requirements for current instance\n        instance_families = {instance.data[\"productType\"]}\n        instance_families.update(instance.data.get(\"families\", []))\n        cls.log.debug(\"Checking plug-in validation \"\n                      f\"for instance families: {instance_families}\")\n        all_required_plugins = set()\n\n        for mapping in family_plugins_mapping:\n            # Check for matching families\n            if not mapping:\n                return\n\n            match_families = {\n                fam.strip() for fam in mapping[\"families\"]\n            }\n            has_match = \"*\" in match_families or match_families.intersection(\n                instance_families)\n\n            if not has_match:\n                continue\n\n            cls.log.debug(\n                f\"Found plug-in family requirements: {match_families}\")\n            required_plugins = [\n                # match lowercase and format with os.environ to allow\n                # plugin names defined by max version, e.g. {3DSMAX_VERSION}\n                plugin.format(**os.environ).lower()\n                for plugin in mapping[\"plugins\"]\n                # ignore empty fields in settings\n                if plugin.strip()\n            ]\n\n            all_required_plugins.update(required_plugins)\n\n        if not all_required_plugins:\n            # Instance has no plug-in requirements\n            return\n\n        # get all DLL loaded plugins in Max and their plugin index\n        available_plugins = {\n            plugin_name.lower(): index for index, plugin_name in enumerate(\n                get_plugins())\n        }\n        # validate the required plug-ins\n        for plugin in sorted(all_required_plugins):\n            plugin_index = available_plugins.get(plugin)\n            if plugin_index is None:\n                debug_msg = (\n                    f\"Plugin {plugin} does not exist\"\n                    \" in 3dsMax Plugin List.\"\n                )\n                invalid.append((plugin, debug_msg))\n                continue\n            if not rt.pluginManager.isPluginDllLoaded(plugin_index):\n                debug_msg = f\"Plugin {plugin} not loaded.\"\n                invalid.append((plugin, debug_msg))\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            self.log.debug(\"Skipping Validate Loaded Plugin...\")\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            bullet_point_invalid_statement = \"\\n\".join(\n                \"- {}\".format(message) for _, message in invalid\n            )\n            report = (\n                \"Required plugins are not loaded.\\n\\n\"\n                f\"{bullet_point_invalid_statement}\\n\\n\"\n                \"You can use repair action to load the plugin.\"\n            )\n            raise PublishValidationError(\n                report, title=\"Missing Required Plugins\")\n\n    @classmethod\n    def repair(cls, instance):\n        # get all DLL loaded plugins in Max and their plugin index\n        invalid = cls.get_invalid(instance)\n        if not invalid:\n            return\n\n        # get all DLL loaded plugins in Max and their plugin index\n        available_plugins = {\n            plugin_name.lower(): index for index, plugin_name in enumerate(\n                get_plugins())\n        }\n\n        for invalid_plugin, _ in invalid:\n            plugin_index = available_plugins.get(invalid_plugin)\n\n            if plugin_index is None:\n                cls.log.warning(\n                    f\"Can't enable missing plugin: {invalid_plugin}\")\n                continue\n\n            if not rt.pluginManager.isPluginDllLoaded(plugin_index):\n                rt.pluginManager.loadPluginDll(plugin_index)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_loaded_plugin.html#client.ayon_max.plugins.publish.validate_loaded_plugin.ValidateLoadedPlugin.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_max/plugins/publish/validate_loaded_plugin.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    family_plugins_mapping = cls.family_plugins_mapping\n    if not family_plugins_mapping:\n        return\n\n    # Backward compatibility - settings did have 'product_types'\n    if \"product_types\" in family_plugins_mapping:\n        family_plugins_mapping[\"families\"] = family_plugins_mapping.pop(\n            \"product_types\"\n        )\n\n    invalid = []\n    # Find all plug-in requirements for current instance\n    instance_families = {instance.data[\"productType\"]}\n    instance_families.update(instance.data.get(\"families\", []))\n    cls.log.debug(\"Checking plug-in validation \"\n                  f\"for instance families: {instance_families}\")\n    all_required_plugins = set()\n\n    for mapping in family_plugins_mapping:\n        # Check for matching families\n        if not mapping:\n            return\n\n        match_families = {\n            fam.strip() for fam in mapping[\"families\"]\n        }\n        has_match = \"*\" in match_families or match_families.intersection(\n            instance_families)\n\n        if not has_match:\n            continue\n\n        cls.log.debug(\n            f\"Found plug-in family requirements: {match_families}\")\n        required_plugins = [\n            # match lowercase and format with os.environ to allow\n            # plugin names defined by max version, e.g. {3DSMAX_VERSION}\n            plugin.format(**os.environ).lower()\n            for plugin in mapping[\"plugins\"]\n            # ignore empty fields in settings\n            if plugin.strip()\n        ]\n\n        all_required_plugins.update(required_plugins)\n\n    if not all_required_plugins:\n        # Instance has no plug-in requirements\n        return\n\n    # get all DLL loaded plugins in Max and their plugin index\n    available_plugins = {\n        plugin_name.lower(): index for index, plugin_name in enumerate(\n            get_plugins())\n    }\n    # validate the required plug-ins\n    for plugin in sorted(all_required_plugins):\n        plugin_index = available_plugins.get(plugin)\n        if plugin_index is None:\n            debug_msg = (\n                f\"Plugin {plugin} does not exist\"\n                \" in 3dsMax Plugin List.\"\n            )\n            invalid.append((plugin, debug_msg))\n            continue\n        if not rt.pluginManager.isPluginDllLoaded(plugin_index):\n            debug_msg = f\"Plugin {plugin} not loaded.\"\n            invalid.append((plugin, debug_msg))\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_mesh_has_uv.html","title":"validate_mesh_has_uv","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_mesh_has_uv.html#client.ayon_max.plugins.publish.validate_mesh_has_uv.ValidateMeshHasUVs","title":"<code>ValidateMeshHasUVs</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the current mesh has UVs.</p> <p>This validator only checks if the mesh has UVs but not whether all the individual faces of the mesh have UVs.</p> <p>It validates whether the current mesh has texture vertices. If the mesh does not have texture vertices, it does not have UVs in Max.</p> Source code in <code>client/ayon_max/plugins/publish/validate_mesh_has_uv.py</code> <pre><code>class ValidateMeshHasUVs(pyblish.api.InstancePlugin,\n                         OptionalPyblishPluginMixin):\n\n    \"\"\"Validate the current mesh has UVs.\n\n    This validator only checks if the mesh has UVs but not\n    whether all the individual faces of the mesh have UVs.\n\n    It validates whether the current mesh has texture vertices.\n    If the mesh does not have texture vertices, it does not\n    have UVs in Max.\n\n    \"\"\"\n\n    order = ValidateMeshOrder\n    hosts = ['max']\n    families = ['model']\n    label = 'Validate Mesh Has UVs'\n    actions = [SelectInvalidAction]\n    optional = True\n\n    settings_category = \"max\"\n\n    @classmethod\n    def get_invalid(cls, instance):\n        meshes = [member for member in instance.data[\"members\"]\n                  if rt.isProperty(member, \"mesh\")]\n        invalid = [member for member in meshes\n                   if member.mesh.numTVerts == 0]\n        return invalid\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            bullet_point_invalid_statement = \"\\n\".join(\n                \"- {}\".format(invalid.name) for invalid\n                in invalid\n            )\n            report = (\n                \"Model meshes are required to have UVs.\\n\\n\"\n                \"Meshes detected with invalid or missing UVs:\\n\"\n                f\"{bullet_point_invalid_statement}\\n\"\n            )\n            raise PublishValidationError(\n                report,\n                description=(\n                \"Model meshes are required to have UVs.\\n\\n\"\n                \"Meshes detected with no texture vertice or missing UVs\"),\n                title=\"Non-mesh objects found or mesh has missing UVs\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_model_contents.html","title":"validate_model_contents","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_model_contents.html#client.ayon_max.plugins.publish.validate_model_contents.ValidateModelContent","title":"<code>ValidateModelContent</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates Model instance contents.</p> <p>A model instance may only hold either geometry-related object(excluding Shapes) or editable meshes.</p> Source code in <code>client/ayon_max/plugins/publish/validate_model_contents.py</code> <pre><code>class ValidateModelContent(pyblish.api.InstancePlugin):\n    \"\"\"Validates Model instance contents.\n\n    A model instance may only hold either geometry-related\n    object(excluding Shapes) or editable meshes.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"model\"]\n    hosts = [\"max\"]\n    label = \"Model Contents\"\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError((\"Model instance must only include\"\n                                          \"Geometry and Editable Mesh. \"\n                                          f\"Invalid types on: {invalid}\"))\n\n    def get_invalid(self, instance):\n        \"\"\"\n        Get invalid nodes if the instance is not camera\n        \"\"\"\n        invalid = []\n        container = instance.data[\"instance_node\"]\n        self.log.info(f\"Validating model content for {container}\")\n\n        selection_list = instance.data[\"members\"]\n        for sel in selection_list:\n            if rt.ClassOf(sel) in rt.Camera.classes:\n                invalid.append(sel)\n            if rt.ClassOf(sel) in rt.Light.classes:\n                invalid.append(sel)\n            if rt.ClassOf(sel) in rt.Shape.classes:\n                invalid.append(sel)\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_model_contents.html#client.ayon_max.plugins.publish.validate_model_contents.ValidateModelContent.get_invalid","title":"<code>get_invalid(instance)</code>","text":"<p>Get invalid nodes if the instance is not camera</p> Source code in <code>client/ayon_max/plugins/publish/validate_model_contents.py</code> <pre><code>def get_invalid(self, instance):\n    \"\"\"\n    Get invalid nodes if the instance is not camera\n    \"\"\"\n    invalid = []\n    container = instance.data[\"instance_node\"]\n    self.log.info(f\"Validating model content for {container}\")\n\n    selection_list = instance.data[\"members\"]\n    for sel in selection_list:\n        if rt.ClassOf(sel) in rt.Camera.classes:\n            invalid.append(sel)\n        if rt.ClassOf(sel) in rt.Light.classes:\n            invalid.append(sel)\n        if rt.ClassOf(sel) in rt.Shape.classes:\n            invalid.append(sel)\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_model_name.html","title":"validate_model_name","text":"<p>Validate model nodes names.</p>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_model_name.html#client.ayon_max.plugins.publish.validate_model_name.ValidateModelName","title":"<code>ValidateModelName</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate Model Name.</p> <p>Validation regex is <code>(.*)_(?P&lt;subset&gt;.*)_(GEO)</code> by default. The setting supports the following regex group name:     - project     - asset     - subset</p> <p>Examples:</p> <p><code>{SOME_RANDOM_NAME}_{YOUR_SUBSET_NAME}_GEO</code> should be your default model name. The regex of <code>(?P&lt;subset&gt;.*)</code> can be replaced by <code>(?P&lt;asset&gt;.*)</code> and <code>(?P&lt;project&gt;.*)</code>. <code>(.*)_(?P&lt;asset&gt;.*)_(GEO)</code> check if your model name is <code>{SOME_RANDOM_NAME}_{CURRENT_ASSET_NAME}_GEO</code> <code>(.*)_(?P&lt;project&gt;.*)_(GEO)</code> check if your model name is <code>{SOME_RANDOM_NAME}_{CURRENT_PROJECT_NAME}_GEO</code></p> Source code in <code>client/ayon_max/plugins/publish/validate_model_name.py</code> <pre><code>class ValidateModelName(pyblish.api.InstancePlugin,\n                        OptionalPyblishPluginMixin):\n    \"\"\"Validate Model Name.\n\n    Validation regex is `(.*)_(?P&lt;subset&gt;.*)_(GEO)` by default.\n    The setting supports the following regex group name:\n        - project\n        - asset\n        - subset\n\n    Examples:\n    \t`{SOME_RANDOM_NAME}_{YOUR_SUBSET_NAME}_GEO` should be your\n        default model name.\n    \tThe regex of `(?P&lt;subset&gt;.*)` can be replaced by `(?P&lt;asset&gt;.*)`\n    \tand `(?P&lt;project&gt;.*)`.\n        `(.*)_(?P&lt;asset&gt;.*)_(GEO)` check if your model name is\n        `{SOME_RANDOM_NAME}_{CURRENT_ASSET_NAME}_GEO`\n        `(.*)_(?P&lt;project&gt;.*)_(GEO)` check if your model name is\n        `{SOME_RANDOM_NAME}_{CURRENT_PROJECT_NAME}_GEO`\n\n    \"\"\"\n    optional = True\n    order = ValidateContentsOrder\n    hosts = [\"max\"]\n    families = [\"model\"]\n    label = \"Validate Model Name\"\n    actions = [SelectInvalidAction]\n\n    settings_category = \"max\"\n\n    # defined by settings\n    regex = r\"(.*)_(?P&lt;subset&gt;.*)_(GEO)\"\n    # cache\n    regex_compiled = None\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            names = \"\\n\".join(\n                \"- {}\".format(node.name) for node in invalid\n            )\n            raise PublishXmlValidationError(\n                plugin=self,\n                message=\"Nodes found with invalid model names: {}\".format(invalid),\n                formatting_data={\"nodes\": names}\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        if not cls.regex:\n            cls.log.warning(\"No regex pattern set. Nothing to validate.\")\n            return\n\n        members = instance.data.get(\"members\")\n        if not members:\n            cls.log.error(\"No members found in the instance.\")\n            return\n\n        cls.regex_compiled = re.compile(cls.regex)\n\n        invalid = []\n        for obj in members:\n            if cls.invalid_name(instance, obj):\n                invalid.append(obj)\n        return invalid\n\n    @classmethod\n    def invalid_name(cls, instance, obj):\n        \"\"\"Function to check the object has invalid name\n        regarding to the validation regex in the AYON setttings\n\n        Args:\n            instance (pyblish.api.instance): Instance\n            obj (str): object name\n\n        Returns:\n            str: invalid object\n        \"\"\"\n        regex = cls.regex_compiled\n        name = obj.name\n        match = regex.match(name)\n\n        if match is None:\n            cls.log.error(\"Invalid model name on: %s\", name)\n            cls.log.error(\"Name doesn't match regex {}\".format(regex.pattern))\n            return obj\n\n        # Validate regex groups\n        invalid = False\n        compare = {\n            \"project\": instance.context.data[\"projectName\"],\n            \"asset\": instance.data[\"folderPath\"],\n            \"subset\": instance.data[\"productName\"]\n        }\n        for key, required_value in compare.items():\n            if key in regex.groupindex:\n                if match.group(key) != required_value:\n                    cls.log.error(\n                        \"Invalid %s name for the model %s, \"\n                        \"required name is %s\",\n                        key, name, required_value\n                    )\n                    invalid = True\n\n        if invalid:\n            return obj\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_model_name.html#client.ayon_max.plugins.publish.validate_model_name.ValidateModelName.invalid_name","title":"<code>invalid_name(instance, obj)</code>  <code>classmethod</code>","text":"<p>Function to check the object has invalid name regarding to the validation regex in the AYON setttings</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>instance</code> <p>Instance</p> required <code>obj</code> <code>str</code> <p>object name</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>invalid object</p> Source code in <code>client/ayon_max/plugins/publish/validate_model_name.py</code> <pre><code>@classmethod\ndef invalid_name(cls, instance, obj):\n    \"\"\"Function to check the object has invalid name\n    regarding to the validation regex in the AYON setttings\n\n    Args:\n        instance (pyblish.api.instance): Instance\n        obj (str): object name\n\n    Returns:\n        str: invalid object\n    \"\"\"\n    regex = cls.regex_compiled\n    name = obj.name\n    match = regex.match(name)\n\n    if match is None:\n        cls.log.error(\"Invalid model name on: %s\", name)\n        cls.log.error(\"Name doesn't match regex {}\".format(regex.pattern))\n        return obj\n\n    # Validate regex groups\n    invalid = False\n    compare = {\n        \"project\": instance.context.data[\"projectName\"],\n        \"asset\": instance.data[\"folderPath\"],\n        \"subset\": instance.data[\"productName\"]\n    }\n    for key, required_value in compare.items():\n        if key in regex.groupindex:\n            if match.group(key) != required_value:\n                cls.log.error(\n                    \"Invalid %s name for the model %s, \"\n                    \"required name is %s\",\n                    key, name, required_value\n                )\n                invalid = True\n\n    if invalid:\n        return obj\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_no_animation.html","title":"validate_no_animation","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_no_animation.html#client.ayon_max.plugins.publish.validate_no_animation.ValidateNoAnimation","title":"<code>ValidateNoAnimation</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates No Animation</p> <p>Ensure no keyframes on nodes in the Instance</p> Source code in <code>client/ayon_max/plugins/publish/validate_no_animation.py</code> <pre><code>class ValidateNoAnimation(pyblish.api.InstancePlugin,\n                          OptionalPyblishPluginMixin):\n    \"\"\"Validates No Animation\n\n    Ensure no keyframes on nodes in the Instance\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"model\"]\n    hosts = [\"max\"]\n    optional = True\n    label = \"Validate No Animation\"\n    actions = [SelectInvalidAction]\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Keyframes found on:\\n\\n{0}\".format(invalid)\n                ,\n                title=\"Keyframes on model\"\n            )\n\n    @staticmethod\n    def get_invalid(instance):\n        \"\"\"Get invalid object(s) which have keyframe(s)\n\n\n        Args:\n            instance (pyblish.api.instance): Instance\n\n        Returns:\n            list: list of invalid objects\n        \"\"\"\n        invalid = [invalid for invalid in instance.data[\"members\"]\n                   if invalid.isAnimated or get_invalid_keys(invalid)]\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_no_animation.html#client.ayon_max.plugins.publish.validate_no_animation.ValidateNoAnimation.get_invalid","title":"<code>get_invalid(instance)</code>  <code>staticmethod</code>","text":"<p>Get invalid object(s) which have keyframe(s)</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>instance</code> <p>Instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of invalid objects</p> Source code in <code>client/ayon_max/plugins/publish/validate_no_animation.py</code> <pre><code>@staticmethod\ndef get_invalid(instance):\n    \"\"\"Get invalid object(s) which have keyframe(s)\n\n\n    Args:\n        instance (pyblish.api.instance): Instance\n\n    Returns:\n        list: list of invalid objects\n    \"\"\"\n    invalid = [invalid for invalid in instance.data[\"members\"]\n               if invalid.isAnimated or get_invalid_keys(invalid)]\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_no_animation.html#client.ayon_max.plugins.publish.validate_no_animation.get_invalid_keys","title":"<code>get_invalid_keys(obj)</code>","text":"<p>function to check on whether there is keyframe in</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str</code> <p>object needed to check if there is a keyframe</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>whether invalid object(s) exist</p> Source code in <code>client/ayon_max/plugins/publish/validate_no_animation.py</code> <pre><code>def get_invalid_keys(obj):\n    \"\"\"function to check on whether there is keyframe in\n\n    Args:\n        obj (str): object needed to check if there is a keyframe\n\n    Returns:\n        bool: whether invalid object(s) exist\n    \"\"\"\n    for transform in [\"Position\", \"Rotation\", \"Scale\"]:\n        num_of_key = rt.NumKeys(rt.getPropertyController(\n            obj.controller, transform))\n        if num_of_key &gt; 0:\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_pointcloud.html","title":"validate_pointcloud","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_pointcloud.html#client.ayon_max.plugins.publish.validate_pointcloud.ValidatePointCloud","title":"<code>ValidatePointCloud</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate that work file was saved.</p> Source code in <code>client/ayon_max/plugins/publish/validate_pointcloud.py</code> <pre><code>class ValidatePointCloud(pyblish.api.InstancePlugin):\n    \"\"\"Validate that work file was saved.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"pointcloud\"]\n    hosts = [\"max\"]\n    label = \"Validate Point Cloud\"\n\n    def process(self, instance):\n        \"\"\"\n        Notes:\n            1. Validate if the export mode of Export Particle is at PRT format\n            2. Validate the partition count and range set as default value\n                Partition Count : 100\n                Partition Range : 1 to 1\n            3. Validate if the custom attribute(s) exist as parameter(s)\n                of export_particle operator\n\n        \"\"\"\n        report = []\n\n        if self.validate_export_mode(instance):\n            report.append(\"The export mode is not at PRT\")\n\n        if self.validate_partition_value(instance):\n            report.append((\"tyFlow Partition setting is \"\n                           \"not at the default value\"))\n\n        invalid_attribute = self.validate_custom_attribute(instance)\n        if invalid_attribute:\n            report.append((\"Custom Attribute not found \"\n                           f\":{invalid_attribute}\"))\n\n        if report:\n            raise PublishValidationError(f\"{report}\")\n\n    def validate_custom_attribute(self, instance):\n        invalid = []\n        container = instance.data[\"instance_node\"]\n        self.log.info(\n            f\"Validating tyFlow custom attributes for {container}\")\n\n        selection_list = instance.data[\"members\"]\n\n        project_settings = instance.context.data[\"project_settings\"]\n        attr_settings = project_settings[\"max\"][\"PointCloud\"][\"attribute\"]\n        for sel in selection_list:\n            obj = sel.baseobject\n            anim_names = rt.GetSubAnimNames(obj)\n            for anim_name in anim_names:\n                # get all the names of the related tyFlow nodes\n                sub_anim = rt.GetSubAnim(obj, anim_name)\n                if rt.IsProperty(sub_anim, \"Export_Particles\"):\n                    event_name = sub_anim.name\n                    opt = \"${0}.{1}.export_particles\".format(sel.name,\n                                                             event_name)\n                    for attr in attr_settings:\n                        key = attr[\"name\"]\n                        value = attr[\"value\"]\n                        custom_attr = \"{0}.PRTChannels_{1}\".format(opt,\n                                                                   value)\n                        try:\n                            rt.Execute(custom_attr)\n                        except RuntimeError:\n                            invalid.append(key)\n\n        return invalid\n\n    def validate_partition_value(self, instance):\n        invalid = []\n        container = instance.data[\"instance_node\"]\n        self.log.info(\n            f\"Validating tyFlow partition value for {container}\")\n\n        selection_list = instance.data[\"members\"]\n        for sel in selection_list:\n            obj = sel.baseobject\n            anim_names = rt.GetSubAnimNames(obj)\n            for anim_name in anim_names:\n                # get all the names of the related tyFlow nodes\n                sub_anim = rt.GetSubAnim(obj, anim_name)\n                if rt.IsProperty(sub_anim, \"Export_Particles\"):\n                    event_name = sub_anim.name\n                    opt = \"${0}.{1}.export_particles\".format(sel.name,\n                                                             event_name)\n                    count = rt.Execute(f'{opt}.PRTPartitionsCount')\n                    if count != 100:\n                        invalid.append(count)\n                    start = rt.Execute(f'{opt}.PRTPartitionsFrom')\n                    if start != 1:\n                        invalid.append(start)\n                    end = rt.Execute(f'{opt}.PRTPartitionsTo')\n                    if end != 1:\n                        invalid.append(end)\n\n        return invalid\n\n    def validate_export_mode(self, instance):\n        invalid = []\n        container = instance.data[\"instance_node\"]\n        self.log.info(\n            f\"Validating tyFlow export mode for {container}\")\n\n        con = rt.GetNodeByName(container)\n        selection_list = list(con.Children)\n        for sel in selection_list:\n            obj = sel.baseobject\n            anim_names = rt.GetSubAnimNames(obj)\n            for anim_name in anim_names:\n                # get all the names of the related tyFlow nodes\n                sub_anim = rt.GetSubAnim(obj, anim_name)\n                # check if there is export particle operator\n                boolean = rt.IsProperty(sub_anim, \"Export_Particles\")\n                event_name = sub_anim.name\n                if boolean:\n                    opt = f\"${sel.name}.{event_name}.export_particles\"\n                    export_mode = rt.Execute(f'{opt}.exportMode')\n                    if export_mode != 1:\n                        invalid.append(export_mode)\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_pointcloud.html#client.ayon_max.plugins.publish.validate_pointcloud.ValidatePointCloud.process","title":"<code>process(instance)</code>","text":"Notes <ol> <li>Validate if the export mode of Export Particle is at PRT format</li> <li>Validate the partition count and range set as default value     Partition Count : 100     Partition Range : 1 to 1</li> <li>Validate if the custom attribute(s) exist as parameter(s)     of export_particle operator</li> </ol> Source code in <code>client/ayon_max/plugins/publish/validate_pointcloud.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Notes:\n        1. Validate if the export mode of Export Particle is at PRT format\n        2. Validate the partition count and range set as default value\n            Partition Count : 100\n            Partition Range : 1 to 1\n        3. Validate if the custom attribute(s) exist as parameter(s)\n            of export_particle operator\n\n    \"\"\"\n    report = []\n\n    if self.validate_export_mode(instance):\n        report.append(\"The export mode is not at PRT\")\n\n    if self.validate_partition_value(instance):\n        report.append((\"tyFlow Partition setting is \"\n                       \"not at the default value\"))\n\n    invalid_attribute = self.validate_custom_attribute(instance)\n    if invalid_attribute:\n        report.append((\"Custom Attribute not found \"\n                       f\":{invalid_attribute}\"))\n\n    if report:\n        raise PublishValidationError(f\"{report}\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderable_camera.html","title":"validate_renderable_camera","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderable_camera.html#client.ayon_max.plugins.publish.validate_renderable_camera.ValidateRenderableCamera","title":"<code>ValidateRenderableCamera</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validates Renderable Camera</p> <p>Check if the renderable camera used for rendering</p> Source code in <code>client/ayon_max/plugins/publish/validate_renderable_camera.py</code> <pre><code>class ValidateRenderableCamera(pyblish.api.InstancePlugin,\n                               OptionalPyblishPluginMixin):\n    \"\"\"Validates Renderable Camera\n\n    Check if the renderable camera used for rendering\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"maxrender\"]\n    hosts = [\"max\"]\n    label = \"Renderable Camera\"\n    optional = True\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        if not instance.data[\"cameras\"]:\n            raise PublishValidationError(\n                \"No renderable Camera found in scene.\"\n            )\n\n    @classmethod\n    def repair(cls, instance):\n\n        rt.viewport.setType(rt.Name(\"view_camera\"))\n        camera = rt.viewport.GetCamera()\n        cls.log.info(f\"Camera {camera} set as renderable camera\")\n        renderer_class = get_current_renderer()\n        renderer = str(renderer_class).split(\":\")[0]\n        if renderer == \"Arnold\":\n            arv = rt.MAXToAOps.ArnoldRenderView()\n            arv.setOption(\"Camera\", str(camera))\n            arv.close()\n        instance.data[\"cameras\"] = [camera.name]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderer_redshift_proxy.html","title":"validate_renderer_redshift_proxy","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderer_redshift_proxy.html#client.ayon_max.plugins.publish.validate_renderer_redshift_proxy.ValidateRendererRedshiftProxy","title":"<code>ValidateRendererRedshiftProxy</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates Redshift as the current renderer for creating Redshift Proxy</p> Source code in <code>client/ayon_max/plugins/publish/validate_renderer_redshift_proxy.py</code> <pre><code>class ValidateRendererRedshiftProxy(pyblish.api.InstancePlugin):\n    \"\"\"\n    Validates Redshift as the current renderer for creating\n    Redshift Proxy\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"redshiftproxy\"]\n    hosts = [\"max\"]\n    label = \"Redshift Renderer\"\n    actions = [RepairAction]\n\n    def process(self, instance):\n        invalid = self.get_redshift_renderer(instance)\n        if invalid:\n            raise PublishValidationError(\"Please install Redshift for 3dsMax\"\n                                         \" before using the Redshift proxy instance\")   # noqa\n        invalid = self.get_current_renderer(instance)\n        if invalid:\n            raise PublishValidationError(\"The Redshift proxy extraction\"\n                                         \"discontinued since the current renderer is not Redshift\")  # noqa\n\n    def get_redshift_renderer(self, instance):\n        invalid = list()\n        max_renderers_list = str(rt.RendererClass.classes)\n        if \"Redshift_Renderer\" not in max_renderers_list:\n            invalid.append(max_renderers_list)\n\n        return invalid\n\n    def get_current_renderer(self, instance):\n        invalid = list()\n        renderer_class = get_current_renderer()\n        current_renderer = str(renderer_class).split(\":\")[0]\n        if current_renderer != \"Redshift_Renderer\":\n            invalid.append(current_renderer)\n\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        for Renderer in rt.RendererClass.classes:\n            renderer = Renderer()\n            if \"Redshift_Renderer\" in str(renderer):\n                rt.renderers.production = renderer\n                break\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderpasses.html","title":"validate_renderpasses","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderpasses.html#client.ayon_max.plugins.publish.validate_renderpasses.ValidateRenderPasses","title":"<code>ValidateRenderPasses</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Validates Render Passes before farm submission</p> Source code in <code>client/ayon_max/plugins/publish/validate_renderpasses.py</code> <pre><code>class ValidateRenderPasses(OptionalPyblishPluginMixin,\n                           pyblish.api.InstancePlugin):\n    \"\"\"Validates Render Passes before farm submission\n    \"\"\"\n\n    order = ValidateContentsOrder\n    families = [\"maxrender\"]\n    hosts = [\"max\"]\n    label = \"Validate Render Passes\"\n    actions = [RepairAction]\n\n    settings_category = \"max\"\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            bullet_point_invalid_statement = \"\\n\".join(\n                f\"- {err_type}: {filepath}\" for err_type, filepath\n                in invalid\n            )\n            report = (\n                \"Invalid render passes found.\\n\\n\"\n                f\"{bullet_point_invalid_statement}\\n\\n\"\n                \"You can use repair action to fix the invalid filepath.\"\n            )\n            raise PublishValidationError(\n                report, title=\"Invalid Render Passes\")\n\n    @classmethod\n    def get_invalid(cls, instance):\n        \"\"\"Function to get invalid beauty render outputs and\n        render elements.\n\n        1. Check Render Output Folder matches the name of\n           the current Max Scene, e.g.\n             The name of the current Max scene:\n               John_Doe.max\n             The expected render output directory:\n               {root[work]}/{project[name]}/{hierarchy}/{asset}/\n               work/{task[name]}/render/3dsmax/John_Doe/\n\n        2. Check image extension(s) of the render output(s)\n           matches the image format in OP/AYON setting, e.g.\n               The current image format in settings: png\n               The expected render outputs: John_Doe.png\n\n        3. Check filename of render element ends with the name of\n           render element from the 3dsMax Render Element Manager.\n           e.g. The name of render element: RsCryptomatte\n            The expected filename: {InstanceName}_RsCryptomatte.png\n\n        Args:\n            instance (pyblish.api.Instance): instance\n            workfile_name (str): filename of the Max scene\n\n        Returns:\n            list: list of invalid filename which doesn't match\n                with the project name\n        \"\"\"\n        invalid = []\n        project_settings = instance.context.data[\"project_settings\"]\n        default_render_folder = Path(\n            get_default_render_folder(project_settings)\n        )\n        render_output = Path(rt.rendOutputFilename)\n        render_dir = render_output.parent\n        if default_render_folder != render_dir.parent:\n            invalid.append((\"Invalid render output folder\",\n                            os.path.dirname(rt.rendOutputFilename)))\n\n        renderer = instance.data[\"renderer\"]\n        beauty_fname = render_output.name\n        beauty_name, ext = os.path.splitext(beauty_fname)\n        invalid_filenames = cls.get_invalid_filenames(\n            instance, beauty_name, ext)\n        invalid.extend(invalid_filenames)\n        invalid_image_format = cls.get_invalid_image_format(\n            instance, ext.lstrip(\".\"))\n        invalid.extend(invalid_image_format)\n        if is_supported_renderer(renderer):\n            render_elem = rt.maxOps.GetCurRenderElementMgr()\n            render_elem_num = render_elem.NumRenderElements()\n            for i in range(render_elem_num):\n                renderlayer_name = render_elem.GetRenderElement(i)\n                renderpass = str(renderlayer_name).rsplit(\":\", 1)[-1]\n                rend_file = render_elem.GetRenderElementFilename(i)\n                if not rend_file:\n                    continue\n                render_filename = os.path.basename(rend_file)\n                rend_fname, ext = os.path.splitext(render_filename)\n                invalid_image_format = cls.get_invalid_image_format(\n                    instance, ext)\n                invalid_filenames = cls.get_invalid_filenames(\n                    instance, rend_fname, ext, renderpass=renderpass,\n                    render_filename=render_filename)\n                invalid.extend(invalid_filenames)\n                invalid.extend(invalid_image_format)\n\n        elif renderer == \"Arnold\":\n            cls.log.debug(\n                \"Renderpass validation does not support Arnold yet,\"\n                \" validation skipped...\")\n        elif renderer.startswith(\"V-Ray\"):\n            cls.log.debug(\n                \"Renderpass validation does not support V-Ray.\"\n                \" As V-Ray Frame Buffer takes care of this.\"\n            )\n        else:\n            cls.log.debug(\n                \"Skipping render element validation \"\n                f\"for renderer: {renderer}\")\n        return invalid\n\n    @classmethod\n    def get_invalid_filenames(\n        cls, instance, file_name,\n        ext, renderpass=None,\n        render_filename=None):\n        \"\"\"Function to get invalid filenames from render outputs.\n\n        Args:\n            instance (pyblish.api.Instance): instance\n            file_name (str): name of the file\n            ext (str): image extension\n            renderpass (str, optional): name of the renderpass.\n                Defaults to None.\n            render_filename(str, optional): render filename\n\n        Returns:\n            list: invalid filenames\n        \"\"\"\n        invalid = []\n        if instance.name not in file_name:\n            cls.log.error(\"The renderpass filename should contain the instance name.\")\n            invalid.append((\"Invalid instance name\",\n                            file_name))\n        if renderpass is not None and render_filename is not None:\n            renderpass_token = f\"{renderpass}.{ext}\"\n            if not render_filename.endswith(renderpass_token):\n                cls.log.error(f\"{render_filename}: {renderpass_token}\")\n                cls.log.error(\n                    f\"Filename for {renderpass} should \"\n                    f\"end with {renderpass}: {render_filename}\"\n                )\n                invalid.append((f\"Invalid {renderpass}\",\n                                render_filename))\n        return invalid\n\n    @classmethod\n    def get_invalid_image_format(cls, instance, ext):\n        \"\"\"Function to check if the image format of the render outputs\n        aligns with that in the setting.\n\n        Args:\n            instance (pyblish.api.Instance): instance\n            ext (str): image extension\n\n        Returns:\n            list: list of files with invalid image format\n        \"\"\"\n        invalid = []\n        settings = instance.context.data[\"project_settings\"].get(\"max\")\n        image_format = settings[\"RenderSettings\"][\"image_format\"]\n        ext = ext.lstrip(\".\")\n        if ext != image_format:\n            msg = (\n                f\"Invalid image format {ext} for render outputs.\\n\"\n                f\"Should be: {image_format}\")\n            cls.log.error(msg)\n            invalid.append((msg, ext))\n        return invalid\n\n    @classmethod\n    def repair(cls, instance):\n        container = instance.data.get(\"instance_node\")\n        # TODO: need to rename the function of render_output\n        RenderSettings().render_output(container)\n        cls.log.debug(\"Finished repairing the render output \"\n                      \"folder and filenames.\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderpasses.html#client.ayon_max.plugins.publish.validate_renderpasses.ValidateRenderPasses.get_invalid","title":"<code>get_invalid(instance)</code>  <code>classmethod</code>","text":"<p>Function to get invalid beauty render outputs and render elements.</p> <ol> <li> <p>Check Render Output Folder matches the name of    the current Max Scene, e.g.      The name of the current Max scene:        John_Doe.max      The expected render output directory:        {root[work]}/{project[name]}/{hierarchy}/{asset}/        work/{task[name]}/render/3dsmax/John_Doe/</p> </li> <li> <p>Check image extension(s) of the render output(s)    matches the image format in OP/AYON setting, e.g.        The current image format in settings: png        The expected render outputs: John_Doe.png</p> </li> <li> <p>Check filename of render element ends with the name of    render element from the 3dsMax Render Element Manager.    e.g. The name of render element: RsCryptomatte     The expected filename: {InstanceName}_RsCryptomatte.png</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <code>workfile_name</code> <code>str</code> <p>filename of the Max scene</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of invalid filename which doesn't match with the project name</p> Source code in <code>client/ayon_max/plugins/publish/validate_renderpasses.py</code> <pre><code>@classmethod\ndef get_invalid(cls, instance):\n    \"\"\"Function to get invalid beauty render outputs and\n    render elements.\n\n    1. Check Render Output Folder matches the name of\n       the current Max Scene, e.g.\n         The name of the current Max scene:\n           John_Doe.max\n         The expected render output directory:\n           {root[work]}/{project[name]}/{hierarchy}/{asset}/\n           work/{task[name]}/render/3dsmax/John_Doe/\n\n    2. Check image extension(s) of the render output(s)\n       matches the image format in OP/AYON setting, e.g.\n           The current image format in settings: png\n           The expected render outputs: John_Doe.png\n\n    3. Check filename of render element ends with the name of\n       render element from the 3dsMax Render Element Manager.\n       e.g. The name of render element: RsCryptomatte\n        The expected filename: {InstanceName}_RsCryptomatte.png\n\n    Args:\n        instance (pyblish.api.Instance): instance\n        workfile_name (str): filename of the Max scene\n\n    Returns:\n        list: list of invalid filename which doesn't match\n            with the project name\n    \"\"\"\n    invalid = []\n    project_settings = instance.context.data[\"project_settings\"]\n    default_render_folder = Path(\n        get_default_render_folder(project_settings)\n    )\n    render_output = Path(rt.rendOutputFilename)\n    render_dir = render_output.parent\n    if default_render_folder != render_dir.parent:\n        invalid.append((\"Invalid render output folder\",\n                        os.path.dirname(rt.rendOutputFilename)))\n\n    renderer = instance.data[\"renderer\"]\n    beauty_fname = render_output.name\n    beauty_name, ext = os.path.splitext(beauty_fname)\n    invalid_filenames = cls.get_invalid_filenames(\n        instance, beauty_name, ext)\n    invalid.extend(invalid_filenames)\n    invalid_image_format = cls.get_invalid_image_format(\n        instance, ext.lstrip(\".\"))\n    invalid.extend(invalid_image_format)\n    if is_supported_renderer(renderer):\n        render_elem = rt.maxOps.GetCurRenderElementMgr()\n        render_elem_num = render_elem.NumRenderElements()\n        for i in range(render_elem_num):\n            renderlayer_name = render_elem.GetRenderElement(i)\n            renderpass = str(renderlayer_name).rsplit(\":\", 1)[-1]\n            rend_file = render_elem.GetRenderElementFilename(i)\n            if not rend_file:\n                continue\n            render_filename = os.path.basename(rend_file)\n            rend_fname, ext = os.path.splitext(render_filename)\n            invalid_image_format = cls.get_invalid_image_format(\n                instance, ext)\n            invalid_filenames = cls.get_invalid_filenames(\n                instance, rend_fname, ext, renderpass=renderpass,\n                render_filename=render_filename)\n            invalid.extend(invalid_filenames)\n            invalid.extend(invalid_image_format)\n\n    elif renderer == \"Arnold\":\n        cls.log.debug(\n            \"Renderpass validation does not support Arnold yet,\"\n            \" validation skipped...\")\n    elif renderer.startswith(\"V-Ray\"):\n        cls.log.debug(\n            \"Renderpass validation does not support V-Ray.\"\n            \" As V-Ray Frame Buffer takes care of this.\"\n        )\n    else:\n        cls.log.debug(\n            \"Skipping render element validation \"\n            f\"for renderer: {renderer}\")\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderpasses.html#client.ayon_max.plugins.publish.validate_renderpasses.ValidateRenderPasses.get_invalid_filenames","title":"<code>get_invalid_filenames(instance, file_name, ext, renderpass=None, render_filename=None)</code>  <code>classmethod</code>","text":"<p>Function to get invalid filenames from render outputs.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <code>file_name</code> <code>str</code> <p>name of the file</p> required <code>ext</code> <code>str</code> <p>image extension</p> required <code>renderpass</code> <code>str</code> <p>name of the renderpass. Defaults to None.</p> <code>None</code> <code>render_filename</code> <code>str</code> <p>render filename</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>invalid filenames</p> Source code in <code>client/ayon_max/plugins/publish/validate_renderpasses.py</code> <pre><code>@classmethod\ndef get_invalid_filenames(\n    cls, instance, file_name,\n    ext, renderpass=None,\n    render_filename=None):\n    \"\"\"Function to get invalid filenames from render outputs.\n\n    Args:\n        instance (pyblish.api.Instance): instance\n        file_name (str): name of the file\n        ext (str): image extension\n        renderpass (str, optional): name of the renderpass.\n            Defaults to None.\n        render_filename(str, optional): render filename\n\n    Returns:\n        list: invalid filenames\n    \"\"\"\n    invalid = []\n    if instance.name not in file_name:\n        cls.log.error(\"The renderpass filename should contain the instance name.\")\n        invalid.append((\"Invalid instance name\",\n                        file_name))\n    if renderpass is not None and render_filename is not None:\n        renderpass_token = f\"{renderpass}.{ext}\"\n        if not render_filename.endswith(renderpass_token):\n            cls.log.error(f\"{render_filename}: {renderpass_token}\")\n            cls.log.error(\n                f\"Filename for {renderpass} should \"\n                f\"end with {renderpass}: {render_filename}\"\n            )\n            invalid.append((f\"Invalid {renderpass}\",\n                            render_filename))\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_renderpasses.html#client.ayon_max.plugins.publish.validate_renderpasses.ValidateRenderPasses.get_invalid_image_format","title":"<code>get_invalid_image_format(instance, ext)</code>  <code>classmethod</code>","text":"<p>Function to check if the image format of the render outputs aligns with that in the setting.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <code>ext</code> <code>str</code> <p>image extension</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>list of files with invalid image format</p> Source code in <code>client/ayon_max/plugins/publish/validate_renderpasses.py</code> <pre><code>@classmethod\ndef get_invalid_image_format(cls, instance, ext):\n    \"\"\"Function to check if the image format of the render outputs\n    aligns with that in the setting.\n\n    Args:\n        instance (pyblish.api.Instance): instance\n        ext (str): image extension\n\n    Returns:\n        list: list of files with invalid image format\n    \"\"\"\n    invalid = []\n    settings = instance.context.data[\"project_settings\"].get(\"max\")\n    image_format = settings[\"RenderSettings\"][\"image_format\"]\n    ext = ext.lstrip(\".\")\n    if ext != image_format:\n        msg = (\n            f\"Invalid image format {ext} for render outputs.\\n\"\n            f\"Should be: {image_format}\")\n        cls.log.error(msg)\n        invalid.append((msg, ext))\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_resolution_setting.html","title":"validate_resolution_setting","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_resolution_setting.html#client.ayon_max.plugins.publish.validate_resolution_setting.ValidateResolutionSetting","title":"<code>ValidateResolutionSetting</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate the resolution setting aligned with DB</p> Source code in <code>client/ayon_max/plugins/publish/validate_resolution_setting.py</code> <pre><code>class ValidateResolutionSetting(pyblish.api.InstancePlugin,\n                                OptionalPyblishPluginMixin):\n    \"\"\"Validate the resolution setting aligned with DB\"\"\"\n\n    order = pyblish.api.ValidatorOrder - 0.01\n    families = [\"maxrender\"]\n    hosts = [\"max\"]\n    label = \"Validate Resolution Setting\"\n    optional = True\n    actions = [RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n        width, height = self.get_folder_resolution(instance)\n        current_width, current_height = (\n            self.get_current_resolution(instance)\n        )\n\n        if current_width != width and current_height != height:\n            raise PublishValidationError(\"Resolution Setting \"\n                                         \"not matching resolution \"\n                                         \"set on asset or shot.\")\n        if current_width != width:\n            raise PublishValidationError(\"Width in Resolution Setting \"\n                                         \"not matching resolution set \"\n                                         \"on asset or shot.\")\n\n        if current_height != height:\n            raise PublishValidationError(\"Height in Resolution Setting \"\n                                         \"not matching resolution set \"\n                                         \"on asset or shot.\")\n\n    def get_current_resolution(self, instance):\n        return rt.renderWidth, rt.renderHeight\n\n    @classmethod\n    def get_folder_resolution(cls, instance):\n        task_entity = instance.data.get(\"taskEntity\")\n        if task_entity:\n            task_attributes = task_entity[\"attrib\"]\n            width = task_attributes[\"resolutionWidth\"]\n            height = task_attributes[\"resolutionHeight\"]\n            return int(width), int(height)\n\n        # Defaults if not found in folder entity\n        return 1920, 1080\n\n    @classmethod\n    def repair(cls, instance):\n        reset_scene_resolution()\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_scene_saved.html","title":"validate_scene_saved","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_scene_saved.html#client.ayon_max.plugins.publish.validate_scene_saved.ValidateSceneSaved","title":"<code>ValidateSceneSaved</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate that workfile was saved.</p> Source code in <code>client/ayon_max/plugins/publish/validate_scene_saved.py</code> <pre><code>class ValidateSceneSaved(pyblish.api.InstancePlugin):\n    \"\"\"Validate that workfile was saved.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"workfile\"]\n    hosts = [\"max\"]\n    label = \"Validate Workfile is saved\"\n\n    def process(self, instance):\n        if not rt.maxFilePath or not rt.maxFileName:\n            raise PublishValidationError(\n                \"Workfile is not saved\", title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html","title":"validate_tyflow_data","text":""},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowData","title":"<code>ValidateTyFlowData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate TyFlow plugins or relevant operators are set correctly.</p> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>class ValidateTyFlowData(pyblish.api.InstancePlugin):\n    \"\"\"Validate TyFlow plugins or relevant operators are set correctly.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    families = [\"pointcloud\"]\n    hosts = [\"max\"]\n    label = \"TyFlow Data\"\n\n    def process(self, instance):\n        \"\"\"\n        Notes:\n            1. Validate the container only include tyFlow objects\n            2. Validate if tyFlow operator Export Particle exists\n\n        \"\"\"\n        errors = []\n        invalid_object = self.get_tyflow_object(instance)\n        if invalid_object:\n            errors.append(f\"Non tyFlow object found: {invalid_object}\")\n\n        invalid_operator = self.get_tyflow_operator(instance)\n        if invalid_operator:\n            errors.append(invalid_operator)\n        if errors:\n            bullet_point_invalid_statement = \"\\n\".join(\n                \"- {}\".format(error) for error\n                in errors\n            )\n            report = (\n                \"TyFlow Data has invalid values(s).\\n\\n\"\n                f\"{bullet_point_invalid_statement}\\n\\n\"\n            )\n            raise PublishValidationError(\n                report,\n                title=\"Invalid value(s) for TyFlow Data\")\n\n\n    def get_tyflow_object(self, instance):\n        \"\"\"Get the nodes which are not tyFlow object(s)\n        and editable mesh(es)\n\n        Args:\n            instance (pyblish.api.Instance): instance\n\n        Returns:\n            list: invalid nodes which are not tyFlow\n                object(s) and editable mesh(es).\n        \"\"\"\n        container = instance.data[\"instance_node\"]\n        self.log.debug(f\"Validating tyFlow container for {container}\")\n\n        allowed_classes = [rt.tyFlow, rt.Editable_Mesh]\n        return [\n            member for member in instance.data[\"members\"]\n            if rt.ClassOf(member) not in allowed_classes\n        ]\n\n    def get_tyflow_operator(self, instance):\n        \"\"\"Check if the Export Particle Operators in the node\n        connections.\n\n        Args:\n            instance (str): instance node\n\n        Returns:\n            invalid(list): list of invalid nodes which are not\n            export particle operators or with the invalid export\n            modes\n        \"\"\"\n        invalid = []\n        members = instance.data[\"members\"]\n        for member in members:\n            obj = member.baseobject\n            # There must be at least one animation with export\n            # particles enabled\n            anim_names = rt.GetSubAnimNames(obj)\n            has_export_particle = False\n            for anim_name in anim_names:\n                # get name of the related tyFlow node\n                sub_anim = rt.GetSubAnim(obj, anim_name)\n                # Isolate only the events\n                if not rt.isKindOf(sub_anim, rt.tyEvent):\n                    continue\n                # Look through all the nodes in the events\n                node_names = rt.GetSubAnimNames(sub_anim)\n                for node_name in node_names:\n                    node_sub_anim = rt.GetSubAnim(sub_anim, node_name)\n                    if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                        # check if the current export mode of the operator\n                        # is valid for the tycache export.\n                        if node_sub_anim.exportMode == 1 or \\\n                            node_sub_anim.exportMode == 2 or \\\n                                node_sub_anim.exportMode == 6:\n                            has_export_particle = True\n                            break\n\n            if has_export_particle:\n                break\n\n            if not has_export_particle:\n                invalid.append(f\"{member.name} has invalid Export Mode.\")\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowData.get_tyflow_object","title":"<code>get_tyflow_object(instance)</code>","text":"<p>Get the nodes which are not tyFlow object(s) and editable mesh(es)</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>invalid nodes which are not tyFlow object(s) and editable mesh(es).</p> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>def get_tyflow_object(self, instance):\n    \"\"\"Get the nodes which are not tyFlow object(s)\n    and editable mesh(es)\n\n    Args:\n        instance (pyblish.api.Instance): instance\n\n    Returns:\n        list: invalid nodes which are not tyFlow\n            object(s) and editable mesh(es).\n    \"\"\"\n    container = instance.data[\"instance_node\"]\n    self.log.debug(f\"Validating tyFlow container for {container}\")\n\n    allowed_classes = [rt.tyFlow, rt.Editable_Mesh]\n    return [\n        member for member in instance.data[\"members\"]\n        if rt.ClassOf(member) not in allowed_classes\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowData.get_tyflow_operator","title":"<code>get_tyflow_operator(instance)</code>","text":"<p>Check if the Export Particle Operators in the node connections.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>instance node</p> required <p>Returns:</p> Name Type Description <code>invalid</code> <code>list</code> <p>list of invalid nodes which are not</p> <p>export particle operators or with the invalid export</p> <p>modes</p> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>def get_tyflow_operator(self, instance):\n    \"\"\"Check if the Export Particle Operators in the node\n    connections.\n\n    Args:\n        instance (str): instance node\n\n    Returns:\n        invalid(list): list of invalid nodes which are not\n        export particle operators or with the invalid export\n        modes\n    \"\"\"\n    invalid = []\n    members = instance.data[\"members\"]\n    for member in members:\n        obj = member.baseobject\n        # There must be at least one animation with export\n        # particles enabled\n        anim_names = rt.GetSubAnimNames(obj)\n        has_export_particle = False\n        for anim_name in anim_names:\n            # get name of the related tyFlow node\n            sub_anim = rt.GetSubAnim(obj, anim_name)\n            # Isolate only the events\n            if not rt.isKindOf(sub_anim, rt.tyEvent):\n                continue\n            # Look through all the nodes in the events\n            node_names = rt.GetSubAnimNames(sub_anim)\n            for node_name in node_names:\n                node_sub_anim = rt.GetSubAnim(sub_anim, node_name)\n                if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                    # check if the current export mode of the operator\n                    # is valid for the tycache export.\n                    if node_sub_anim.exportMode == 1 or \\\n                        node_sub_anim.exportMode == 2 or \\\n                            node_sub_anim.exportMode == 6:\n                        has_export_particle = True\n                        break\n\n        if has_export_particle:\n            break\n\n        if not has_export_particle:\n            invalid.append(f\"{member.name} has invalid Export Mode.\")\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowData.process","title":"<code>process(instance)</code>","text":"Notes <ol> <li>Validate the container only include tyFlow objects</li> <li>Validate if tyFlow operator Export Particle exists</li> </ol> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Notes:\n        1. Validate the container only include tyFlow objects\n        2. Validate if tyFlow operator Export Particle exists\n\n    \"\"\"\n    errors = []\n    invalid_object = self.get_tyflow_object(instance)\n    if invalid_object:\n        errors.append(f\"Non tyFlow object found: {invalid_object}\")\n\n    invalid_operator = self.get_tyflow_operator(instance)\n    if invalid_operator:\n        errors.append(invalid_operator)\n    if errors:\n        bullet_point_invalid_statement = \"\\n\".join(\n            \"- {}\".format(error) for error\n            in errors\n        )\n        report = (\n            \"TyFlow Data has invalid values(s).\\n\\n\"\n            f\"{bullet_point_invalid_statement}\\n\\n\"\n        )\n        raise PublishValidationError(\n            report,\n            title=\"Invalid value(s) for TyFlow Data\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowTySplineData","title":"<code>ValidateTyFlowTySplineData</code>","text":"<p>               Bases: <code>ValidateTyFlowData</code></p> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>class ValidateTyFlowTySplineData(ValidateTyFlowData):\n    families = [\"tycache\", \"tyspline\"]\n    hosts = [\"max\"]\n    label = \"TyFlow Data (TyCache)\"\n\n    def process(self, instance):\n        \"\"\"\n        Notes:\n            1. Validate the container only include tyFlow objects\n            2. Validate if tyFlow operator Export Particle exists\n            3. Validate if tyFlow operator Spline Paths exists\n\n        \"\"\"\n        errors = []\n        invalid_operator = self.get_tyflow_operator(instance)\n        if invalid_operator:\n            errors.append(invalid_operator)\n        no_spline_nodes = self.get_invalid_tycache_spline_nodes(instance)\n        if no_spline_nodes:\n            errors.append(no_spline_nodes)\n        if errors:\n            bullet_point_invalid_statement = \"\\n\".join(\n                \"- {}\".format(error) for error\n                in errors\n            )\n            report = (\n                \"TyFlow Data has invalid values(s).\\n\\n\"\n                f\"{bullet_point_invalid_statement}\\n\\n\"\n            )\n            raise PublishValidationError(\n                report,\n                title=\"Invalid value(s) for TyFlow Data\")\n\n    def get_invalid_tycache_spline_nodes(self, instance):\n        \"\"\"Check if there is spline paths operators before the export\n\n        Args:\n            instance (pyblish.api.Instance): instance\n\n        Returns:\n            invalid: list of invalid nodes which are not\n            with spline paths operators\n        \"\"\"\n        invalid = []\n        node_sub_anim = instance.data[\"operator\"]\n        if node_sub_anim is not None:\n            if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                # check if the current export mode of the operator\n                # is valid for the tycache export.\n                if instance.data[\"exportMode\"] == 2:\n                    family = instance.data[\"productType\"]\n                    self.log.debug(\n                        \"Skipping checking spline path nodes \"\n                        f\"as this instance exports in {family} format\")\n                    return invalid\n            # check against the spline path node if\n            # the export mode is tyspline\n            if not rt.hasProperty(node_sub_anim, \"splinePathsNode\"):\n                invalid.append(\n                    f\"{node_sub_anim.name} has no tycache spline nodes.\")\n\n        return invalid\n\n    def get_tyflow_operator(self, instance):\n        invalid = []\n        node_sub_anim = instance.data[\"operator\"]\n        has_export_particle = []\n        if node_sub_anim is not None:\n            if rt.hasProperty(node_sub_anim, \"exportMode\"):\n                if node_sub_anim.exportMode == 2 or \\\n                        node_sub_anim.exportMode == 6:\n                    has_export_particle.append(\"True\")\n                else:\n                    has_export_particle.append(\"False\")\n                    if \"False\" in has_export_particle:\n                        invalid.append(\n                            f\"{node_sub_anim.name} has invalid Export Mode.\")\n\n        return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowTySplineData.get_invalid_tycache_spline_nodes","title":"<code>get_invalid_tycache_spline_nodes(instance)</code>","text":"<p>Check if there is spline paths operators before the export</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>instance</p> required <p>Returns:</p> Name Type Description <code>invalid</code> <p>list of invalid nodes which are not</p> <p>with spline paths operators</p> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>def get_invalid_tycache_spline_nodes(self, instance):\n    \"\"\"Check if there is spline paths operators before the export\n\n    Args:\n        instance (pyblish.api.Instance): instance\n\n    Returns:\n        invalid: list of invalid nodes which are not\n        with spline paths operators\n    \"\"\"\n    invalid = []\n    node_sub_anim = instance.data[\"operator\"]\n    if node_sub_anim is not None:\n        if rt.hasProperty(node_sub_anim, \"exportMode\"):\n            # check if the current export mode of the operator\n            # is valid for the tycache export.\n            if instance.data[\"exportMode\"] == 2:\n                family = instance.data[\"productType\"]\n                self.log.debug(\n                    \"Skipping checking spline path nodes \"\n                    f\"as this instance exports in {family} format\")\n                return invalid\n        # check against the spline path node if\n        # the export mode is tyspline\n        if not rt.hasProperty(node_sub_anim, \"splinePathsNode\"):\n            invalid.append(\n                f\"{node_sub_anim.name} has no tycache spline nodes.\")\n\n    return invalid\n</code></pre>"},{"location":"autoapi/client/ayon_max/plugins/publish/validate_tyflow_data.html#client.ayon_max.plugins.publish.validate_tyflow_data.ValidateTyFlowTySplineData.process","title":"<code>process(instance)</code>","text":"Notes <ol> <li>Validate the container only include tyFlow objects</li> <li>Validate if tyFlow operator Export Particle exists</li> <li>Validate if tyFlow operator Spline Paths exists</li> </ol> Source code in <code>client/ayon_max/plugins/publish/validate_tyflow_data.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Notes:\n        1. Validate the container only include tyFlow objects\n        2. Validate if tyFlow operator Export Particle exists\n        3. Validate if tyFlow operator Spline Paths exists\n\n    \"\"\"\n    errors = []\n    invalid_operator = self.get_tyflow_operator(instance)\n    if invalid_operator:\n        errors.append(invalid_operator)\n    no_spline_nodes = self.get_invalid_tycache_spline_nodes(instance)\n    if no_spline_nodes:\n        errors.append(no_spline_nodes)\n    if errors:\n        bullet_point_invalid_statement = \"\\n\".join(\n            \"- {}\".format(error) for error\n            in errors\n        )\n        report = (\n            \"TyFlow Data has invalid values(s).\\n\\n\"\n            f\"{bullet_point_invalid_statement}\\n\\n\"\n        )\n        raise PublishValidationError(\n            report,\n            title=\"Invalid value(s) for TyFlow Data\")\n</code></pre>"},{"location":"autoapi/client/ayon_max/startup/index.html","title":"startup","text":""},{"location":"autoapi/client/ayon_max/startup/startup.html","title":"startup","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/create_review_settings.html","title":"create_review_settings","text":""},{"location":"autoapi/server/settings/create_review_settings.html#server.settings.create_review_settings.anti_aliasing_enum","title":"<code>anti_aliasing_enum()</code>","text":"<p>Return enumerator for viewport anti-aliasing.</p> Source code in <code>server/settings/create_review_settings.py</code> <pre><code>def anti_aliasing_enum():\n    \"\"\"Return enumerator for viewport anti-aliasing.\"\"\"\n    return [\n        {\"label\": \"None\", \"value\": \"None\"},\n        {\"label\": \"2X\", \"value\": \"2X\"},\n        {\"label\": \"4X\", \"value\": \"4X\"},\n        {\"label\": \"8X\", \"value\": \"8X\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/create_review_settings.html#server.settings.create_review_settings.image_format_enum","title":"<code>image_format_enum()</code>","text":"<p>Return enumerator for image output formats.</p> Source code in <code>server/settings/create_review_settings.py</code> <pre><code>def image_format_enum():\n    \"\"\"Return enumerator for image output formats.\"\"\"\n    return [\n        {\"label\": \"exr\", \"value\": \"exr\"},\n        {\"label\": \"jpg\", \"value\": \"jpg\"},\n        {\"label\": \"png\", \"value\": \"png\"},\n        {\"label\": \"tga\", \"value\": \"tga\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/create_review_settings.html#server.settings.create_review_settings.preview_preset_enum","title":"<code>preview_preset_enum()</code>","text":"<p>Return enumerator for viewport visual preset.</p> Source code in <code>server/settings/create_review_settings.py</code> <pre><code>def preview_preset_enum():\n    \"\"\"Return enumerator for viewport visual preset.\"\"\"\n    return [\n        {\"label\": \"Quality\", \"value\": \"Quality\"},\n        {\"label\": \"Standard\", \"value\": \"Standard\"},\n        {\"label\": \"Performance\", \"value\": \"Performance\"},\n        {\"label\": \"DXMode\", \"value\": \"DXMode\"},\n        {\"label\": \"Customize\", \"value\": \"Customize\"},\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/create_review_settings.html#server.settings.create_review_settings.visual_style_enum","title":"<code>visual_style_enum()</code>","text":"<p>Return enumerator for viewport visual style.</p> Source code in <code>server/settings/create_review_settings.py</code> <pre><code>def visual_style_enum():\n    \"\"\"Return enumerator for viewport visual style.\"\"\"\n    return [\n        {\"label\": \"Realistic\", \"value\": \"Realistic\"},\n        {\"label\": \"Shaded\", \"value\": \"Shaded\"},\n        {\"label\": \"Facets\", \"value\": \"Facets\"},\n        {\"label\": \"ConsistentColors\",\n         \"value\": \"ConsistentColors\"},\n        {\"label\": \"Wireframe\", \"value\": \"Wireframe\"},\n        {\"label\": \"BoundingBox\", \"value\": \"BoundingBox\"},\n        {\"label\": \"Ink\", \"value\": \"Ink\"},\n        {\"label\": \"ColorInk\", \"value\": \"ColorInk\"},\n        {\"label\": \"Acrylic\", \"value\": \"Acrylic\"},\n        {\"label\": \"Tech\", \"value\": \"Tech\"},\n        {\"label\": \"Graphite\", \"value\": \"Graphite\"},\n        {\"label\": \"ColorPencil\", \"value\": \"ColorPencil\"},\n        {\"label\": \"Pastel\", \"value\": \"Pastel\"},\n        {\"label\": \"Clay\", \"value\": \"Clay\"},\n        {\"label\": \"ModelAssist\", \"value\": \"ModelAssist\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.unit_scale_enum","title":"<code>unit_scale_enum()</code>","text":"<p>Return enumerator for scene unit scale.</p> Source code in <code>server/settings/main.py</code> <pre><code>def unit_scale_enum():\n    \"\"\"Return enumerator for scene unit scale.\"\"\"\n    return [\n        {\"label\": \"mm\", \"value\": \"Millimeters\"},\n        {\"label\": \"cm\", \"value\": \"Centimeters\"},\n        {\"label\": \"m\", \"value\": \"Meters\"},\n        {\"label\": \"km\", \"value\": \"Kilometers\"}\n    ]\n</code></pre>"},{"location":"autoapi/server/settings/publishers.html","title":"publishers","text":""},{"location":"autoapi/server/settings/render_settings.html","title":"render_settings","text":""},{"location":"autoapi/server/settings/render_settings.html#server.settings.render_settings.image_format_enum","title":"<code>image_format_enum()</code>","text":"<p>Return enumerator for image output formats.</p> Source code in <code>server/settings/render_settings.py</code> <pre><code>def image_format_enum():\n    \"\"\"Return enumerator for image output formats.\"\"\"\n    return [\n        {\"label\": \"bmp\", \"value\": \"bmp\"},\n        {\"label\": \"exr\", \"value\": \"exr\"},\n        {\"label\": \"tif\", \"value\": \"tif\"},\n        {\"label\": \"tiff\", \"value\": \"tiff\"},\n        {\"label\": \"jpg\", \"value\": \"jpg\"},\n        {\"label\": \"png\", \"value\": \"png\"},\n        {\"label\": \"tga\", \"value\": \"tga\"},\n        {\"label\": \"dds\", \"value\": \"dds\"}\n    ]\n</code></pre>"}]}